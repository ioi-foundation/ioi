# IOI-SEC-2025-001 — Critical Replay Vulnerability in Misbehavior Reporting

**Date Published:** 2025-11-10  
**Severity:** Critical (CVSS 9.1)  
**CVSS Vector:** AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:H  
**Status:** ✅ Patched  
**Fixed In:** Commit [`32c05a8c`](https://github.com/ioi-network/ioi/commit/tbd)

---

## 1. Summary

A replay vulnerability was discovered in the **misbehavior reporting subsystem** of the IOI Kernel.  
The `evidence_id` mechanism — intended to provide replay protection for slashing events — could be bypassed by varying a non-canonical field (`probe_id`) within the `OffenseFacts` payload.

Attackers could repeatedly penalize a single validator by submitting multiple logically equivalent `FailureReport`s differing only in the arbitrary `probe_id` value.  
Each unique ID bypassed the registry and triggered another penalty, enabling repeated or total stake slashing, or in Proof-of-Authority mode, mass quarantining of validators.

---

## 2. Affected Components

| Layer | File | Impact |
|-------|------|---------|
| Types | `crates/types/src/app/penalties.rs` | Replay protection logic vulnerable to input mutation |
| Transaction Processing | `crates/tx/src/unified/mod.rs` | Accepts clid reports without verifying canonicality |
| Consensus Engines | `crates/consensus/src/proof_of_stake.rs`, `crates/consensus/src/proof_of_authority.rs` | Repeated penalties applied for same offense |
| Tests | `crates/cli/tests/penalty_pos_e2e.rs`, `crates/cli/tests/penalty_poa_e2e.rs` | Replay protection test passed under vulnerable assumptions |

---

## 3. Vulnerability Details

### Root Cause

The replay-protection identifier was computed from:

```rust
evidence_id = hash(offender, offense_type, facts)
````

However, the `facts` structure for a `FailedCalibrationProbe` offense included a **mutable reporter-supplied field**:

```rust
FailedCalibrationProbe { probe_id: [u8; 32] }
```

Since `probe_id` could be any arbitrary value chosen by the reporter, two distinct reports for the same event could produce different hashes and therefore different `evidence_id`s — effectively bypassing the replay registry.

### Exploit Scenario

1. Validator A observes an offense by validator B.
2. A submits a valid misbehavior report:

   ```rust
   probe_id = [0xAA; 32]
   ```
3. The chain penalizes B, stores the `evidence_id` derived from `probe_id = [0xAA; 32]`.
4. A re-submits the *same* report with:

   ```rust
   probe_id = [0xBB; 32]
   ```
5. The chain treats it as new evidence, applies another penalty, and adds a new `evidence_id`.

This can be repeated indefinitely, draining the offender’s stake or reducing the validator set below the liveness threshold.

---

## 4. Proof-of-Concept

A reproduction test (`test_pos_double_slashing_exploit`) demonstrates the exploit.
Two transactions differing only by `probe_id` cause two slashing events:

```rust
let (tx1, _) = create_report_tx_with_probe_id(..., [0xAA; 32]);
submit_transaction(&reporter_node.rpc_addr, &tx1).await?;
wait_for_stake_to_be(..., 90_000).await?; // first slash

let (tx2, _) = create_report_tx_with_probe_id(..., [0xBB; 32]);
submit_transaction(&reporter_node.rpc_addr, &tx2).await?;
wait_for_stake_to_be(..., 81_000).await?; // second slash — exploit success
```

---

## 5. Impact Assessment

| Vector        | Description                                                                                                               |
| ------------- | ------------------------------------------------------------------------------------------------------------------------- |
| **Economic**  | A malicious validator could repeatedly slash another validator’s stake to zero.                                           |
| **Liveness**  | Repeated penalties could remove active validators until the quorum threshold was no longer met, halting block production. |
| **Integrity** | Multiple valid proofs for a single offense created divergent chain state and broke deterministic replay protection.       |

---

## 6. Remediation

### Code Fix

1. **Canonicalized OffenseFacts**

   ```rust
   FailedCalibrationProbe {
       target_url: String,        // canonical lowercase probe target
       probe_timestamp: u64       // on-chain timestamp of probe block
   }
   ```

   The new fields are immutable and objectively verifiable.

2. **Sanity Checks**

   * Enforce canonical lowercase, trimmed URLs.
   * Reject future timestamps (relative to `ChainStatus.latest_timestamp`).

3. **Tests Updated**

   * `penalty_pos_e2e.rs` and `penalty_poa_e2e.rs` now construct canonical facts.
   * Added `get_chain_timestamp()` RPC helper for deterministic test timestamps.

### Patch Reference

* Commit: [`TBD`](https://github.com/ioi-network/ioi/commit/TBD)
* Modules: `types`, `tx`, `cli`
* Tag: `v0.1.0`

---

## 7. Verification

| Verification Step              | Result                                              |
| ------------------------------ | --------------------------------------------------- |
| Unit tests (penalty modules)   | ✅ Passed                                            |
| Replay exploit regression test | ✅ Second submission rejected (“Duplicate evidence”) |
| Network liveness check         | ✅ Chain continues producing blocks                  |
| Stake invariant                | ✅ No stake drained beyond intended single penalty   |

---

## 8. Timeline

| Date (UTC) | Event                                                        |
| ---------- | ------------------------------------------------------------ |
| 2025-11-07 | Vulnerability discovered during CLI PoS E2E replay testing |
| 2025-11-08 | Root cause confirmed (`probe_id` non-canonical)              |
| 2025-11-09 | Patch drafted, verified locally                              |
| 2025-11-10 | Commit merged and advisory published (IOI-SEC-2025-001)      |

---

## 9. Acknowledgements


---

## 10. References

* [CWE-345: Insufficient Verification of Data Authenticity](https://cwe.mitre.org/data/definitions/345.html)

---

*Document version:* 1.0
*Last updated:* 2025-11-10

```

