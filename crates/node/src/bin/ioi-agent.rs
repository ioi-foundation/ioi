// Path: crates/node/src/bin/ioi-agent.rs
#![forbid(unsafe_code)]

use anyhow::{anyhow, Result};
use clap::Parser;
use std::path::PathBuf;
use std::sync::Arc;
use tokio::time::Duration;

// IOI Imports
use ioi_api::vm::drivers::os::OsDriver;
use ioi_api::vm::inference::{HttpInferenceRuntime, InferenceRuntime};
use ioi_drivers::browser::BrowserDriver;
use ioi_drivers::gui::IoiGuiDriver;
use ioi_drivers::os::NativeOsDriver;
use ioi_drivers::terminal::TerminalDriver;
use ioi_scs::{SovereignContextStore, StoreConfig};
use ioi_services::agentic::desktop::DesktopAgentService;
use ioi_services::market::licensing::LicenseVerifier;
use ioi_types::app::{account_id_from_key_material, AccountId, SignatureSuite};
use ioi_validator::common::GuardianContainer;
use libp2p::identity;

// Include the manifest generated by build.rs
// Note: We read it from the embedded asset or fallback if build.rs didn't populate it (e.g. standard build).
// For the `ioi-agent` binary specifically, we expect `embedded_manifest.toml` to be present in OUT_DIR.
// We access it via include_bytes! relative to OUT_DIR.
const MANIFEST_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/embedded_manifest.toml"));

#[derive(Parser, Debug)]
#[clap(name = "ioi-agent", about = "IOI Service-as-a-Software Runtime")]
struct AgentOpts {
    #[clap(long, default_value = "./agent-data")]
    data_dir: PathBuf,

    /// RPC URL of the IOI Mainnet for license verification
    #[clap(
        long,
        env = "IOI_MAINNET_RPC",
        default_value = "https://rpc.ioi.network"
    )]
    mainnet_rpc: String,

    #[clap(long)]
    headless: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let _ = rustls::crypto::ring::default_provider().install_default();
    ioi_telemetry::init::init_tracing()?;
    let opts = AgentOpts::parse();
    std::fs::create_dir_all(&opts.data_dir)?;

    // 1. Load User Identity
    let key_path = opts.data_dir.join("user.key");
    let keypair = if key_path.exists() {
        let raw = GuardianContainer::load_encrypted_file(&key_path)?;
        identity::Keypair::from_protobuf_encoding(&raw)?
    } else {
        println!("‚ö†Ô∏è  No identity found. Generating new user key...");
        let kp = identity::Keypair::generate_ed25519();
        GuardianContainer::save_encrypted_file(&key_path, &kp.to_protobuf_encoding()?)?;
        kp
    };
    let pubkey_bytes = keypair.public().encode_protobuf();
    let account_id = AccountId(account_id_from_key_material(
        SignatureSuite::ED25519,
        &pubkey_bytes,
    )?);
    println!("üîë User ID: 0x{}", hex::encode(account_id));

    // 2. Parse Manifest & Asset Hash
    // If manifest bytes are empty (dev build), error out.
    if MANIFEST_BYTES.is_empty() {
        return Err(anyhow!(
            "Binary was built without an embedded manifest. Use `ioi-cli pack`."
        ));
    }

    let manifest: ioi_types::app::agentic::AgentManifest = toml::from_slice(MANIFEST_BYTES)
        .map_err(|e| anyhow!("Corrupt embedded workflow: {}", e))?;

    let asset_bytes = ioi_types::codec::to_bytes_canonical(&manifest).unwrap();
    let asset_hash_res = ioi_crypto::algorithms::hash::sha256(&asset_bytes)?;
    let mut asset_hash = [0u8; 32];
    asset_hash.copy_from_slice(asset_hash_res.as_ref());

    println!("üì¶ Starting: {} (v{})", manifest.name, manifest.version);
    println!("   Asset Hash: 0x{}", hex::encode(asset_hash));

    // 3. DRM Check
    // Fetch current root from RPC (Bootstrap trust anchor)
    // In production, this might be pinned in the binary or fetched via light client.
    let client = ioi_client::WorkloadClient::new(&opts.mainnet_rpc, "", "", "").await?;
    let trusted_root = client.get_state_root().await?;

    let verifier = LicenseVerifier::new(opts.mainnet_rpc.clone(), trusted_root.0);

    println!("üåê Verifying license on Mainnet...");
    match verifier.verify_license(account_id, asset_hash).await {
        Ok(true) => println!("‚úÖ License Verified (Merkle Proof Valid)."),
        Ok(false) => {
            println!("‚ùå ACCESS DENIED: You do not own a license for this agent.");
            println!(
                "   Please purchase it at: https://market.ioi.network/asset/0x{}",
                hex::encode(asset_hash)
            );
            // In a real build, we would exit here.
            // std::process::exit(1);
        }
        Err(e) => {
            println!("‚ö†Ô∏è  License Error: {}", e);
            // Decide fail-open or fail-closed based on config
        }
    }

    // 4. Initialize Local Hypervisor (SCS + Drivers)
    let scs_path = opts.data_dir.join("memory.scs");
    let ed_kp = keypair.clone().try_into_ed25519()?;
    let mut identity_key = [0u8; 32];
    identity_key.copy_from_slice(ed_kp.secret().as_ref());

    let scs_config = StoreConfig {
        chain_id: 0,
        owner_id: account_id.0,
        identity_key,
    };

    let scs = if scs_path.exists() {
        SovereignContextStore::open(&scs_path)?
    } else {
        SovereignContextStore::create(&scs_path, scs_config)?
    };
    let scs_arc = Arc::new(std::sync::Mutex::new(scs));

    // 5. Initialize Drivers & Lenses
    let os_driver = Arc::new(NativeOsDriver::new());

    // Initialize GUI driver mutably to register lenses
    let mut gui_driver_struct = IoiGuiDriver::new()
        .with_scs(scs_arc.clone())
        .with_som(true)
        .with_os_driver(os_driver.clone());

    // Register Custom Lenses from Manifest
    for lens_manifest in &manifest.custom_lenses {
        match lens_manifest {
            ioi_types::app::agentic::LensManifest::V1(config) => {
                let driver_config = ioi_drivers::gui::lenses::custom::LensConfig {
                    app_name: config.app_name.clone(),
                    mappings: config
                        .mappings
                        .iter()
                        .map(|(k, v)| {
                            (
                                k.clone(),
                                ioi_drivers::gui::lenses::custom::ElementSelector {
                                    role: v.role.clone(),
                                    name_contains: v.name_contains.clone(),
                                    id_pattern: v.id_pattern.clone(),
                                },
                            )
                        })
                        .collect(),
                };
                let lens = Box::new(ioi_drivers::gui::lenses::custom::ConfigurableLens::new(
                    driver_config,
                ));
                gui_driver_struct.register_lens(lens);
                log::info!("Registered custom UI lens for '{}'", config.app_name);
            }
        }
    }

    let gui_driver = Arc::new(gui_driver_struct);
    let browser_driver = Arc::new(BrowserDriver::new());
    let terminal_driver = Arc::new(TerminalDriver::new());

    // 6. Initialize Inference
    let inference_runtime: Arc<dyn InferenceRuntime> = Arc::new(HttpInferenceRuntime::new(
        "https://api.openai.com/v1/chat/completions".into(),
        std::env::var("OPENAI_API_KEY").unwrap_or_default(),
        manifest.model_selector.clone(),
    ));

    // 7. Start Embedded App (if enabled)
    if manifest.has_embedded_app && !opts.headless {
        let host = ioi_services::agentic::desktop::host::EmbeddedAppHost::start().await?;
        let entry = manifest.app_entrypoint.as_deref().unwrap_or("/");
        let url = format!("{}{}", host.get_url(), entry);

        println!("üñ•Ô∏è  Launching Embedded Interface: {}", url);

        // Note: In headless mode we skip the UI, but the host might still be needed for API access
        if !opts.headless {
            browser_driver.navigate(&url).await?;
        }
    }

    // 8. Launch the Agent Service
    let _agent_service = DesktopAgentService::new_hybrid(
        gui_driver,
        terminal_driver,
        browser_driver,
        inference_runtime.clone(),
        inference_runtime.clone(),
    )
    .with_scs(scs_arc.clone())
    .with_os_driver(os_driver.clone())
    .with_workspace_path(opts.data_dir.to_string_lossy().to_string());

    println!("üöÄ Service-as-a-Software Active.");

    // Keep alive
    loop {
        tokio::time::sleep(Duration::from_secs(1)).await;
    }
}
