// Path: crates/commitment/src/tree/hashmap/verifier.rs

use crate::primitives::hash::{HashCommitment, HashProof};
use crate::tree::hashmap::{HashMapStateTree, MerkleProof};
use depin_sdk_api::error::StateError;
use depin_sdk_api::state::Verifier;
use depin_sdk_types::app::Membership;

/// A stateless verifier for proofs generated by a `HashMapStateTree` using `HashCommitmentScheme`.
#[derive(Clone, Debug, Default)]
pub struct HashMapTreeHashVerifier;

impl Verifier for HashMapTreeHashVerifier {
    type Commitment = HashCommitment;
    type Proof = HashProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(HashCommitment::new(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> bool {
        let proof_data = proof.as_ref();

        // The proof data for this tree is a serialized MerkleProof struct.
        let merkle_proof: MerkleProof = match serde_json::from_slice(proof_data) {
            Ok(p) => p,
            Err(_) => {
                log::warn!(
                    "Failed to deserialize MerkleProof from proof data during verification."
                );
                return false;
            }
        };

        match outcome {
            Membership::Present(value) => {
                // For a proof of presence, we use the static verification function from the tree
                // to check if the provided leaf (key, value) hashes up to the trusted root
                // using the sibling hashes in the proof.
                HashMapStateTree::<crate::primitives::hash::HashCommitmentScheme>::verify_merkle_proof_static(
                    root.as_ref(),
                    key,
                    value,
                    &merkle_proof,
                )
            }
            Membership::Absent => {
                // This simple Merkle tree implementation does not support strong non-membership proofs.
                // A strong proof would require showing the existence of two adjacent keys between which
                // the queried key would lie, or proving that the path to the key leads to an empty hash.
                // Since this tree cannot provide such a proof, verification must always fail for Absent claims.
                log::trace!("HashMapStateTree does not support non-membership proofs; verification returns false for Absent outcome.");
                false
            }
        }
    }
}
