// Path: crates/commitment/src/tree/file/verifier.rs

use crate::primitives::hash::{HashCommitment, HashProof};
use crate::tree::file::FileStateTree;
use depin_sdk_api::error::StateError;
use depin_sdk_api::state::Verifier;
use depin_sdk_types::app::Membership;

/// A stateless verifier for proofs generated by a `FileStateTree` using `HashCommitmentScheme`.
#[derive(Clone, Debug, Default)]
pub struct FileTreeHashVerifier;

impl Verifier for FileTreeHashVerifier {
    type Commitment = HashCommitment;
    type Proof = HashProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(HashCommitment::new(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> bool {
        // This simple Merkle tree implementation doesn't have strong non-membership proofs.
        // It proves presence by reconstructing the root from a leaf and siblings.
        // Proving absence would require proving the existence of two adjacent leaves.
        let value = match outcome {
            Membership::Present(v) => v.as_slice(),
            Membership::Absent => return false, // Non-membership cannot be proven by this simple verifier.
        };

        // The proof logic is embedded in the tree's static method.
        // The HashProof's value field contains the serialized Merkle proof data.
        FileStateTree::<crate::primitives::hash::HashCommitmentScheme>::verify_merkle_proof_internal(
            root.as_ref(),
            &hex::encode(key),
            value,
            proof.as_ref(),
        )
    }
}
