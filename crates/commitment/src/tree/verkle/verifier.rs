// Path: crates/commitment/src/tree/verkle/verifier.rs
use crate::primitives::kzg::{KZGCommitment, KZGCommitmentScheme, KZGParams, KZGProof};
use crate::tree::verkle::proof::VerklePathProof;
use crate::tree::verkle::verify::verify_path_with_scheme;
use depin_sdk_api::error::StateError;
use depin_sdk_api::state::Verifier;
use depin_sdk_types::app::Membership;

/// A stateless verifier for proofs generated by a `VerkleTree` using a `KZGCommitmentScheme`.
#[derive(Clone, Debug)]
pub struct KZGVerifier {
    scheme: KZGCommitmentScheme,
}

impl KZGVerifier {
    /// Creates a new verifier with the necessary cryptographic parameters.
    pub fn new(params: KZGParams) -> Self {
        Self {
            scheme: KZGCommitmentScheme::new(params),
        }
    }
}

impl Verifier for KZGVerifier {
    type Commitment = KZGCommitment;
    type Proof = KZGProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(KZGCommitment::from(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof_obj: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> bool {
        let proof_bytes = proof_obj.as_ref();
        if proof_bytes.is_empty() {
            return false;
        }

        // Deserialize just to check the params_id and the terminal node against the outcome
        // before performing the more expensive cryptographic checks.
        let verkle_proof: VerklePathProof = match bincode::deserialize(proof_bytes) {
            Ok(p) => p,
            Err(e) => {
                log::warn!("Failed to deserialize VerklePathProof: {}", e);
                return false;
            }
        };

        // Pre-check 1: Ensure the proof was generated with the same parameters we are using.
        if verkle_proof.params_id != self.scheme.params.fingerprint() {
            log::warn!("Verkle proof SRS fingerprint mismatch.");
            return false;
        }

        // Pre-check 2: Ensure the outcome claimed by the Workload matches the proof's terminal node.
        let outcome_ok = match (outcome, &verkle_proof.terminal) {
            (Membership::Present(value), crate::tree::verkle::proof::Terminal::Leaf(payload)) => {
                value == payload
            }
            (Membership::Absent, crate::tree::verkle::proof::Terminal::Empty) => true,
            (
                Membership::Absent,
                crate::tree::verkle::proof::Terminal::Neighbor { key_stem, .. },
            ) => !key.starts_with(key_stem),
            _ => false, // Mismatched claim (e.g., Present) and proof type (e.g., Empty).
        };

        if !outcome_ok {
            log::warn!("Claimed membership outcome does not match Verkle proof's terminal node.");
            return false;
        }

        // Perform the full cryptographic verification.
        verify_path_with_scheme(
            &self.scheme,
            root,
            &self.scheme.params.fingerprint(),
            key,
            proof_bytes,
        )
    }
}
