// Path: crates/commitment/src/tree/verkle/verifier.rs
use crate::primitives::kzg::{KZGCommitment, KZGProof};
use crate::tree::verkle::verify::verify_path_with_scheme;
use depin_sdk_api::error::StateError;
use depin_sdk_api::state::Verifier;
use depin_sdk_types::app::Membership;

/// A stateless verifier for proofs generated by a `VerkleTree` using a `KZGCommitmentScheme`.
#[derive(Clone, Debug, Default)]
pub struct KZGVerifier;

impl Verifier for KZGVerifier {
    type Commitment = KZGCommitment;
    type Proof = KZGProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(KZGCommitment::from(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof_obj: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> bool {
        // This is a placeholder as the full Verkle proof verification logic is complex
        // and depends on the specific scheme parameters which aren't available here.
        // A real implementation would need access to the KZG parameters to verify the proof.
        // For now, we simulate a successful verification if the proof data is not empty.
        
        let proof_bytes = proof_obj.as_ref();
        
        // This is a simplified check. A real verifier would be much more involved.
        // We're essentially trusting the proof data for now.
        if proof_bytes.is_empty() {
            return false;
        }

        // A real implementation would look something like this:
        // let kzg_scheme = self.get_kzg_scheme_from_context_or_global();
        // verify_path_with_scheme(&kzg_scheme, root, &kzg_scheme.params.fingerprint(), key, proof_bytes)
        
        // For now, we just check if the outcome matches what a proof might contain.
        match outcome {
            Membership::Present(_) => !proof_bytes.is_empty(),
            Membership::Absent => !proof_bytes.is_empty(), // A non-membership proof also has data
        }
    }
}