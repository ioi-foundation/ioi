// Path: crates/ipc/proto/public/v1/public.proto
syntax = "proto3";
package ioi.public.v1;

// FIX: Updated import path to match new directory structure relative to 'crates/ipc/proto'
import "blockchain/v1/blockchain.proto";

service PublicApi {
  // Submit a transaction to the mempool/ingestion queue.
  // Returns immediately with a receipt (hash) or an approval request.
  rpc SubmitTransaction (SubmitTransactionRequest) returns (SubmitTransactionResponse);

  // Check the status of a transaction hash.
  rpc GetTransactionStatus (GetTransactionStatusRequest) returns (GetTransactionStatusResponse);

  // Proxy queries to the underlying Workload state (Merklized proof).
  rpc QueryState (ioi.blockchain.v1.QueryStateAtRequest) returns (ioi.blockchain.v1.QueryStateAtResponse);

  // Queries the raw state value directly from the latest committed state.
  rpc QueryRawState (ioi.blockchain.v1.QueryRawStateRequest) returns (ioi.blockchain.v1.QueryRawStateResponse);

  // Get the current status of the chain (Height, etc).
  rpc GetStatus (ioi.blockchain.v1.GetStatusRequest) returns (ioi.blockchain.v1.GetStatusResponse);

  // Get a block by its height.
  rpc GetBlockByHeight (GetBlockByHeightRequest) returns (GetBlockByHeightResponse);

  // [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
  // Critical for the "Visual Sovereignty" of the Autopilot GUI.
  rpc SubscribeEvents (SubscribeEventsRequest) returns (stream ChainEvent);

  // [NEW] Converts a natural language intent into a signable transaction payload.
  // This powers the "Commander Mode" search bar in the GUI.
  rpc DraftTransaction (DraftTransactionRequest) returns (DraftTransactionResponse);

  // [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
  // This allows the GUI to display the agent's visual memory.
  rpc GetContextBlob (GetContextBlobRequest) returns (GetContextBlobResponse);

  // Hydrate chat transcript messages for a specific session.
  rpc GetSessionHistory (GetSessionHistoryRequest) returns (GetSessionHistoryResponse);

  // Set an in-memory runtime secret scoped to a session (never persisted).
  rpc SetRuntimeSecret (SetRuntimeSecretRequest) returns (SetRuntimeSecretResponse);
}

message SubmitTransactionRequest {
    // Canonical SCALE-encoded bytes of the transaction.
    bytes transaction_bytes = 1;
}

message SubmitTransactionResponse {
    // SHA-256 hash of the transaction.
    // If status is PENDING_APPROVAL, this is the hash to sign in the ApprovalToken.
    string tx_hash = 1;
    
    // Indicates if the transaction was accepted, rejected, or requires 2FA.
    SubmissionStatus status = 2;
    
    // If PENDING_APPROVAL, this contains the human-readable reason (e.g. "Spend limit exceeded").
    string approval_reason = 3;
}

enum SubmissionStatus {
    ACCEPTED = 0;
    SUBMISSION_REJECTED = 1; // Renamed from REJECTED to avoid conflict
    PENDING_APPROVAL = 2; // "Suspended" state requiring user signature
}

message GetTransactionStatusRequest {
  string tx_hash = 1;
}

enum TxStatus {
  UNKNOWN = 0;
  PENDING = 1;
  IN_MEMPOOL = 2;
  COMMITTED = 3;
  REJECTED = 4;
}

message GetTransactionStatusResponse {
  TxStatus status = 1;
  string error_message = 2;
  uint64 block_height = 3;
}

message GetBlockByHeightRequest {
  uint64 height = 1;
}

message GetBlockByHeightResponse {
  bytes block_bytes = 1;
}

// --- Event Streaming Types ---

message SubscribeEventsRequest {
    // Optional filters could be added here (e.g. only "Action" events)
}

message ChainEvent {
    oneof event {
        // A block was successfully committed to the chain.
        BlockCommitted block = 1;
        
        // The agent is "thinking" (LLM token stream or internal monologue).
        AgentThought thought = 2;
        
        // The firewall intercepted an action.
        ActionIntercepted action = 3;
        
        // The status of a service or policy changed.
        SystemUpdate system = 4;

        // The user performed a physical input while in Ghost Mode.
        GhostInput ghost = 5;

        // The result of an executed action.
        AgentActionResult action_result = 6;

        // [NEW] A new sub-agent was spawned (delegation).
        AgentSpawn spawn = 7;

        // [NEW] Typed parity routing receipt for an action step.
        RoutingReceipt routing_receipt = 8;

        // [NEW] Structured workload activity stream for orchestration (lifecycle/stdio).
        WorkloadActivity workload_activity = 10;

        // [NEW] Workload receipt stream for auditable actions (exec/fs/net).
        WorkloadReceipt workload_receipt = 11;
    }
}

message BlockCommitted {
    uint64 height = 1;
    string state_root = 2; // Hex
    uint64 tx_count = 3;
}

message AgentThought {
    string session_id = 1; // Hex
    string content = 2;    // The text token or reasoning step
    bool is_final = 3;     // True if this concludes the thought
    // The hash of the visual context (screenshot) associated with this step.
    string visual_hash = 4;
}

message ActionIntercepted {
    string session_id = 1;
    string target = 2;     // e.g. "net::fetch"
    string verdict = 3;    // "ALLOW", "BLOCK", "REQUIRE_APPROVAL"
    string reason = 4;
}

message SystemUpdate {
    string component = 1;  // e.g. "P2P", "Mempool"
    string status = 2;
}

message GhostInput {
    string device = 1;      // "mouse", "keyboard"
    string description = 2; // "Click(100, 200)", "Type('hello')"
}

message AgentActionResult {
    string session_id = 1; // Hex
    uint32 step_index = 2;
    string tool_name = 3;
    string output = 4;
    // [NEW] The authoritative lifecycle state after this action.
    // e.g. "Running", "Paused", "Completed", "Failed"
    string agent_status = 5; 
}

// --- Workload Orchestration Events ---

message WorkloadActivity {
    string session_id = 1; // Hex
    uint32 step_index = 2;
    string workload_id = 3;
    uint64 timestamp_ms = 4;

    oneof kind {
        WorkloadLifecycle lifecycle = 10;
        WorkloadStdio stdio = 11;
    }
}

message WorkloadLifecycle {
    string phase = 1; // started|detached|completed|failed
    int32 exit_code = 2;
    bool has_exit_code = 3;
}

message WorkloadStdio {
    string stream = 1; // stdout|stderr|status
    string chunk = 2;
    uint64 seq = 3;
    bool is_final = 4;
    int32 exit_code = 5;
    bool has_exit_code = 6;
}

message WorkloadReceipt {
    string session_id = 1; // Hex
    uint32 step_index = 2;
    string workload_id = 3;
    uint64 timestamp_ms = 4;

    oneof receipt {
        WorkloadExecReceipt exec = 10;
        WorkloadNetFetchReceipt net_fetch = 11;
    }
}

message WorkloadExecReceipt {
    string tool_name = 1;
    string command = 2;
    repeated string args = 3;
    string cwd = 4;
    bool detach = 5;
    uint64 timeout_ms = 6;
    bool success = 7;
    int32 exit_code = 8;
    bool has_exit_code = 9;
    string error_class = 10;
    bool has_error_class = 11;
    string command_preview = 12;
}

message WorkloadNetFetchReceipt {
    string tool_name = 1;      // "net__fetch"
    string method = 2;         // "GET"
    string requested_url = 3;  // redacted/scrubbed

    string final_url = 4;      // redacted/scrubbed
    bool has_final_url = 5;

    uint32 status_code = 6;
    bool has_status_code = 7;

    string content_type = 8;
    bool has_content_type = 9;

    uint32 max_chars = 10;
    uint64 max_bytes = 11;
    uint64 bytes_read = 12;
    bool truncated = 13;
    uint64 timeout_ms = 14;

    bool success = 15;

    string error_class = 16;
    bool has_error_class = 17;
}

// [NEW] Message for agent spawning
message AgentSpawn {
    string parent_session_id = 1; // Hex
    string new_session_id = 2;    // Hex
    string name = 3;
    string role = 4;
    uint64 budget = 5;
    string goal = 6;
}

enum RoutingFailureClass {
    ROUTING_FAILURE_CLASS_UNSPECIFIED = 0;
    ROUTING_FAILURE_CLASS_FOCUS_MISMATCH = 1;
    ROUTING_FAILURE_CLASS_TARGET_NOT_FOUND = 2;
    ROUTING_FAILURE_CLASS_PERMISSION_OR_APPROVAL_REQUIRED = 3;
    ROUTING_FAILURE_CLASS_TOOL_UNAVAILABLE = 4;
    ROUTING_FAILURE_CLASS_NON_DETERMINISTIC_UI = 5;
    ROUTING_FAILURE_CLASS_UNEXPECTED_STATE = 6;
    ROUTING_FAILURE_CLASS_TIMEOUT_OR_HANG = 7;
    ROUTING_FAILURE_CLASS_USER_INTERVENTION_NEEDED = 8;
    ROUTING_FAILURE_CLASS_VISION_TARGET_NOT_FOUND = 9;
    ROUTING_FAILURE_CLASS_NO_EFFECT_AFTER_ACTION = 10;
    ROUTING_FAILURE_CLASS_TIER_VIOLATION = 11;
    ROUTING_FAILURE_CLASS_MISSING_DEPENDENCY = 12;
    ROUTING_FAILURE_CLASS_CONTEXT_DRIFT = 13;
}

message RoutingStateSummary {
    string agent_status = 1;
    string tier = 2;
    uint32 step_index = 3;
    uint32 consecutive_failures = 4;
    string target_hint = 5;
}

message RoutingPostStateSummary {
    string agent_status = 1;
    string tier = 2;
    uint32 step_index = 3;
    uint32 consecutive_failures = 4;
    bool success = 5;
    repeated string verification_checks = 6;
}

message RoutingReceipt {
    string session_id = 1; // Hex
    uint32 step_index = 2;
    string intent_hash = 3;
    string policy_decision = 4;
    string tool_name = 5;
    string tool_version = 6;
    RoutingStateSummary pre_state = 7;
    string action_json = 8;
    RoutingPostStateSummary post_state = 9;
    repeated string artifacts = 10;
    RoutingFailureClass failure_class = 11;
    bool has_failure_class = 12;
    bool stop_condition_hit = 13;
    string escalation_path = 14;
    string scs_lineage_ptr = 15;
    string mutation_receipt_ptr = 16;
    string policy_binding_hash = 17;
    string policy_binding_sig = 18;
    string policy_binding_signer = 19;
    string failure_class_name = 20;
    string intent_class = 21;
    string incident_id = 22;
    string incident_stage = 23;
    string strategy_name = 24;
    string strategy_node = 25;
    string gate_state = 26;
    string resolution_action = 27;
}

// --- Intent Drafting Types ---

message DraftTransactionRequest {
    // Natural language intent (e.g., "Send 50 tokens to Bob").
    string intent = 1;
    // Optional context to resolve names (e.g., "Bob" -> 0x123...).
    map<string, string> address_book = 2;
}

message DraftTransactionResponse {
    // The constructed, unsigned transaction bytes (SCALE encoded).
    bytes transaction_bytes = 1;
    
    // A structured summary for the UI to display before signing.
    string summary_markdown = 2;
    
    // The list of capabilities this transaction requires (for Policy check).
    repeated string required_capabilities = 3;
}

// --- Blob Retrieval Types ---

message GetContextBlobRequest {
  // Hex-encoded SHA-256 hash of the blob (e.g., visual_hash).
  string blob_hash = 1; 
}

message GetContextBlobResponse {
  // Raw bytes of the blob (e.g., PNG image).
  bytes data = 1;
  // Suggested MIME type (e.g. "image/png"). 
  // In a real implementation, this might be inferred or stored in metadata.
  string mime_type = 2; 
}

message GetSessionHistoryRequest {
  string session_id_hex = 1;
  uint32 limit = 2;
  bool ascending = 3;
}

message SessionHistoryMessage {
  string role = 1;
  string content = 2;
  uint64 timestamp = 3;
}

message GetSessionHistoryResponse {
  repeated SessionHistoryMessage messages = 1;
}

message SetRuntimeSecretRequest {
  string session_id_hex = 1;
  string secret_kind = 2;
  string secret_value = 3;
  bool one_time = 4;
  uint32 ttl_seconds = 5;
}

message SetRuntimeSecretResponse {
  bool accepted = 1;
}
