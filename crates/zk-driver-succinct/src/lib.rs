// Path: crates/zk-driver-succinct/src/lib.rs

use anyhow::{anyhow, Result};
use dcrypt::algorithms::hash::{HashFunction, Sha256};
use ioi_api::{error::CoreError, ibc::IbcZkVerifier, zk::ZkProofSystem};
use ioi_types::ibc::StateProofScheme;

/// A dummy ZK backend for simulation, fulfilling the ZkProofSystem trait.
/// In production, this would be a wrapper around `arkworks` or `bellman`.
#[derive(Debug, Clone, Default)]
pub struct SimulatedGroth16;

impl ZkProofSystem for SimulatedGroth16 {
    type Proof = Vec<u8>;
    type VerifyingKey = (); // Mock
    type PublicInputs = Vec<u8>;

    fn verify(
        _vk: &Self::VerifyingKey,
        proof: &Self::Proof,
        public_inputs: &Self::PublicInputs,
    ) -> Result<bool, ioi_api::error::CryptoError> {
        // Simulation: Check hash preimage using dcrypt.
        // In real Groth16: verify_proof(vk, proof, public_inputs)

        // FIX 1: Explicitly map the dcrypt error to CryptoError
        let hash = Sha256::digest(proof)
            .map_err(|e| ioi_api::error::CryptoError::OperationFailed(e.to_string()))?;

        // FIX 2: Use as_ref() to get the slice from the Digest
        Ok(hash.as_ref() == public_inputs.as_slice())
    }
}

/// A driver that verifies proofs generated by the Succinct platform.
/// It implements the domain-specific `IbcZkVerifier` trait using the generic `SimulatedGroth16` backend.
#[derive(Debug, Clone, Default)]
pub struct SuccinctDriver;

impl SuccinctDriver {
    pub fn new() -> Self {
        Self
    }
}

impl IbcZkVerifier for SuccinctDriver {
    fn verify_beacon_update(&self, proof: &[u8], public_inputs: &[u8]) -> Result<(), CoreError> {
        // Delegate the math to the ZK Backend (Blueprint 5.2)
        let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &public_inputs.to_vec())
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

        if !valid {
            return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
        }
        Ok(())
    }

    fn verify_state_inclusion(
        &self,
        _scheme: StateProofScheme,
        proof: &[u8],
        root: [u8; 32],
    ) -> Result<(), CoreError> {
        // Delegate the math to the ZK Backend
        let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &root.to_vec())
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

        if !valid {
            return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
        }
        Ok(())
    }
}
