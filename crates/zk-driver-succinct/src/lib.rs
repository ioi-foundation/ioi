// Path: crates/zk-driver-succinct/src/lib.rs

pub mod config;
#[cfg(feature = "native")]
pub mod sp1_backend;

use crate::config::SuccinctDriverConfig;
use anyhow::Result;
use dcrypt::algorithms::hash::{HashFunction, Sha256};
use ioi_api::{error::CoreError, ibc::IbcZkVerifier, zk::ZkProofSystem};
use ioi_types::ibc::StateProofScheme;
use std::sync::Arc;

/// A dummy ZK backend for simulation, fulfilling the ZkProofSystem trait.
/// In production, this would be a wrapper around `arkworks` or `bellman`.
#[derive(Debug, Clone, Default)]
pub struct SimulatedGroth16;

impl ZkProofSystem for SimulatedGroth16 {
    type Proof = Vec<u8>;
    type VerifyingKey = (); // Mock
    type PublicInputs = Vec<u8>;

    fn verify(
        _vk: &Self::VerifyingKey,
        proof: &Self::Proof,
        public_inputs: &Self::PublicInputs,
    ) -> Result<bool, ioi_api::error::CryptoError> {
        // Simulation: Check hash preimage using dcrypt.
        // In real Groth16: verify_proof(vk, proof, public_inputs)

        // Explicitly map the dcrypt error to CryptoError
        let hash = Sha256::digest(proof)
            .map_err(|e| ioi_api::error::CryptoError::OperationFailed(e.to_string()))?;

        // Use as_ref() to get the slice from the Digest
        Ok(hash.as_ref() == public_inputs.as_slice())
    }
}

/// A driver that verifies proofs generated by the Succinct platform.
/// It implements the domain-specific `IbcZkVerifier` trait.
///
/// When compiled with `feature = "native"`, it delegates to the actual SP1 verifier.
/// Otherwise, it uses the `SimulatedGroth16` backend for testing.
#[derive(Debug, Clone)]
pub struct SuccinctDriver {
    config: Arc<SuccinctDriverConfig>,
}

impl SuccinctDriver {
    /// Create a new driver with specific verification keys.
    pub fn new(config: SuccinctDriverConfig) -> Self {
        Self {
            config: Arc::new(config),
        }
    }

    /// Create a mock driver with default (placeholder) configuration.
    pub fn new_mock() -> Self {
        Self::new(SuccinctDriverConfig::default())
    }
}

impl Default for SuccinctDriver {
    fn default() -> Self {
        Self::new_mock()
    }
}

impl IbcZkVerifier for SuccinctDriver {
    fn verify_beacon_update(&self, proof: &[u8], public_inputs: &[u8]) -> Result<(), CoreError> {
        #[cfg(feature = "native")]
        {
            use crate::sp1_backend::Sp1ProofSystem;
            // In native mode, verify the SP1 proof against the configured vkey.
            let valid = Sp1ProofSystem::verify(
                &self.config.beacon_vkey_hash,
                &proof.to_vec(),
                &public_inputs.to_vec(),
            )
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("SP1 Beacon Verification Failed".into()));
            }
            Ok(())
        }

        #[cfg(not(feature = "native"))]
        {
            // In mock mode, delegate to the simulation backend (hash check).
            let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &public_inputs.to_vec())
                .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
            }
            Ok(())
        }
    }

    fn verify_state_inclusion(
        &self,
        _scheme: StateProofScheme,
        proof: &[u8],
        root: [u8; 32],
    ) -> Result<(), CoreError> {
        #[cfg(feature = "native")]
        {
            use crate::sp1_backend::Sp1ProofSystem;
            // In native mode, verify the SP1 proof against the configured vkey.
            // Note: The circuit must be written to output the root as public values
            // in the exact serialization format matching `root.to_vec()`.
            let valid = Sp1ProofSystem::verify(
                &self.config.state_inclusion_vkey_hash,
                &proof.to_vec(),
                &root.to_vec(),
            )
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("SP1 State Verification Failed".into()));
            }
            Ok(())
        }

        #[cfg(not(feature = "native"))]
        {
            // In mock mode, delegate to the simulation backend (hash check).
            let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &root.to_vec())
                .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
            }
            Ok(())
        }
    }
}
