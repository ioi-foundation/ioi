// Path: crates/zk-driver-succinct/src/lib.rs

pub mod config;
#[cfg(feature = "native")]
pub mod sp1_backend;

use crate::config::SuccinctDriverConfig;
use anyhow::Result;
use dcrypt::algorithms::hash::{HashFunction, Sha256};
use ioi_api::{error::CoreError, ibc::IbcZkVerifier, zk::ZkProofSystem};
use ioi_types::ibc::StateProofScheme;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

// --- Canonical Public Input Definitions ---

/// The public inputs expected by the Ethereum Beacon Update circuit.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BeaconPublicInputs {
    /// The trusted state root before this update.
    pub previous_state_root: [u8; 32],
    /// The new state root being attested to.
    pub new_state_root: [u8; 32],
    /// The slot number of the new header.
    pub slot: u64,
}

/// The public inputs expected by the State Inclusion circuit.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct StateInclusionPublicInputs {
    /// The state root against which inclusion is being proven.
    pub state_root: [u8; 32],
    /// The key being verified.
    pub key: Vec<u8>,
    /// The value being verified.
    pub value: Vec<u8>,
    /// The proof scheme identifier (0=Mpt, 1=Verkle).
    pub scheme_id: u8,
}

/// A dummy ZK backend for simulation, fulfilling the ZkProofSystem trait.
#[derive(Debug, Clone, Default)]
pub struct SimulatedGroth16;

impl ZkProofSystem for SimulatedGroth16 {
    type Proof = Vec<u8>;
    type VerifyingKey = (); // Mock
    type PublicInputs = Vec<u8>;

    fn verify(
        _vk: &Self::VerifyingKey,
        proof: &Self::Proof,
        public_inputs: &Self::PublicInputs,
    ) -> Result<bool, ioi_api::error::CryptoError> {
        // Simulation Rule: hash(proof) == state_root
        // We need to extract the `state_root` from the serialized `public_inputs`.

        // Try to interpret inputs as BeaconPublicInputs
        let target_root: [u8; 32] = if let Ok(inputs) =
            bincode::deserialize::<BeaconPublicInputs>(public_inputs)
        {
            inputs.new_state_root
        }
        // Try to interpret inputs as StateInclusionPublicInputs
        else if let Ok(inputs) = bincode::deserialize::<StateInclusionPublicInputs>(public_inputs)
        {
            inputs.state_root
        }
        // Fallback for legacy tests where inputs ARE the root bytes directly
        else if public_inputs.len() == 32 {
            let mut root = [0u8; 32];
            root.copy_from_slice(public_inputs);
            root
        } else {
            return Err(ioi_api::error::CryptoError::InvalidInput(
                "Public inputs could not be deserialized to known struct or root".into(),
            ));
        };

        // Check if SHA256(proof) matches the target root
        let hash = Sha256::digest(proof)
            .map_err(|e| ioi_api::error::CryptoError::OperationFailed(e.to_string()))?;

        Ok(hash.as_ref() == target_root.as_slice())
    }
}

/// A driver that verifies proofs generated by the Succinct platform.
#[derive(Debug, Clone)]
pub struct SuccinctDriver {
    config: Arc<SuccinctDriverConfig>,
}

impl SuccinctDriver {
    pub fn new(config: SuccinctDriverConfig) -> Self {
        Self {
            config: Arc::new(config),
        }
    }

    pub fn new_mock() -> Self {
        Self::new(SuccinctDriverConfig::default())
    }
}

impl Default for SuccinctDriver {
    fn default() -> Self {
        Self::new_mock()
    }
}

impl IbcZkVerifier for SuccinctDriver {
    fn verify_beacon_update(&self, proof: &[u8], public_inputs: &[u8]) -> Result<(), CoreError> {
        #[cfg(feature = "native")]
        {
            use crate::sp1_backend::Sp1ProofSystem;
            // In native mode, verify the SP1 proof against the configured vkey.
            let valid = Sp1ProofSystem::verify(
                &self.config.beacon_vkey_bytes,
                &proof.to_vec(),
                &public_inputs.to_vec(),
            )
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("SP1 Beacon Verification Failed".into()));
            }
            Ok(())
        }

        #[cfg(not(feature = "native"))]
        {
            // In mock mode, delegate to the simulation backend.
            let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &public_inputs.to_vec())
                .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
            }
            Ok(())
        }
    }

    fn verify_state_inclusion(
        &self,
        scheme: StateProofScheme,
        proof: &[u8],
        root: [u8; 32],
    ) -> Result<(), CoreError> {
        // Construct the canonical input struct locally.
        // Note: key/value are empty because the upstream trait doesn't pass them yet.
        let inputs = StateInclusionPublicInputs {
            state_root: root,
            key: vec![],
            value: vec![],
            scheme_id: match scheme {
                StateProofScheme::Mpt => 0,
                StateProofScheme::Verkle => 1,
            },
        };

        let inputs_bytes = bincode::serialize(&inputs)
            .map_err(|e| CoreError::Custom(format!("Serialization failed: {}", e)))?;

        #[cfg(feature = "native")]
        {
            use crate::sp1_backend::Sp1ProofSystem;
            let valid = Sp1ProofSystem::verify(
                &self.config.state_inclusion_vkey_bytes,
                &proof.to_vec(),
                &inputs_bytes,
            )
            .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("SP1 State Verification Failed".into()));
            }
            Ok(())
        }

        #[cfg(not(feature = "native"))]
        {
            // Mock mode: verify hash(proof) == inputs.root
            let valid = SimulatedGroth16::verify(&(), &proof.to_vec(), &inputs_bytes)
                .map_err(|e| CoreError::Crypto(e.to_string()))?;

            if !valid {
                return Err(CoreError::Custom("ZK Proof Verification Failed".into()));
            }
            Ok(())
        }
    }
}
