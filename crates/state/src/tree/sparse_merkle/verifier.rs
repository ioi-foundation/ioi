// Path: crates/commitment/src/tree/sparse_merkle/verifier.rs

use crate::primitives::hash::{HashCommitment, HashCommitmentScheme, HashProof};
use crate::tree::sparse_merkle::{SparseMerkleProof, SparseMerkleTree};
use ioi_types::app::Membership;
use ioi_types::error::ProofError;
use ioi_api::error::StateError;
use ioi_api::state::Verifier;
use parity_scale_codec::Decode;

/// A stateless verifier for proofs generated by a `SparseMerkleTree` using a `HashCommitmentScheme`.
#[derive(Clone, Debug, Default)]
pub struct SparseMerkleVerifier;

impl Verifier for SparseMerkleVerifier {
    type Commitment = HashCommitment;
    type Proof = HashProof;

    fn commitment_from_bytes(&self, bytes: &[u8]) -> Result<Self::Commitment, StateError> {
        Ok(HashCommitment::new(bytes.to_vec()))
    }

    fn verify(
        &self,
        root: &Self::Commitment,
        proof_obj: &Self::Proof,
        key: &[u8],
        outcome: &Membership,
    ) -> Result<(), ProofError> {
        let root_hash = root.as_ref();
        // The `create_proof` method in the SMT serializes the `SparseMerkleProof` struct
        // into the `value` field of the generic `HashProof`. We deserialize it here.
        let proof_data = proof_obj.value();

        let smt_proof: SparseMerkleProof =
            SparseMerkleProof::decode(&mut &*proof_data).map_err(|e| {
                log::warn!(
                    "Failed to deserialize SparseMerkleProof from proof data during verification: {}",
                    e
                );
                ProofError::Deserialization(e.to_string())
            })?;

        // The `verify_proof_static` function is designed to handle both presence and absence.
        // We map the Membership enum to the Option<&[u8]> it expects.
        let value_to_verify = match outcome {
            Membership::Present(v) => Some(v.as_slice()),
            Membership::Absent => None,
        };

        // Delegate to the tree's static, pure verification logic.
        match SparseMerkleTree::<HashCommitmentScheme>::verify_proof_static(
            root_hash,
            key,
            value_to_verify,
            &smt_proof,
        ) {
            Ok(true) => Ok(()), // The proof is valid for the given outcome.
            Ok(false) => Err(ProofError::RootMismatch), // The proof is valid but doesn't match the root.
            Err(e) => {
                log::warn!("[SMTVerifier] Proof verification failed with error: {}", e);
                Err(e) // Propagate the specific error from the verifier function.
            }
        }
    }
}
