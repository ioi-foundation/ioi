// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.12.4
// source: public/v1/public.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import {
  GetStatusRequest,
  GetStatusResponse,
  QueryRawStateRequest,
  QueryRawStateResponse,
  QueryStateAtRequest,
  QueryStateAtResponse,
} from "../../blockchain/v1/blockchain";

export const protobufPackage = "ioi.public.v1";

/** Path: crates/ipc/proto/public/v1/public.proto */

export enum SubmissionStatus {
  ACCEPTED = 0,
  /** SUBMISSION_REJECTED - Renamed from REJECTED to avoid conflict */
  SUBMISSION_REJECTED = 1,
  /** PENDING_APPROVAL - "Suspended" state requiring user signature */
  PENDING_APPROVAL = 2,
  UNRECOGNIZED = -1,
}

export function submissionStatusFromJSON(object: any): SubmissionStatus {
  switch (object) {
    case 0:
    case "ACCEPTED":
      return SubmissionStatus.ACCEPTED;
    case 1:
    case "SUBMISSION_REJECTED":
      return SubmissionStatus.SUBMISSION_REJECTED;
    case 2:
    case "PENDING_APPROVAL":
      return SubmissionStatus.PENDING_APPROVAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubmissionStatus.UNRECOGNIZED;
  }
}

export function submissionStatusToJSON(object: SubmissionStatus): string {
  switch (object) {
    case SubmissionStatus.ACCEPTED:
      return "ACCEPTED";
    case SubmissionStatus.SUBMISSION_REJECTED:
      return "SUBMISSION_REJECTED";
    case SubmissionStatus.PENDING_APPROVAL:
      return "PENDING_APPROVAL";
    case SubmissionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TxStatus {
  UNKNOWN = 0,
  PENDING = 1,
  IN_MEMPOOL = 2,
  COMMITTED = 3,
  REJECTED = 4,
  UNRECOGNIZED = -1,
}

export function txStatusFromJSON(object: any): TxStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TxStatus.UNKNOWN;
    case 1:
    case "PENDING":
      return TxStatus.PENDING;
    case 2:
    case "IN_MEMPOOL":
      return TxStatus.IN_MEMPOOL;
    case 3:
    case "COMMITTED":
      return TxStatus.COMMITTED;
    case 4:
    case "REJECTED":
      return TxStatus.REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TxStatus.UNRECOGNIZED;
  }
}

export function txStatusToJSON(object: TxStatus): string {
  switch (object) {
    case TxStatus.UNKNOWN:
      return "UNKNOWN";
    case TxStatus.PENDING:
      return "PENDING";
    case TxStatus.IN_MEMPOOL:
      return "IN_MEMPOOL";
    case TxStatus.COMMITTED:
      return "COMMITTED";
    case TxStatus.REJECTED:
      return "REJECTED";
    case TxStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RoutingFailureClass {
  ROUTING_FAILURE_CLASS_UNSPECIFIED = 0,
  ROUTING_FAILURE_CLASS_FOCUS_MISMATCH = 1,
  ROUTING_FAILURE_CLASS_TARGET_NOT_FOUND = 2,
  ROUTING_FAILURE_CLASS_PERMISSION_OR_APPROVAL_REQUIRED = 3,
  ROUTING_FAILURE_CLASS_TOOL_UNAVAILABLE = 4,
  ROUTING_FAILURE_CLASS_NON_DETERMINISTIC_UI = 5,
  ROUTING_FAILURE_CLASS_UNEXPECTED_STATE = 6,
  ROUTING_FAILURE_CLASS_TIMEOUT_OR_HANG = 7,
  ROUTING_FAILURE_CLASS_USER_INTERVENTION_NEEDED = 8,
  UNRECOGNIZED = -1,
}

export function routingFailureClassFromJSON(object: any): RoutingFailureClass {
  switch (object) {
    case 0:
    case "ROUTING_FAILURE_CLASS_UNSPECIFIED":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_UNSPECIFIED;
    case 1:
    case "ROUTING_FAILURE_CLASS_FOCUS_MISMATCH":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_FOCUS_MISMATCH;
    case 2:
    case "ROUTING_FAILURE_CLASS_TARGET_NOT_FOUND":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_TARGET_NOT_FOUND;
    case 3:
    case "ROUTING_FAILURE_CLASS_PERMISSION_OR_APPROVAL_REQUIRED":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_PERMISSION_OR_APPROVAL_REQUIRED;
    case 4:
    case "ROUTING_FAILURE_CLASS_TOOL_UNAVAILABLE":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_TOOL_UNAVAILABLE;
    case 5:
    case "ROUTING_FAILURE_CLASS_NON_DETERMINISTIC_UI":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_NON_DETERMINISTIC_UI;
    case 6:
    case "ROUTING_FAILURE_CLASS_UNEXPECTED_STATE":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_UNEXPECTED_STATE;
    case 7:
    case "ROUTING_FAILURE_CLASS_TIMEOUT_OR_HANG":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_TIMEOUT_OR_HANG;
    case 8:
    case "ROUTING_FAILURE_CLASS_USER_INTERVENTION_NEEDED":
      return RoutingFailureClass.ROUTING_FAILURE_CLASS_USER_INTERVENTION_NEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoutingFailureClass.UNRECOGNIZED;
  }
}

export function routingFailureClassToJSON(object: RoutingFailureClass): string {
  switch (object) {
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_UNSPECIFIED:
      return "ROUTING_FAILURE_CLASS_UNSPECIFIED";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_FOCUS_MISMATCH:
      return "ROUTING_FAILURE_CLASS_FOCUS_MISMATCH";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_TARGET_NOT_FOUND:
      return "ROUTING_FAILURE_CLASS_TARGET_NOT_FOUND";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_PERMISSION_OR_APPROVAL_REQUIRED:
      return "ROUTING_FAILURE_CLASS_PERMISSION_OR_APPROVAL_REQUIRED";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_TOOL_UNAVAILABLE:
      return "ROUTING_FAILURE_CLASS_TOOL_UNAVAILABLE";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_NON_DETERMINISTIC_UI:
      return "ROUTING_FAILURE_CLASS_NON_DETERMINISTIC_UI";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_UNEXPECTED_STATE:
      return "ROUTING_FAILURE_CLASS_UNEXPECTED_STATE";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_TIMEOUT_OR_HANG:
      return "ROUTING_FAILURE_CLASS_TIMEOUT_OR_HANG";
    case RoutingFailureClass.ROUTING_FAILURE_CLASS_USER_INTERVENTION_NEEDED:
      return "ROUTING_FAILURE_CLASS_USER_INTERVENTION_NEEDED";
    case RoutingFailureClass.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubmitTransactionRequest {
  /** Canonical SCALE-encoded bytes of the transaction. */
  transactionBytes: Uint8Array;
}

export interface SubmitTransactionResponse {
  /**
   * SHA-256 hash of the transaction.
   * If status is PENDING_APPROVAL, this is the hash to sign in the ApprovalToken.
   */
  txHash: string;
  /** Indicates if the transaction was accepted, rejected, or requires 2FA. */
  status: SubmissionStatus;
  /** If PENDING_APPROVAL, this contains the human-readable reason (e.g. "Spend limit exceeded"). */
  approvalReason: string;
}

export interface GetTransactionStatusRequest {
  txHash: string;
}

export interface GetTransactionStatusResponse {
  status: TxStatus;
  errorMessage: string;
  blockHeight: number;
}

export interface GetBlockByHeightRequest {
  height: number;
}

export interface GetBlockByHeightResponse {
  blockBytes: Uint8Array;
}

/** Optional filters could be added here (e.g. only "Action" events) */
export interface SubscribeEventsRequest {
}

export interface ChainEvent {
  /** A block was successfully committed to the chain. */
  block?:
    | BlockCommitted
    | undefined;
  /** The agent is "thinking" (LLM token stream or internal monologue). */
  thought?:
    | AgentThought
    | undefined;
  /** The firewall intercepted an action. */
  action?:
    | ActionIntercepted
    | undefined;
  /** The status of a service or policy changed. */
  system?:
    | SystemUpdate
    | undefined;
  /** The user performed a physical input while in Ghost Mode. */
  ghost?:
    | GhostInput
    | undefined;
  /** The result of an executed action. */
  actionResult?:
    | AgentActionResult
    | undefined;
  /** [NEW] A new sub-agent was spawned (delegation). */
  spawn?:
    | AgentSpawn
    | undefined;
  /** [NEW] Typed parity routing receipt for an action step. */
  routingReceipt?: RoutingReceipt | undefined;
}

export interface BlockCommitted {
  height: number;
  /** Hex */
  stateRoot: string;
  txCount: number;
}

export interface AgentThought {
  /** Hex */
  sessionId: string;
  /** The text token or reasoning step */
  content: string;
  /** True if this concludes the thought */
  isFinal: boolean;
  /** The hash of the visual context (screenshot) associated with this step. */
  visualHash: string;
}

export interface ActionIntercepted {
  sessionId: string;
  /** e.g. "net::fetch" */
  target: string;
  /** "ALLOW", "BLOCK", "REQUIRE_APPROVAL" */
  verdict: string;
  reason: string;
}

export interface SystemUpdate {
  /** e.g. "P2P", "Mempool" */
  component: string;
  status: string;
}

export interface GhostInput {
  /** "mouse", "keyboard" */
  device: string;
  /** "Click(100, 200)", "Type('hello')" */
  description: string;
}

export interface AgentActionResult {
  /** Hex */
  sessionId: string;
  stepIndex: number;
  toolName: string;
  output: string;
  /**
   * [NEW] The authoritative lifecycle state after this action.
   * e.g. "Running", "Paused", "Completed", "Failed"
   */
  agentStatus: string;
}

/** [NEW] Message for agent spawning */
export interface AgentSpawn {
  /** Hex */
  parentSessionId: string;
  /** Hex */
  newSessionId: string;
  name: string;
  role: string;
  budget: number;
  goal: string;
}

export interface RoutingStateSummary {
  agentStatus: string;
  tier: string;
  stepIndex: number;
  consecutiveFailures: number;
  targetHint: string;
}

export interface RoutingPostStateSummary {
  agentStatus: string;
  tier: string;
  stepIndex: number;
  consecutiveFailures: number;
  success: boolean;
  verificationChecks: string[];
}

export interface RoutingReceipt {
  /** Hex */
  sessionId: string;
  stepIndex: number;
  intentHash: string;
  policyDecision: string;
  toolName: string;
  toolVersion: string;
  preState: RoutingStateSummary | undefined;
  actionJson: string;
  postState: RoutingPostStateSummary | undefined;
  artifacts: string[];
  failureClass: RoutingFailureClass;
  hasFailureClass: boolean;
  stopConditionHit: boolean;
  escalationPath: string;
  scsLineagePtr: string;
  mutationReceiptPtr: string;
  policyBindingHash: string;
  policyBindingSig: string;
  policyBindingSigner: string;
}

export interface DraftTransactionRequest {
  /** Natural language intent (e.g., "Send 50 tokens to Bob"). */
  intent: string;
  /** Optional context to resolve names (e.g., "Bob" -> 0x123...). */
  addressBook: { [key: string]: string };
}

export interface DraftTransactionRequest_AddressBookEntry {
  key: string;
  value: string;
}

export interface DraftTransactionResponse {
  /** The constructed, unsigned transaction bytes (SCALE encoded). */
  transactionBytes: Uint8Array;
  /** A structured summary for the UI to display before signing. */
  summaryMarkdown: string;
  /** The list of capabilities this transaction requires (for Policy check). */
  requiredCapabilities: string[];
}

export interface GetContextBlobRequest {
  /** Hex-encoded SHA-256 hash of the blob (e.g., visual_hash). */
  blobHash: string;
}

export interface GetContextBlobResponse {
  /** Raw bytes of the blob (e.g., PNG image). */
  data: Uint8Array;
  /**
   * Suggested MIME type (e.g. "image/png").
   * In a real implementation, this might be inferred or stored in metadata.
   */
  mimeType: string;
}

function createBaseSubmitTransactionRequest(): SubmitTransactionRequest {
  return { transactionBytes: new Uint8Array(0) };
}

export const SubmitTransactionRequest: MessageFns<SubmitTransactionRequest> = {
  encode(message: SubmitTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionBytes.length !== 0) {
      writer.uint32(10).bytes(message.transactionBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionRequest {
    return {
      transactionBytes: isSet(object.transactionBytes)
        ? bytesFromBase64(object.transactionBytes)
        : isSet(object.transaction_bytes)
        ? bytesFromBase64(object.transaction_bytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SubmitTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionBytes.length !== 0) {
      obj.transactionBytes = base64FromBytes(message.transactionBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(base?: I): SubmitTransactionRequest {
    return SubmitTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(object: I): SubmitTransactionRequest {
    const message = createBaseSubmitTransactionRequest();
    message.transactionBytes = object.transactionBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitTransactionResponse(): SubmitTransactionResponse {
  return { txHash: "", status: 0, approvalReason: "" };
}

export const SubmitTransactionResponse: MessageFns<SubmitTransactionResponse> = {
  encode(message: SubmitTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.approvalReason !== "") {
      writer.uint32(26).string(message.approvalReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.approvalReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionResponse {
    return {
      txHash: isSet(object.txHash)
        ? globalThis.String(object.txHash)
        : isSet(object.tx_hash)
        ? globalThis.String(object.tx_hash)
        : "",
      status: isSet(object.status) ? submissionStatusFromJSON(object.status) : 0,
      approvalReason: isSet(object.approvalReason)
        ? globalThis.String(object.approvalReason)
        : isSet(object.approval_reason)
        ? globalThis.String(object.approval_reason)
        : "",
    };
  },

  toJSON(message: SubmitTransactionResponse): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.status !== 0) {
      obj.status = submissionStatusToJSON(message.status);
    }
    if (message.approvalReason !== "") {
      obj.approvalReason = message.approvalReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(base?: I): SubmitTransactionResponse {
    return SubmitTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(object: I): SubmitTransactionResponse {
    const message = createBaseSubmitTransactionResponse();
    message.txHash = object.txHash ?? "";
    message.status = object.status ?? 0;
    message.approvalReason = object.approvalReason ?? "";
    return message;
  },
};

function createBaseGetTransactionStatusRequest(): GetTransactionStatusRequest {
  return { txHash: "" };
}

export const GetTransactionStatusRequest: MessageFns<GetTransactionStatusRequest> = {
  encode(message: GetTransactionStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionStatusRequest {
    return {
      txHash: isSet(object.txHash)
        ? globalThis.String(object.txHash)
        : isSet(object.tx_hash)
        ? globalThis.String(object.tx_hash)
        : "",
    };
  },

  toJSON(message: GetTransactionStatusRequest): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionStatusRequest>, I>>(base?: I): GetTransactionStatusRequest {
    return GetTransactionStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionStatusRequest>, I>>(object: I): GetTransactionStatusRequest {
    const message = createBaseGetTransactionStatusRequest();
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseGetTransactionStatusResponse(): GetTransactionStatusResponse {
  return { status: 0, errorMessage: "", blockHeight: 0 };
}

export const GetTransactionStatusResponse: MessageFns<GetTransactionStatusResponse> = {
  encode(message: GetTransactionStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(24).uint64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockHeight = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionStatusResponse {
    return {
      status: isSet(object.status) ? txStatusFromJSON(object.status) : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
      blockHeight: isSet(object.blockHeight)
        ? globalThis.Number(object.blockHeight)
        : isSet(object.block_height)
        ? globalThis.Number(object.block_height)
        : 0,
    };
  },

  toJSON(message: GetTransactionStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = txStatusToJSON(message.status);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionStatusResponse>, I>>(base?: I): GetTransactionStatusResponse {
    return GetTransactionStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionStatusResponse>, I>>(object: I): GetTransactionStatusResponse {
    const message = createBaseGetTransactionStatusResponse();
    message.status = object.status ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.blockHeight = object.blockHeight ?? 0;
    return message;
  },
};

function createBaseGetBlockByHeightRequest(): GetBlockByHeightRequest {
  return { height: 0 };
}

export const GetBlockByHeightRequest: MessageFns<GetBlockByHeightRequest> = {
  encode(message: GetBlockByHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockByHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockByHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockByHeightRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: GetBlockByHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockByHeightRequest>, I>>(base?: I): GetBlockByHeightRequest {
    return GetBlockByHeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockByHeightRequest>, I>>(object: I): GetBlockByHeightRequest {
    const message = createBaseGetBlockByHeightRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseGetBlockByHeightResponse(): GetBlockByHeightResponse {
  return { blockBytes: new Uint8Array(0) };
}

export const GetBlockByHeightResponse: MessageFns<GetBlockByHeightResponse> = {
  encode(message: GetBlockByHeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockBytes.length !== 0) {
      writer.uint32(10).bytes(message.blockBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockByHeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockByHeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockByHeightResponse {
    return {
      blockBytes: isSet(object.blockBytes)
        ? bytesFromBase64(object.blockBytes)
        : isSet(object.block_bytes)
        ? bytesFromBase64(object.block_bytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: GetBlockByHeightResponse): unknown {
    const obj: any = {};
    if (message.blockBytes.length !== 0) {
      obj.blockBytes = base64FromBytes(message.blockBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockByHeightResponse>, I>>(base?: I): GetBlockByHeightResponse {
    return GetBlockByHeightResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockByHeightResponse>, I>>(object: I): GetBlockByHeightResponse {
    const message = createBaseGetBlockByHeightResponse();
    message.blockBytes = object.blockBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubscribeEventsRequest(): SubscribeEventsRequest {
  return {};
}

export const SubscribeEventsRequest: MessageFns<SubscribeEventsRequest> = {
  encode(_: SubscribeEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubscribeEventsRequest {
    return {};
  },

  toJSON(_: SubscribeEventsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeEventsRequest>, I>>(base?: I): SubscribeEventsRequest {
    return SubscribeEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeEventsRequest>, I>>(_: I): SubscribeEventsRequest {
    const message = createBaseSubscribeEventsRequest();
    return message;
  },
};

function createBaseChainEvent(): ChainEvent {
  return {
    block: undefined,
    thought: undefined,
    action: undefined,
    system: undefined,
    ghost: undefined,
    actionResult: undefined,
    spawn: undefined,
    routingReceipt: undefined,
  };
}

export const ChainEvent: MessageFns<ChainEvent> = {
  encode(message: ChainEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      BlockCommitted.encode(message.block, writer.uint32(10).fork()).join();
    }
    if (message.thought !== undefined) {
      AgentThought.encode(message.thought, writer.uint32(18).fork()).join();
    }
    if (message.action !== undefined) {
      ActionIntercepted.encode(message.action, writer.uint32(26).fork()).join();
    }
    if (message.system !== undefined) {
      SystemUpdate.encode(message.system, writer.uint32(34).fork()).join();
    }
    if (message.ghost !== undefined) {
      GhostInput.encode(message.ghost, writer.uint32(42).fork()).join();
    }
    if (message.actionResult !== undefined) {
      AgentActionResult.encode(message.actionResult, writer.uint32(50).fork()).join();
    }
    if (message.spawn !== undefined) {
      AgentSpawn.encode(message.spawn, writer.uint32(58).fork()).join();
    }
    if (message.routingReceipt !== undefined) {
      RoutingReceipt.encode(message.routingReceipt, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = BlockCommitted.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thought = AgentThought.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = ActionIntercepted.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.system = SystemUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ghost = GhostInput.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actionResult = AgentActionResult.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.spawn = AgentSpawn.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.routingReceipt = RoutingReceipt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainEvent {
    return {
      block: isSet(object.block) ? BlockCommitted.fromJSON(object.block) : undefined,
      thought: isSet(object.thought) ? AgentThought.fromJSON(object.thought) : undefined,
      action: isSet(object.action) ? ActionIntercepted.fromJSON(object.action) : undefined,
      system: isSet(object.system) ? SystemUpdate.fromJSON(object.system) : undefined,
      ghost: isSet(object.ghost) ? GhostInput.fromJSON(object.ghost) : undefined,
      actionResult: isSet(object.actionResult)
        ? AgentActionResult.fromJSON(object.actionResult)
        : isSet(object.action_result)
        ? AgentActionResult.fromJSON(object.action_result)
        : undefined,
      spawn: isSet(object.spawn) ? AgentSpawn.fromJSON(object.spawn) : undefined,
      routingReceipt: isSet(object.routingReceipt)
        ? RoutingReceipt.fromJSON(object.routingReceipt)
        : isSet(object.routing_receipt)
        ? RoutingReceipt.fromJSON(object.routing_receipt)
        : undefined,
    };
  },

  toJSON(message: ChainEvent): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = BlockCommitted.toJSON(message.block);
    }
    if (message.thought !== undefined) {
      obj.thought = AgentThought.toJSON(message.thought);
    }
    if (message.action !== undefined) {
      obj.action = ActionIntercepted.toJSON(message.action);
    }
    if (message.system !== undefined) {
      obj.system = SystemUpdate.toJSON(message.system);
    }
    if (message.ghost !== undefined) {
      obj.ghost = GhostInput.toJSON(message.ghost);
    }
    if (message.actionResult !== undefined) {
      obj.actionResult = AgentActionResult.toJSON(message.actionResult);
    }
    if (message.spawn !== undefined) {
      obj.spawn = AgentSpawn.toJSON(message.spawn);
    }
    if (message.routingReceipt !== undefined) {
      obj.routingReceipt = RoutingReceipt.toJSON(message.routingReceipt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainEvent>, I>>(base?: I): ChainEvent {
    return ChainEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainEvent>, I>>(object: I): ChainEvent {
    const message = createBaseChainEvent();
    message.block = (object.block !== undefined && object.block !== null)
      ? BlockCommitted.fromPartial(object.block)
      : undefined;
    message.thought = (object.thought !== undefined && object.thought !== null)
      ? AgentThought.fromPartial(object.thought)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? ActionIntercepted.fromPartial(object.action)
      : undefined;
    message.system = (object.system !== undefined && object.system !== null)
      ? SystemUpdate.fromPartial(object.system)
      : undefined;
    message.ghost = (object.ghost !== undefined && object.ghost !== null)
      ? GhostInput.fromPartial(object.ghost)
      : undefined;
    message.actionResult = (object.actionResult !== undefined && object.actionResult !== null)
      ? AgentActionResult.fromPartial(object.actionResult)
      : undefined;
    message.spawn = (object.spawn !== undefined && object.spawn !== null)
      ? AgentSpawn.fromPartial(object.spawn)
      : undefined;
    message.routingReceipt = (object.routingReceipt !== undefined && object.routingReceipt !== null)
      ? RoutingReceipt.fromPartial(object.routingReceipt)
      : undefined;
    return message;
  },
};

function createBaseBlockCommitted(): BlockCommitted {
  return { height: 0, stateRoot: "", txCount: 0 };
}

export const BlockCommitted: MessageFns<BlockCommitted> = {
  encode(message: BlockCommitted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    if (message.stateRoot !== "") {
      writer.uint32(18).string(message.stateRoot);
    }
    if (message.txCount !== 0) {
      writer.uint32(24).uint64(message.txCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockCommitted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockCommitted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stateRoot = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.txCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockCommitted {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      stateRoot: isSet(object.stateRoot)
        ? globalThis.String(object.stateRoot)
        : isSet(object.state_root)
        ? globalThis.String(object.state_root)
        : "",
      txCount: isSet(object.txCount)
        ? globalThis.Number(object.txCount)
        : isSet(object.tx_count)
        ? globalThis.Number(object.tx_count)
        : 0,
    };
  },

  toJSON(message: BlockCommitted): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.stateRoot !== "") {
      obj.stateRoot = message.stateRoot;
    }
    if (message.txCount !== 0) {
      obj.txCount = Math.round(message.txCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockCommitted>, I>>(base?: I): BlockCommitted {
    return BlockCommitted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockCommitted>, I>>(object: I): BlockCommitted {
    const message = createBaseBlockCommitted();
    message.height = object.height ?? 0;
    message.stateRoot = object.stateRoot ?? "";
    message.txCount = object.txCount ?? 0;
    return message;
  },
};

function createBaseAgentThought(): AgentThought {
  return { sessionId: "", content: "", isFinal: false, visualHash: "" };
}

export const AgentThought: MessageFns<AgentThought> = {
  encode(message: AgentThought, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.isFinal !== false) {
      writer.uint32(24).bool(message.isFinal);
    }
    if (message.visualHash !== "") {
      writer.uint32(34).string(message.visualHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentThought {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentThought();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.visualHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentThought {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isFinal: isSet(object.isFinal)
        ? globalThis.Boolean(object.isFinal)
        : isSet(object.is_final)
        ? globalThis.Boolean(object.is_final)
        : false,
      visualHash: isSet(object.visualHash)
        ? globalThis.String(object.visualHash)
        : isSet(object.visual_hash)
        ? globalThis.String(object.visual_hash)
        : "",
    };
  },

  toJSON(message: AgentThought): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    if (message.visualHash !== "") {
      obj.visualHash = message.visualHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentThought>, I>>(base?: I): AgentThought {
    return AgentThought.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentThought>, I>>(object: I): AgentThought {
    const message = createBaseAgentThought();
    message.sessionId = object.sessionId ?? "";
    message.content = object.content ?? "";
    message.isFinal = object.isFinal ?? false;
    message.visualHash = object.visualHash ?? "";
    return message;
  },
};

function createBaseActionIntercepted(): ActionIntercepted {
  return { sessionId: "", target: "", verdict: "", reason: "" };
}

export const ActionIntercepted: MessageFns<ActionIntercepted> = {
  encode(message: ActionIntercepted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    if (message.verdict !== "") {
      writer.uint32(26).string(message.verdict);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionIntercepted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionIntercepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verdict = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionIntercepted {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verdict: isSet(object.verdict) ? globalThis.String(object.verdict) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: ActionIntercepted): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verdict !== "") {
      obj.verdict = message.verdict;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionIntercepted>, I>>(base?: I): ActionIntercepted {
    return ActionIntercepted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionIntercepted>, I>>(object: I): ActionIntercepted {
    const message = createBaseActionIntercepted();
    message.sessionId = object.sessionId ?? "";
    message.target = object.target ?? "";
    message.verdict = object.verdict ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseSystemUpdate(): SystemUpdate {
  return { component: "", status: "" };
}

export const SystemUpdate: MessageFns<SystemUpdate> = {
  encode(message: SystemUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.component !== "") {
      writer.uint32(10).string(message.component);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.component = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemUpdate {
    return {
      component: isSet(object.component) ? globalThis.String(object.component) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: SystemUpdate): unknown {
    const obj: any = {};
    if (message.component !== "") {
      obj.component = message.component;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemUpdate>, I>>(base?: I): SystemUpdate {
    return SystemUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemUpdate>, I>>(object: I): SystemUpdate {
    const message = createBaseSystemUpdate();
    message.component = object.component ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseGhostInput(): GhostInput {
  return { device: "", description: "" };
}

export const GhostInput: MessageFns<GhostInput> = {
  encode(message: GhostInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.device !== "") {
      writer.uint32(10).string(message.device);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GhostInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGhostInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.device = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GhostInput {
    return {
      device: isSet(object.device) ? globalThis.String(object.device) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: GhostInput): unknown {
    const obj: any = {};
    if (message.device !== "") {
      obj.device = message.device;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GhostInput>, I>>(base?: I): GhostInput {
    return GhostInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GhostInput>, I>>(object: I): GhostInput {
    const message = createBaseGhostInput();
    message.device = object.device ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseAgentActionResult(): AgentActionResult {
  return { sessionId: "", stepIndex: 0, toolName: "", output: "", agentStatus: "" };
}

export const AgentActionResult: MessageFns<AgentActionResult> = {
  encode(message: AgentActionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.stepIndex !== 0) {
      writer.uint32(16).uint32(message.stepIndex);
    }
    if (message.toolName !== "") {
      writer.uint32(26).string(message.toolName);
    }
    if (message.output !== "") {
      writer.uint32(34).string(message.output);
    }
    if (message.agentStatus !== "") {
      writer.uint32(42).string(message.agentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentActionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentActionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stepIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.agentStatus = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentActionResult {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      stepIndex: isSet(object.stepIndex)
        ? globalThis.Number(object.stepIndex)
        : isSet(object.step_index)
        ? globalThis.Number(object.step_index)
        : 0,
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      agentStatus: isSet(object.agentStatus)
        ? globalThis.String(object.agentStatus)
        : isSet(object.agent_status)
        ? globalThis.String(object.agent_status)
        : "",
    };
  },

  toJSON(message: AgentActionResult): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.stepIndex !== 0) {
      obj.stepIndex = Math.round(message.stepIndex);
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.agentStatus !== "") {
      obj.agentStatus = message.agentStatus;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentActionResult>, I>>(base?: I): AgentActionResult {
    return AgentActionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentActionResult>, I>>(object: I): AgentActionResult {
    const message = createBaseAgentActionResult();
    message.sessionId = object.sessionId ?? "";
    message.stepIndex = object.stepIndex ?? 0;
    message.toolName = object.toolName ?? "";
    message.output = object.output ?? "";
    message.agentStatus = object.agentStatus ?? "";
    return message;
  },
};

function createBaseAgentSpawn(): AgentSpawn {
  return { parentSessionId: "", newSessionId: "", name: "", role: "", budget: 0, goal: "" };
}

export const AgentSpawn: MessageFns<AgentSpawn> = {
  encode(message: AgentSpawn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentSessionId !== "") {
      writer.uint32(10).string(message.parentSessionId);
    }
    if (message.newSessionId !== "") {
      writer.uint32(18).string(message.newSessionId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.budget !== 0) {
      writer.uint32(40).uint64(message.budget);
    }
    if (message.goal !== "") {
      writer.uint32(50).string(message.goal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentSpawn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentSpawn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentSessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.budget = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.goal = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentSpawn {
    return {
      parentSessionId: isSet(object.parentSessionId)
        ? globalThis.String(object.parentSessionId)
        : isSet(object.parent_session_id)
        ? globalThis.String(object.parent_session_id)
        : "",
      newSessionId: isSet(object.newSessionId)
        ? globalThis.String(object.newSessionId)
        : isSet(object.new_session_id)
        ? globalThis.String(object.new_session_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      budget: isSet(object.budget) ? globalThis.Number(object.budget) : 0,
      goal: isSet(object.goal) ? globalThis.String(object.goal) : "",
    };
  },

  toJSON(message: AgentSpawn): unknown {
    const obj: any = {};
    if (message.parentSessionId !== "") {
      obj.parentSessionId = message.parentSessionId;
    }
    if (message.newSessionId !== "") {
      obj.newSessionId = message.newSessionId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.budget !== 0) {
      obj.budget = Math.round(message.budget);
    }
    if (message.goal !== "") {
      obj.goal = message.goal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentSpawn>, I>>(base?: I): AgentSpawn {
    return AgentSpawn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentSpawn>, I>>(object: I): AgentSpawn {
    const message = createBaseAgentSpawn();
    message.parentSessionId = object.parentSessionId ?? "";
    message.newSessionId = object.newSessionId ?? "";
    message.name = object.name ?? "";
    message.role = object.role ?? "";
    message.budget = object.budget ?? 0;
    message.goal = object.goal ?? "";
    return message;
  },
};

function createBaseRoutingStateSummary(): RoutingStateSummary {
  return { agentStatus: "", tier: "", stepIndex: 0, consecutiveFailures: 0, targetHint: "" };
}

export const RoutingStateSummary: MessageFns<RoutingStateSummary> = {
  encode(message: RoutingStateSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentStatus !== "") {
      writer.uint32(10).string(message.agentStatus);
    }
    if (message.tier !== "") {
      writer.uint32(18).string(message.tier);
    }
    if (message.stepIndex !== 0) {
      writer.uint32(24).uint32(message.stepIndex);
    }
    if (message.consecutiveFailures !== 0) {
      writer.uint32(32).uint32(message.consecutiveFailures);
    }
    if (message.targetHint !== "") {
      writer.uint32(42).string(message.targetHint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingStateSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingStateSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agentStatus = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stepIndex = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.consecutiveFailures = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targetHint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingStateSummary {
    return {
      agentStatus: isSet(object.agentStatus)
        ? globalThis.String(object.agentStatus)
        : isSet(object.agent_status)
        ? globalThis.String(object.agent_status)
        : "",
      tier: isSet(object.tier) ? globalThis.String(object.tier) : "",
      stepIndex: isSet(object.stepIndex)
        ? globalThis.Number(object.stepIndex)
        : isSet(object.step_index)
        ? globalThis.Number(object.step_index)
        : 0,
      consecutiveFailures: isSet(object.consecutiveFailures)
        ? globalThis.Number(object.consecutiveFailures)
        : isSet(object.consecutive_failures)
        ? globalThis.Number(object.consecutive_failures)
        : 0,
      targetHint: isSet(object.targetHint)
        ? globalThis.String(object.targetHint)
        : isSet(object.target_hint)
        ? globalThis.String(object.target_hint)
        : "",
    };
  },

  toJSON(message: RoutingStateSummary): unknown {
    const obj: any = {};
    if (message.agentStatus !== "") {
      obj.agentStatus = message.agentStatus;
    }
    if (message.tier !== "") {
      obj.tier = message.tier;
    }
    if (message.stepIndex !== 0) {
      obj.stepIndex = Math.round(message.stepIndex);
    }
    if (message.consecutiveFailures !== 0) {
      obj.consecutiveFailures = Math.round(message.consecutiveFailures);
    }
    if (message.targetHint !== "") {
      obj.targetHint = message.targetHint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingStateSummary>, I>>(base?: I): RoutingStateSummary {
    return RoutingStateSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingStateSummary>, I>>(object: I): RoutingStateSummary {
    const message = createBaseRoutingStateSummary();
    message.agentStatus = object.agentStatus ?? "";
    message.tier = object.tier ?? "";
    message.stepIndex = object.stepIndex ?? 0;
    message.consecutiveFailures = object.consecutiveFailures ?? 0;
    message.targetHint = object.targetHint ?? "";
    return message;
  },
};

function createBaseRoutingPostStateSummary(): RoutingPostStateSummary {
  return { agentStatus: "", tier: "", stepIndex: 0, consecutiveFailures: 0, success: false, verificationChecks: [] };
}

export const RoutingPostStateSummary: MessageFns<RoutingPostStateSummary> = {
  encode(message: RoutingPostStateSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentStatus !== "") {
      writer.uint32(10).string(message.agentStatus);
    }
    if (message.tier !== "") {
      writer.uint32(18).string(message.tier);
    }
    if (message.stepIndex !== 0) {
      writer.uint32(24).uint32(message.stepIndex);
    }
    if (message.consecutiveFailures !== 0) {
      writer.uint32(32).uint32(message.consecutiveFailures);
    }
    if (message.success !== false) {
      writer.uint32(40).bool(message.success);
    }
    for (const v of message.verificationChecks) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingPostStateSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingPostStateSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agentStatus = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stepIndex = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.consecutiveFailures = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.verificationChecks.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingPostStateSummary {
    return {
      agentStatus: isSet(object.agentStatus)
        ? globalThis.String(object.agentStatus)
        : isSet(object.agent_status)
        ? globalThis.String(object.agent_status)
        : "",
      tier: isSet(object.tier) ? globalThis.String(object.tier) : "",
      stepIndex: isSet(object.stepIndex)
        ? globalThis.Number(object.stepIndex)
        : isSet(object.step_index)
        ? globalThis.Number(object.step_index)
        : 0,
      consecutiveFailures: isSet(object.consecutiveFailures)
        ? globalThis.Number(object.consecutiveFailures)
        : isSet(object.consecutive_failures)
        ? globalThis.Number(object.consecutive_failures)
        : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      verificationChecks: globalThis.Array.isArray(object?.verificationChecks)
        ? object.verificationChecks.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.verification_checks)
        ? object.verification_checks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RoutingPostStateSummary): unknown {
    const obj: any = {};
    if (message.agentStatus !== "") {
      obj.agentStatus = message.agentStatus;
    }
    if (message.tier !== "") {
      obj.tier = message.tier;
    }
    if (message.stepIndex !== 0) {
      obj.stepIndex = Math.round(message.stepIndex);
    }
    if (message.consecutiveFailures !== 0) {
      obj.consecutiveFailures = Math.round(message.consecutiveFailures);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.verificationChecks?.length) {
      obj.verificationChecks = message.verificationChecks;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingPostStateSummary>, I>>(base?: I): RoutingPostStateSummary {
    return RoutingPostStateSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingPostStateSummary>, I>>(object: I): RoutingPostStateSummary {
    const message = createBaseRoutingPostStateSummary();
    message.agentStatus = object.agentStatus ?? "";
    message.tier = object.tier ?? "";
    message.stepIndex = object.stepIndex ?? 0;
    message.consecutiveFailures = object.consecutiveFailures ?? 0;
    message.success = object.success ?? false;
    message.verificationChecks = object.verificationChecks?.map((e) => e) || [];
    return message;
  },
};

function createBaseRoutingReceipt(): RoutingReceipt {
  return {
    sessionId: "",
    stepIndex: 0,
    intentHash: "",
    policyDecision: "",
    toolName: "",
    toolVersion: "",
    preState: undefined,
    actionJson: "",
    postState: undefined,
    artifacts: [],
    failureClass: 0,
    hasFailureClass: false,
    stopConditionHit: false,
    escalationPath: "",
    scsLineagePtr: "",
    mutationReceiptPtr: "",
    policyBindingHash: "",
    policyBindingSig: "",
    policyBindingSigner: "",
  };
}

export const RoutingReceipt: MessageFns<RoutingReceipt> = {
  encode(message: RoutingReceipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.stepIndex !== 0) {
      writer.uint32(16).uint32(message.stepIndex);
    }
    if (message.intentHash !== "") {
      writer.uint32(26).string(message.intentHash);
    }
    if (message.policyDecision !== "") {
      writer.uint32(34).string(message.policyDecision);
    }
    if (message.toolName !== "") {
      writer.uint32(42).string(message.toolName);
    }
    if (message.toolVersion !== "") {
      writer.uint32(50).string(message.toolVersion);
    }
    if (message.preState !== undefined) {
      RoutingStateSummary.encode(message.preState, writer.uint32(58).fork()).join();
    }
    if (message.actionJson !== "") {
      writer.uint32(66).string(message.actionJson);
    }
    if (message.postState !== undefined) {
      RoutingPostStateSummary.encode(message.postState, writer.uint32(74).fork()).join();
    }
    for (const v of message.artifacts) {
      writer.uint32(82).string(v!);
    }
    if (message.failureClass !== 0) {
      writer.uint32(88).int32(message.failureClass);
    }
    if (message.hasFailureClass !== false) {
      writer.uint32(96).bool(message.hasFailureClass);
    }
    if (message.stopConditionHit !== false) {
      writer.uint32(104).bool(message.stopConditionHit);
    }
    if (message.escalationPath !== "") {
      writer.uint32(114).string(message.escalationPath);
    }
    if (message.scsLineagePtr !== "") {
      writer.uint32(122).string(message.scsLineagePtr);
    }
    if (message.mutationReceiptPtr !== "") {
      writer.uint32(130).string(message.mutationReceiptPtr);
    }
    if (message.policyBindingHash !== "") {
      writer.uint32(138).string(message.policyBindingHash);
    }
    if (message.policyBindingSig !== "") {
      writer.uint32(146).string(message.policyBindingSig);
    }
    if (message.policyBindingSigner !== "") {
      writer.uint32(154).string(message.policyBindingSigner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingReceipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stepIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.policyDecision = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toolVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.preState = RoutingStateSummary.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.actionJson = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.postState = RoutingPostStateSummary.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.artifacts.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.failureClass = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hasFailureClass = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.stopConditionHit = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.escalationPath = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.scsLineagePtr = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.mutationReceiptPtr = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.policyBindingHash = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.policyBindingSig = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.policyBindingSigner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingReceipt {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      stepIndex: isSet(object.stepIndex)
        ? globalThis.Number(object.stepIndex)
        : isSet(object.step_index)
        ? globalThis.Number(object.step_index)
        : 0,
      intentHash: isSet(object.intentHash)
        ? globalThis.String(object.intentHash)
        : isSet(object.intent_hash)
        ? globalThis.String(object.intent_hash)
        : "",
      policyDecision: isSet(object.policyDecision)
        ? globalThis.String(object.policyDecision)
        : isSet(object.policy_decision)
        ? globalThis.String(object.policy_decision)
        : "",
      toolName: isSet(object.toolName)
        ? globalThis.String(object.toolName)
        : isSet(object.tool_name)
        ? globalThis.String(object.tool_name)
        : "",
      toolVersion: isSet(object.toolVersion)
        ? globalThis.String(object.toolVersion)
        : isSet(object.tool_version)
        ? globalThis.String(object.tool_version)
        : "",
      preState: isSet(object.preState)
        ? RoutingStateSummary.fromJSON(object.preState)
        : isSet(object.pre_state)
        ? RoutingStateSummary.fromJSON(object.pre_state)
        : undefined,
      actionJson: isSet(object.actionJson)
        ? globalThis.String(object.actionJson)
        : isSet(object.action_json)
        ? globalThis.String(object.action_json)
        : "",
      postState: isSet(object.postState)
        ? RoutingPostStateSummary.fromJSON(object.postState)
        : isSet(object.post_state)
        ? RoutingPostStateSummary.fromJSON(object.post_state)
        : undefined,
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => globalThis.String(e))
        : [],
      failureClass: isSet(object.failureClass)
        ? routingFailureClassFromJSON(object.failureClass)
        : isSet(object.failure_class)
        ? routingFailureClassFromJSON(object.failure_class)
        : 0,
      hasFailureClass: isSet(object.hasFailureClass)
        ? globalThis.Boolean(object.hasFailureClass)
        : isSet(object.has_failure_class)
        ? globalThis.Boolean(object.has_failure_class)
        : false,
      stopConditionHit: isSet(object.stopConditionHit)
        ? globalThis.Boolean(object.stopConditionHit)
        : isSet(object.stop_condition_hit)
        ? globalThis.Boolean(object.stop_condition_hit)
        : false,
      escalationPath: isSet(object.escalationPath)
        ? globalThis.String(object.escalationPath)
        : isSet(object.escalation_path)
        ? globalThis.String(object.escalation_path)
        : "",
      scsLineagePtr: isSet(object.scsLineagePtr)
        ? globalThis.String(object.scsLineagePtr)
        : isSet(object.scs_lineage_ptr)
        ? globalThis.String(object.scs_lineage_ptr)
        : "",
      mutationReceiptPtr: isSet(object.mutationReceiptPtr)
        ? globalThis.String(object.mutationReceiptPtr)
        : isSet(object.mutation_receipt_ptr)
        ? globalThis.String(object.mutation_receipt_ptr)
        : "",
      policyBindingHash: isSet(object.policyBindingHash)
        ? globalThis.String(object.policyBindingHash)
        : isSet(object.policy_binding_hash)
        ? globalThis.String(object.policy_binding_hash)
        : "",
      policyBindingSig: isSet(object.policyBindingSig)
        ? globalThis.String(object.policyBindingSig)
        : isSet(object.policy_binding_sig)
        ? globalThis.String(object.policy_binding_sig)
        : "",
      policyBindingSigner: isSet(object.policyBindingSigner)
        ? globalThis.String(object.policyBindingSigner)
        : isSet(object.policy_binding_signer)
        ? globalThis.String(object.policy_binding_signer)
        : "",
    };
  },

  toJSON(message: RoutingReceipt): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.stepIndex !== 0) {
      obj.stepIndex = Math.round(message.stepIndex);
    }
    if (message.intentHash !== "") {
      obj.intentHash = message.intentHash;
    }
    if (message.policyDecision !== "") {
      obj.policyDecision = message.policyDecision;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.toolVersion !== "") {
      obj.toolVersion = message.toolVersion;
    }
    if (message.preState !== undefined) {
      obj.preState = RoutingStateSummary.toJSON(message.preState);
    }
    if (message.actionJson !== "") {
      obj.actionJson = message.actionJson;
    }
    if (message.postState !== undefined) {
      obj.postState = RoutingPostStateSummary.toJSON(message.postState);
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts;
    }
    if (message.failureClass !== 0) {
      obj.failureClass = routingFailureClassToJSON(message.failureClass);
    }
    if (message.hasFailureClass !== false) {
      obj.hasFailureClass = message.hasFailureClass;
    }
    if (message.stopConditionHit !== false) {
      obj.stopConditionHit = message.stopConditionHit;
    }
    if (message.escalationPath !== "") {
      obj.escalationPath = message.escalationPath;
    }
    if (message.scsLineagePtr !== "") {
      obj.scsLineagePtr = message.scsLineagePtr;
    }
    if (message.mutationReceiptPtr !== "") {
      obj.mutationReceiptPtr = message.mutationReceiptPtr;
    }
    if (message.policyBindingHash !== "") {
      obj.policyBindingHash = message.policyBindingHash;
    }
    if (message.policyBindingSig !== "") {
      obj.policyBindingSig = message.policyBindingSig;
    }
    if (message.policyBindingSigner !== "") {
      obj.policyBindingSigner = message.policyBindingSigner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingReceipt>, I>>(base?: I): RoutingReceipt {
    return RoutingReceipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingReceipt>, I>>(object: I): RoutingReceipt {
    const message = createBaseRoutingReceipt();
    message.sessionId = object.sessionId ?? "";
    message.stepIndex = object.stepIndex ?? 0;
    message.intentHash = object.intentHash ?? "";
    message.policyDecision = object.policyDecision ?? "";
    message.toolName = object.toolName ?? "";
    message.toolVersion = object.toolVersion ?? "";
    message.preState = (object.preState !== undefined && object.preState !== null)
      ? RoutingStateSummary.fromPartial(object.preState)
      : undefined;
    message.actionJson = object.actionJson ?? "";
    message.postState = (object.postState !== undefined && object.postState !== null)
      ? RoutingPostStateSummary.fromPartial(object.postState)
      : undefined;
    message.artifacts = object.artifacts?.map((e) => e) || [];
    message.failureClass = object.failureClass ?? 0;
    message.hasFailureClass = object.hasFailureClass ?? false;
    message.stopConditionHit = object.stopConditionHit ?? false;
    message.escalationPath = object.escalationPath ?? "";
    message.scsLineagePtr = object.scsLineagePtr ?? "";
    message.mutationReceiptPtr = object.mutationReceiptPtr ?? "";
    message.policyBindingHash = object.policyBindingHash ?? "";
    message.policyBindingSig = object.policyBindingSig ?? "";
    message.policyBindingSigner = object.policyBindingSigner ?? "";
    return message;
  },
};

function createBaseDraftTransactionRequest(): DraftTransactionRequest {
  return { intent: "", addressBook: {} };
}

export const DraftTransactionRequest: MessageFns<DraftTransactionRequest> = {
  encode(message: DraftTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== "") {
      writer.uint32(10).string(message.intent);
    }
    globalThis.Object.entries(message.addressBook).forEach(([key, value]: [string, string]) => {
      DraftTransactionRequest_AddressBookEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = DraftTransactionRequest_AddressBookEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.addressBook[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftTransactionRequest {
    return {
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      addressBook: isObject(object.addressBook)
        ? (globalThis.Object.entries(object.addressBook) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : isObject(object.address_book)
        ? (globalThis.Object.entries(object.address_book) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: DraftTransactionRequest): unknown {
    const obj: any = {};
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.addressBook) {
      const entries = globalThis.Object.entries(message.addressBook) as [string, string][];
      if (entries.length > 0) {
        obj.addressBook = {};
        entries.forEach(([k, v]) => {
          obj.addressBook[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftTransactionRequest>, I>>(base?: I): DraftTransactionRequest {
    return DraftTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftTransactionRequest>, I>>(object: I): DraftTransactionRequest {
    const message = createBaseDraftTransactionRequest();
    message.intent = object.intent ?? "";
    message.addressBook = (globalThis.Object.entries(object.addressBook ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDraftTransactionRequest_AddressBookEntry(): DraftTransactionRequest_AddressBookEntry {
  return { key: "", value: "" };
}

export const DraftTransactionRequest_AddressBookEntry: MessageFns<DraftTransactionRequest_AddressBookEntry> = {
  encode(message: DraftTransactionRequest_AddressBookEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftTransactionRequest_AddressBookEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftTransactionRequest_AddressBookEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftTransactionRequest_AddressBookEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DraftTransactionRequest_AddressBookEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftTransactionRequest_AddressBookEntry>, I>>(
    base?: I,
  ): DraftTransactionRequest_AddressBookEntry {
    return DraftTransactionRequest_AddressBookEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftTransactionRequest_AddressBookEntry>, I>>(
    object: I,
  ): DraftTransactionRequest_AddressBookEntry {
    const message = createBaseDraftTransactionRequest_AddressBookEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDraftTransactionResponse(): DraftTransactionResponse {
  return { transactionBytes: new Uint8Array(0), summaryMarkdown: "", requiredCapabilities: [] };
}

export const DraftTransactionResponse: MessageFns<DraftTransactionResponse> = {
  encode(message: DraftTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionBytes.length !== 0) {
      writer.uint32(10).bytes(message.transactionBytes);
    }
    if (message.summaryMarkdown !== "") {
      writer.uint32(18).string(message.summaryMarkdown);
    }
    for (const v of message.requiredCapabilities) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionBytes = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summaryMarkdown = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requiredCapabilities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftTransactionResponse {
    return {
      transactionBytes: isSet(object.transactionBytes)
        ? bytesFromBase64(object.transactionBytes)
        : isSet(object.transaction_bytes)
        ? bytesFromBase64(object.transaction_bytes)
        : new Uint8Array(0),
      summaryMarkdown: isSet(object.summaryMarkdown)
        ? globalThis.String(object.summaryMarkdown)
        : isSet(object.summary_markdown)
        ? globalThis.String(object.summary_markdown)
        : "",
      requiredCapabilities: globalThis.Array.isArray(object?.requiredCapabilities)
        ? object.requiredCapabilities.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.required_capabilities)
        ? object.required_capabilities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DraftTransactionResponse): unknown {
    const obj: any = {};
    if (message.transactionBytes.length !== 0) {
      obj.transactionBytes = base64FromBytes(message.transactionBytes);
    }
    if (message.summaryMarkdown !== "") {
      obj.summaryMarkdown = message.summaryMarkdown;
    }
    if (message.requiredCapabilities?.length) {
      obj.requiredCapabilities = message.requiredCapabilities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftTransactionResponse>, I>>(base?: I): DraftTransactionResponse {
    return DraftTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftTransactionResponse>, I>>(object: I): DraftTransactionResponse {
    const message = createBaseDraftTransactionResponse();
    message.transactionBytes = object.transactionBytes ?? new Uint8Array(0);
    message.summaryMarkdown = object.summaryMarkdown ?? "";
    message.requiredCapabilities = object.requiredCapabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetContextBlobRequest(): GetContextBlobRequest {
  return { blobHash: "" };
}

export const GetContextBlobRequest: MessageFns<GetContextBlobRequest> = {
  encode(message: GetContextBlobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blobHash !== "") {
      writer.uint32(10).string(message.blobHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContextBlobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextBlobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blobHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextBlobRequest {
    return {
      blobHash: isSet(object.blobHash)
        ? globalThis.String(object.blobHash)
        : isSet(object.blob_hash)
        ? globalThis.String(object.blob_hash)
        : "",
    };
  },

  toJSON(message: GetContextBlobRequest): unknown {
    const obj: any = {};
    if (message.blobHash !== "") {
      obj.blobHash = message.blobHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextBlobRequest>, I>>(base?: I): GetContextBlobRequest {
    return GetContextBlobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextBlobRequest>, I>>(object: I): GetContextBlobRequest {
    const message = createBaseGetContextBlobRequest();
    message.blobHash = object.blobHash ?? "";
    return message;
  },
};

function createBaseGetContextBlobResponse(): GetContextBlobResponse {
  return { data: new Uint8Array(0), mimeType: "" };
}

export const GetContextBlobResponse: MessageFns<GetContextBlobResponse> = {
  encode(message: GetContextBlobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContextBlobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextBlobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextBlobResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      mimeType: isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : "",
    };
  },

  toJSON(message: GetContextBlobResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextBlobResponse>, I>>(base?: I): GetContextBlobResponse {
    return GetContextBlobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextBlobResponse>, I>>(object: I): GetContextBlobResponse {
    const message = createBaseGetContextBlobResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

export type PublicApiService = typeof PublicApiService;
export const PublicApiService = {
  /**
   * Submit a transaction to the mempool/ingestion queue.
   * Returns immediately with a receipt (hash) or an approval request.
   */
  submitTransaction: {
    path: "/ioi.public.v1.PublicApi/SubmitTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitTransactionRequest): Buffer =>
      Buffer.from(SubmitTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitTransactionRequest => SubmitTransactionRequest.decode(value),
    responseSerialize: (value: SubmitTransactionResponse): Buffer =>
      Buffer.from(SubmitTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitTransactionResponse => SubmitTransactionResponse.decode(value),
  },
  /** Check the status of a transaction hash. */
  getTransactionStatus: {
    path: "/ioi.public.v1.PublicApi/GetTransactionStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTransactionStatusRequest): Buffer =>
      Buffer.from(GetTransactionStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTransactionStatusRequest => GetTransactionStatusRequest.decode(value),
    responseSerialize: (value: GetTransactionStatusResponse): Buffer =>
      Buffer.from(GetTransactionStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetTransactionStatusResponse => GetTransactionStatusResponse.decode(value),
  },
  /** Proxy queries to the underlying Workload state (Merklized proof). */
  queryState: {
    path: "/ioi.public.v1.PublicApi/QueryState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryStateAtRequest): Buffer => Buffer.from(QueryStateAtRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryStateAtRequest => QueryStateAtRequest.decode(value),
    responseSerialize: (value: QueryStateAtResponse): Buffer =>
      Buffer.from(QueryStateAtResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryStateAtResponse => QueryStateAtResponse.decode(value),
  },
  /** Queries the raw state value directly from the latest committed state. */
  queryRawState: {
    path: "/ioi.public.v1.PublicApi/QueryRawState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRawStateRequest): Buffer => Buffer.from(QueryRawStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryRawStateRequest => QueryRawStateRequest.decode(value),
    responseSerialize: (value: QueryRawStateResponse): Buffer =>
      Buffer.from(QueryRawStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryRawStateResponse => QueryRawStateResponse.decode(value),
  },
  /** Get the current status of the chain (Height, etc). */
  getStatus: {
    path: "/ioi.public.v1.PublicApi/GetStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatusRequest): Buffer => Buffer.from(GetStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatusRequest => GetStatusRequest.decode(value),
    responseSerialize: (value: GetStatusResponse): Buffer => Buffer.from(GetStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetStatusResponse => GetStatusResponse.decode(value),
  },
  /** Get a block by its height. */
  getBlockByHeight: {
    path: "/ioi.public.v1.PublicApi/GetBlockByHeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBlockByHeightRequest): Buffer =>
      Buffer.from(GetBlockByHeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBlockByHeightRequest => GetBlockByHeightRequest.decode(value),
    responseSerialize: (value: GetBlockByHeightResponse): Buffer =>
      Buffer.from(GetBlockByHeightResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBlockByHeightResponse => GetBlockByHeightResponse.decode(value),
  },
  /**
   * [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
   * Critical for the "Visual Sovereignty" of the Autopilot GUI.
   */
  subscribeEvents: {
    path: "/ioi.public.v1.PublicApi/SubscribeEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeEventsRequest): Buffer =>
      Buffer.from(SubscribeEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubscribeEventsRequest => SubscribeEventsRequest.decode(value),
    responseSerialize: (value: ChainEvent): Buffer => Buffer.from(ChainEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): ChainEvent => ChainEvent.decode(value),
  },
  /**
   * [NEW] Converts a natural language intent into a signable transaction payload.
   * This powers the "Commander Mode" search bar in the GUI.
   */
  draftTransaction: {
    path: "/ioi.public.v1.PublicApi/DraftTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DraftTransactionRequest): Buffer =>
      Buffer.from(DraftTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DraftTransactionRequest => DraftTransactionRequest.decode(value),
    responseSerialize: (value: DraftTransactionResponse): Buffer =>
      Buffer.from(DraftTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DraftTransactionResponse => DraftTransactionResponse.decode(value),
  },
  /**
   * [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
   * This allows the GUI to display the agent's visual memory.
   */
  getContextBlob: {
    path: "/ioi.public.v1.PublicApi/GetContextBlob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContextBlobRequest): Buffer =>
      Buffer.from(GetContextBlobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContextBlobRequest => GetContextBlobRequest.decode(value),
    responseSerialize: (value: GetContextBlobResponse): Buffer =>
      Buffer.from(GetContextBlobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetContextBlobResponse => GetContextBlobResponse.decode(value),
  },
} as const;

export interface PublicApiServer extends UntypedServiceImplementation {
  /**
   * Submit a transaction to the mempool/ingestion queue.
   * Returns immediately with a receipt (hash) or an approval request.
   */
  submitTransaction: handleUnaryCall<SubmitTransactionRequest, SubmitTransactionResponse>;
  /** Check the status of a transaction hash. */
  getTransactionStatus: handleUnaryCall<GetTransactionStatusRequest, GetTransactionStatusResponse>;
  /** Proxy queries to the underlying Workload state (Merklized proof). */
  queryState: handleUnaryCall<QueryStateAtRequest, QueryStateAtResponse>;
  /** Queries the raw state value directly from the latest committed state. */
  queryRawState: handleUnaryCall<QueryRawStateRequest, QueryRawStateResponse>;
  /** Get the current status of the chain (Height, etc). */
  getStatus: handleUnaryCall<GetStatusRequest, GetStatusResponse>;
  /** Get a block by its height. */
  getBlockByHeight: handleUnaryCall<GetBlockByHeightRequest, GetBlockByHeightResponse>;
  /**
   * [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
   * Critical for the "Visual Sovereignty" of the Autopilot GUI.
   */
  subscribeEvents: handleServerStreamingCall<SubscribeEventsRequest, ChainEvent>;
  /**
   * [NEW] Converts a natural language intent into a signable transaction payload.
   * This powers the "Commander Mode" search bar in the GUI.
   */
  draftTransaction: handleUnaryCall<DraftTransactionRequest, DraftTransactionResponse>;
  /**
   * [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
   * This allows the GUI to display the agent's visual memory.
   */
  getContextBlob: handleUnaryCall<GetContextBlobRequest, GetContextBlobResponse>;
}

export interface PublicApiClient extends Client {
  /**
   * Submit a transaction to the mempool/ingestion queue.
   * Returns immediately with a receipt (hash) or an approval request.
   */
  submitTransaction(
    request: SubmitTransactionRequest,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  /** Check the status of a transaction hash. */
  getTransactionStatus(
    request: GetTransactionStatusRequest,
    callback: (error: ServiceError | null, response: GetTransactionStatusResponse) => void,
  ): ClientUnaryCall;
  getTransactionStatus(
    request: GetTransactionStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTransactionStatusResponse) => void,
  ): ClientUnaryCall;
  getTransactionStatus(
    request: GetTransactionStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTransactionStatusResponse) => void,
  ): ClientUnaryCall;
  /** Proxy queries to the underlying Workload state (Merklized proof). */
  queryState(
    request: QueryStateAtRequest,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  queryState(
    request: QueryStateAtRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  queryState(
    request: QueryStateAtRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  /** Queries the raw state value directly from the latest committed state. */
  queryRawState(
    request: QueryRawStateRequest,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  queryRawState(
    request: QueryRawStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  queryRawState(
    request: QueryRawStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  /** Get the current status of the chain (Height, etc). */
  getStatus(
    request: GetStatusRequest,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  getStatus(
    request: GetStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  getStatus(
    request: GetStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  /** Get a block by its height. */
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  /**
   * [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
   * Critical for the "Visual Sovereignty" of the Autopilot GUI.
   */
  subscribeEvents(request: SubscribeEventsRequest, options?: Partial<CallOptions>): ClientReadableStream<ChainEvent>;
  subscribeEvents(
    request: SubscribeEventsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ChainEvent>;
  /**
   * [NEW] Converts a natural language intent into a signable transaction payload.
   * This powers the "Commander Mode" search bar in the GUI.
   */
  draftTransaction(
    request: DraftTransactionRequest,
    callback: (error: ServiceError | null, response: DraftTransactionResponse) => void,
  ): ClientUnaryCall;
  draftTransaction(
    request: DraftTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DraftTransactionResponse) => void,
  ): ClientUnaryCall;
  draftTransaction(
    request: DraftTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DraftTransactionResponse) => void,
  ): ClientUnaryCall;
  /**
   * [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
   * This allows the GUI to display the agent's visual memory.
   */
  getContextBlob(
    request: GetContextBlobRequest,
    callback: (error: ServiceError | null, response: GetContextBlobResponse) => void,
  ): ClientUnaryCall;
  getContextBlob(
    request: GetContextBlobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetContextBlobResponse) => void,
  ): ClientUnaryCall;
  getContextBlob(
    request: GetContextBlobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetContextBlobResponse) => void,
  ): ClientUnaryCall;
}

export const PublicApiClient = makeGenericClientConstructor(PublicApiService, "ioi.public.v1.PublicApi") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PublicApiClient;
  service: typeof PublicApiService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
