// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v3.12.4
// source: public.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import {
  GetStatusRequest,
  GetStatusResponse,
  QueryRawStateRequest,
  QueryRawStateResponse,
  QueryStateAtRequest,
  QueryStateAtResponse,
} from "./blockchain";

export const protobufPackage = "ioi.public.v1";

/** Path: crates/ipc/proto/public.proto */

export enum SubmissionStatus {
  ACCEPTED = 0,
  /** SUBMISSION_REJECTED - Renamed from REJECTED to avoid conflict */
  SUBMISSION_REJECTED = 1,
  /** PENDING_APPROVAL - "Suspended" state requiring user signature */
  PENDING_APPROVAL = 2,
  UNRECOGNIZED = -1,
}

export function submissionStatusFromJSON(object: any): SubmissionStatus {
  switch (object) {
    case 0:
    case "ACCEPTED":
      return SubmissionStatus.ACCEPTED;
    case 1:
    case "SUBMISSION_REJECTED":
      return SubmissionStatus.SUBMISSION_REJECTED;
    case 2:
    case "PENDING_APPROVAL":
      return SubmissionStatus.PENDING_APPROVAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubmissionStatus.UNRECOGNIZED;
  }
}

export function submissionStatusToJSON(object: SubmissionStatus): string {
  switch (object) {
    case SubmissionStatus.ACCEPTED:
      return "ACCEPTED";
    case SubmissionStatus.SUBMISSION_REJECTED:
      return "SUBMISSION_REJECTED";
    case SubmissionStatus.PENDING_APPROVAL:
      return "PENDING_APPROVAL";
    case SubmissionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TxStatus {
  UNKNOWN = 0,
  PENDING = 1,
  IN_MEMPOOL = 2,
  COMMITTED = 3,
  REJECTED = 4,
  UNRECOGNIZED = -1,
}

export function txStatusFromJSON(object: any): TxStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TxStatus.UNKNOWN;
    case 1:
    case "PENDING":
      return TxStatus.PENDING;
    case 2:
    case "IN_MEMPOOL":
      return TxStatus.IN_MEMPOOL;
    case 3:
    case "COMMITTED":
      return TxStatus.COMMITTED;
    case 4:
    case "REJECTED":
      return TxStatus.REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TxStatus.UNRECOGNIZED;
  }
}

export function txStatusToJSON(object: TxStatus): string {
  switch (object) {
    case TxStatus.UNKNOWN:
      return "UNKNOWN";
    case TxStatus.PENDING:
      return "PENDING";
    case TxStatus.IN_MEMPOOL:
      return "IN_MEMPOOL";
    case TxStatus.COMMITTED:
      return "COMMITTED";
    case TxStatus.REJECTED:
      return "REJECTED";
    case TxStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubmitTransactionRequest {
  /** Canonical SCALE-encoded bytes of the transaction. */
  transactionBytes: Uint8Array;
}

export interface SubmitTransactionResponse {
  /**
   * SHA-256 hash of the transaction.
   * If status is PENDING_APPROVAL, this is the hash to sign in the ApprovalToken.
   */
  txHash: string;
  /** Indicates if the transaction was accepted, rejected, or requires 2FA. */
  status: SubmissionStatus;
  /** If PENDING_APPROVAL, this contains the human-readable reason (e.g. "Spend limit exceeded"). */
  approvalReason: string;
}

export interface GetTransactionStatusRequest {
  txHash: string;
}

export interface GetTransactionStatusResponse {
  status: TxStatus;
  errorMessage: string;
  blockHeight: number;
}

export interface GetBlockByHeightRequest {
  height: number;
}

export interface GetBlockByHeightResponse {
  blockBytes: Uint8Array;
}

/** Optional filters could be added here (e.g. only "Action" events) */
export interface SubscribeEventsRequest {
}

export interface ChainEvent {
  /** A block was successfully committed to the chain. */
  block?:
    | BlockCommitted
    | undefined;
  /** The agent is "thinking" (LLM token stream or internal monologue). */
  thought?:
    | AgentThought
    | undefined;
  /** The firewall intercepted an action. */
  action?:
    | ActionIntercepted
    | undefined;
  /** The status of a service or policy changed. */
  system?: SystemUpdate | undefined;
}

export interface BlockCommitted {
  height: number;
  /** Hex */
  stateRoot: string;
  txCount: number;
}

export interface AgentThought {
  /** Hex */
  sessionId: string;
  /** The text token or reasoning step */
  content: string;
  /** True if this concludes the thought */
  isFinal: boolean;
}

export interface ActionIntercepted {
  sessionId: string;
  /** e.g. "net::fetch" */
  target: string;
  /** "ALLOW", "BLOCK", "REQUIRE_APPROVAL" */
  verdict: string;
  reason: string;
}

export interface SystemUpdate {
  /** e.g. "P2P", "Mempool" */
  component: string;
  status: string;
}

export interface DraftTransactionRequest {
  /** Natural language intent (e.g., "Send 50 tokens to Bob"). */
  intent: string;
  /** Optional context to resolve names (e.g., "Bob" -> 0x123...). */
  addressBook: { [key: string]: string };
}

export interface DraftTransactionRequest_AddressBookEntry {
  key: string;
  value: string;
}

export interface DraftTransactionResponse {
  /** The constructed, unsigned transaction bytes (SCALE encoded). */
  transactionBytes: Uint8Array;
  /** A structured summary for the UI to display before signing. */
  summaryMarkdown: string;
  /** The list of capabilities this transaction requires (for Policy check). */
  requiredCapabilities: string[];
}

export interface GetContextBlobRequest {
  /** Hex-encoded SHA-256 hash of the blob (e.g., visual_hash). */
  blobHash: string;
}

export interface GetContextBlobResponse {
  /** Raw bytes of the blob (e.g., PNG image). */
  data: Uint8Array;
  /**
   * Suggested MIME type (e.g. "image/png").
   * In a real implementation, this might be inferred or stored in metadata.
   */
  mimeType: string;
}

function createBaseSubmitTransactionRequest(): SubmitTransactionRequest {
  return { transactionBytes: new Uint8Array(0) };
}

export const SubmitTransactionRequest: MessageFns<SubmitTransactionRequest> = {
  encode(message: SubmitTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionBytes.length !== 0) {
      writer.uint32(10).bytes(message.transactionBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionRequest {
    return {
      transactionBytes: isSet(object.transactionBytes) ? bytesFromBase64(object.transactionBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: SubmitTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionBytes.length !== 0) {
      obj.transactionBytes = base64FromBytes(message.transactionBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(base?: I): SubmitTransactionRequest {
    return SubmitTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(object: I): SubmitTransactionRequest {
    const message = createBaseSubmitTransactionRequest();
    message.transactionBytes = object.transactionBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitTransactionResponse(): SubmitTransactionResponse {
  return { txHash: "", status: 0, approvalReason: "" };
}

export const SubmitTransactionResponse: MessageFns<SubmitTransactionResponse> = {
  encode(message: SubmitTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.approvalReason !== "") {
      writer.uint32(26).string(message.approvalReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.approvalReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionResponse {
    return {
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      status: isSet(object.status) ? submissionStatusFromJSON(object.status) : 0,
      approvalReason: isSet(object.approvalReason) ? globalThis.String(object.approvalReason) : "",
    };
  },

  toJSON(message: SubmitTransactionResponse): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.status !== 0) {
      obj.status = submissionStatusToJSON(message.status);
    }
    if (message.approvalReason !== "") {
      obj.approvalReason = message.approvalReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(base?: I): SubmitTransactionResponse {
    return SubmitTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(object: I): SubmitTransactionResponse {
    const message = createBaseSubmitTransactionResponse();
    message.txHash = object.txHash ?? "";
    message.status = object.status ?? 0;
    message.approvalReason = object.approvalReason ?? "";
    return message;
  },
};

function createBaseGetTransactionStatusRequest(): GetTransactionStatusRequest {
  return { txHash: "" };
}

export const GetTransactionStatusRequest: MessageFns<GetTransactionStatusRequest> = {
  encode(message: GetTransactionStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionStatusRequest {
    return { txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "" };
  },

  toJSON(message: GetTransactionStatusRequest): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionStatusRequest>, I>>(base?: I): GetTransactionStatusRequest {
    return GetTransactionStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionStatusRequest>, I>>(object: I): GetTransactionStatusRequest {
    const message = createBaseGetTransactionStatusRequest();
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseGetTransactionStatusResponse(): GetTransactionStatusResponse {
  return { status: 0, errorMessage: "", blockHeight: 0 };
}

export const GetTransactionStatusResponse: MessageFns<GetTransactionStatusResponse> = {
  encode(message: GetTransactionStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(24).uint64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockHeight = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionStatusResponse {
    return {
      status: isSet(object.status) ? txStatusFromJSON(object.status) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      blockHeight: isSet(object.blockHeight) ? globalThis.Number(object.blockHeight) : 0,
    };
  },

  toJSON(message: GetTransactionStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = txStatusToJSON(message.status);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionStatusResponse>, I>>(base?: I): GetTransactionStatusResponse {
    return GetTransactionStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionStatusResponse>, I>>(object: I): GetTransactionStatusResponse {
    const message = createBaseGetTransactionStatusResponse();
    message.status = object.status ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.blockHeight = object.blockHeight ?? 0;
    return message;
  },
};

function createBaseGetBlockByHeightRequest(): GetBlockByHeightRequest {
  return { height: 0 };
}

export const GetBlockByHeightRequest: MessageFns<GetBlockByHeightRequest> = {
  encode(message: GetBlockByHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockByHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockByHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockByHeightRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: GetBlockByHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockByHeightRequest>, I>>(base?: I): GetBlockByHeightRequest {
    return GetBlockByHeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockByHeightRequest>, I>>(object: I): GetBlockByHeightRequest {
    const message = createBaseGetBlockByHeightRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseGetBlockByHeightResponse(): GetBlockByHeightResponse {
  return { blockBytes: new Uint8Array(0) };
}

export const GetBlockByHeightResponse: MessageFns<GetBlockByHeightResponse> = {
  encode(message: GetBlockByHeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockBytes.length !== 0) {
      writer.uint32(10).bytes(message.blockBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockByHeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockByHeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockByHeightResponse {
    return { blockBytes: isSet(object.blockBytes) ? bytesFromBase64(object.blockBytes) : new Uint8Array(0) };
  },

  toJSON(message: GetBlockByHeightResponse): unknown {
    const obj: any = {};
    if (message.blockBytes.length !== 0) {
      obj.blockBytes = base64FromBytes(message.blockBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockByHeightResponse>, I>>(base?: I): GetBlockByHeightResponse {
    return GetBlockByHeightResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockByHeightResponse>, I>>(object: I): GetBlockByHeightResponse {
    const message = createBaseGetBlockByHeightResponse();
    message.blockBytes = object.blockBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubscribeEventsRequest(): SubscribeEventsRequest {
  return {};
}

export const SubscribeEventsRequest: MessageFns<SubscribeEventsRequest> = {
  encode(_: SubscribeEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubscribeEventsRequest {
    return {};
  },

  toJSON(_: SubscribeEventsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeEventsRequest>, I>>(base?: I): SubscribeEventsRequest {
    return SubscribeEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeEventsRequest>, I>>(_: I): SubscribeEventsRequest {
    const message = createBaseSubscribeEventsRequest();
    return message;
  },
};

function createBaseChainEvent(): ChainEvent {
  return { block: undefined, thought: undefined, action: undefined, system: undefined };
}

export const ChainEvent: MessageFns<ChainEvent> = {
  encode(message: ChainEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      BlockCommitted.encode(message.block, writer.uint32(10).fork()).join();
    }
    if (message.thought !== undefined) {
      AgentThought.encode(message.thought, writer.uint32(18).fork()).join();
    }
    if (message.action !== undefined) {
      ActionIntercepted.encode(message.action, writer.uint32(26).fork()).join();
    }
    if (message.system !== undefined) {
      SystemUpdate.encode(message.system, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = BlockCommitted.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.thought = AgentThought.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = ActionIntercepted.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.system = SystemUpdate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainEvent {
    return {
      block: isSet(object.block) ? BlockCommitted.fromJSON(object.block) : undefined,
      thought: isSet(object.thought) ? AgentThought.fromJSON(object.thought) : undefined,
      action: isSet(object.action) ? ActionIntercepted.fromJSON(object.action) : undefined,
      system: isSet(object.system) ? SystemUpdate.fromJSON(object.system) : undefined,
    };
  },

  toJSON(message: ChainEvent): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = BlockCommitted.toJSON(message.block);
    }
    if (message.thought !== undefined) {
      obj.thought = AgentThought.toJSON(message.thought);
    }
    if (message.action !== undefined) {
      obj.action = ActionIntercepted.toJSON(message.action);
    }
    if (message.system !== undefined) {
      obj.system = SystemUpdate.toJSON(message.system);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainEvent>, I>>(base?: I): ChainEvent {
    return ChainEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainEvent>, I>>(object: I): ChainEvent {
    const message = createBaseChainEvent();
    message.block = (object.block !== undefined && object.block !== null)
      ? BlockCommitted.fromPartial(object.block)
      : undefined;
    message.thought = (object.thought !== undefined && object.thought !== null)
      ? AgentThought.fromPartial(object.thought)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? ActionIntercepted.fromPartial(object.action)
      : undefined;
    message.system = (object.system !== undefined && object.system !== null)
      ? SystemUpdate.fromPartial(object.system)
      : undefined;
    return message;
  },
};

function createBaseBlockCommitted(): BlockCommitted {
  return { height: 0, stateRoot: "", txCount: 0 };
}

export const BlockCommitted: MessageFns<BlockCommitted> = {
  encode(message: BlockCommitted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    if (message.stateRoot !== "") {
      writer.uint32(18).string(message.stateRoot);
    }
    if (message.txCount !== 0) {
      writer.uint32(24).uint64(message.txCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockCommitted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockCommitted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stateRoot = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.txCount = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockCommitted {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      stateRoot: isSet(object.stateRoot) ? globalThis.String(object.stateRoot) : "",
      txCount: isSet(object.txCount) ? globalThis.Number(object.txCount) : 0,
    };
  },

  toJSON(message: BlockCommitted): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.stateRoot !== "") {
      obj.stateRoot = message.stateRoot;
    }
    if (message.txCount !== 0) {
      obj.txCount = Math.round(message.txCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockCommitted>, I>>(base?: I): BlockCommitted {
    return BlockCommitted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockCommitted>, I>>(object: I): BlockCommitted {
    const message = createBaseBlockCommitted();
    message.height = object.height ?? 0;
    message.stateRoot = object.stateRoot ?? "";
    message.txCount = object.txCount ?? 0;
    return message;
  },
};

function createBaseAgentThought(): AgentThought {
  return { sessionId: "", content: "", isFinal: false };
}

export const AgentThought: MessageFns<AgentThought> = {
  encode(message: AgentThought, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.isFinal !== false) {
      writer.uint32(24).bool(message.isFinal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentThought {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentThought();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentThought {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      isFinal: isSet(object.isFinal) ? globalThis.Boolean(object.isFinal) : false,
    };
  },

  toJSON(message: AgentThought): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentThought>, I>>(base?: I): AgentThought {
    return AgentThought.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentThought>, I>>(object: I): AgentThought {
    const message = createBaseAgentThought();
    message.sessionId = object.sessionId ?? "";
    message.content = object.content ?? "";
    message.isFinal = object.isFinal ?? false;
    return message;
  },
};

function createBaseActionIntercepted(): ActionIntercepted {
  return { sessionId: "", target: "", verdict: "", reason: "" };
}

export const ActionIntercepted: MessageFns<ActionIntercepted> = {
  encode(message: ActionIntercepted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    if (message.verdict !== "") {
      writer.uint32(26).string(message.verdict);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionIntercepted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionIntercepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verdict = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionIntercepted {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verdict: isSet(object.verdict) ? globalThis.String(object.verdict) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: ActionIntercepted): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verdict !== "") {
      obj.verdict = message.verdict;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionIntercepted>, I>>(base?: I): ActionIntercepted {
    return ActionIntercepted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionIntercepted>, I>>(object: I): ActionIntercepted {
    const message = createBaseActionIntercepted();
    message.sessionId = object.sessionId ?? "";
    message.target = object.target ?? "";
    message.verdict = object.verdict ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseSystemUpdate(): SystemUpdate {
  return { component: "", status: "" };
}

export const SystemUpdate: MessageFns<SystemUpdate> = {
  encode(message: SystemUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.component !== "") {
      writer.uint32(10).string(message.component);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.component = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemUpdate {
    return {
      component: isSet(object.component) ? globalThis.String(object.component) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: SystemUpdate): unknown {
    const obj: any = {};
    if (message.component !== "") {
      obj.component = message.component;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemUpdate>, I>>(base?: I): SystemUpdate {
    return SystemUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemUpdate>, I>>(object: I): SystemUpdate {
    const message = createBaseSystemUpdate();
    message.component = object.component ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseDraftTransactionRequest(): DraftTransactionRequest {
  return { intent: "", addressBook: {} };
}

export const DraftTransactionRequest: MessageFns<DraftTransactionRequest> = {
  encode(message: DraftTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== "") {
      writer.uint32(10).string(message.intent);
    }
    globalThis.Object.entries(message.addressBook).forEach(([key, value]: [string, string]) => {
      DraftTransactionRequest_AddressBookEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = DraftTransactionRequest_AddressBookEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.addressBook[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftTransactionRequest {
    return {
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      addressBook: isObject(object.addressBook)
        ? (globalThis.Object.entries(object.addressBook) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: DraftTransactionRequest): unknown {
    const obj: any = {};
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.addressBook) {
      const entries = globalThis.Object.entries(message.addressBook) as [string, string][];
      if (entries.length > 0) {
        obj.addressBook = {};
        entries.forEach(([k, v]) => {
          obj.addressBook[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftTransactionRequest>, I>>(base?: I): DraftTransactionRequest {
    return DraftTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftTransactionRequest>, I>>(object: I): DraftTransactionRequest {
    const message = createBaseDraftTransactionRequest();
    message.intent = object.intent ?? "";
    message.addressBook = (globalThis.Object.entries(object.addressBook ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDraftTransactionRequest_AddressBookEntry(): DraftTransactionRequest_AddressBookEntry {
  return { key: "", value: "" };
}

export const DraftTransactionRequest_AddressBookEntry: MessageFns<DraftTransactionRequest_AddressBookEntry> = {
  encode(message: DraftTransactionRequest_AddressBookEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftTransactionRequest_AddressBookEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftTransactionRequest_AddressBookEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftTransactionRequest_AddressBookEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DraftTransactionRequest_AddressBookEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftTransactionRequest_AddressBookEntry>, I>>(
    base?: I,
  ): DraftTransactionRequest_AddressBookEntry {
    return DraftTransactionRequest_AddressBookEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftTransactionRequest_AddressBookEntry>, I>>(
    object: I,
  ): DraftTransactionRequest_AddressBookEntry {
    const message = createBaseDraftTransactionRequest_AddressBookEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDraftTransactionResponse(): DraftTransactionResponse {
  return { transactionBytes: new Uint8Array(0), summaryMarkdown: "", requiredCapabilities: [] };
}

export const DraftTransactionResponse: MessageFns<DraftTransactionResponse> = {
  encode(message: DraftTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionBytes.length !== 0) {
      writer.uint32(10).bytes(message.transactionBytes);
    }
    if (message.summaryMarkdown !== "") {
      writer.uint32(18).string(message.summaryMarkdown);
    }
    for (const v of message.requiredCapabilities) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DraftTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDraftTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionBytes = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summaryMarkdown = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requiredCapabilities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DraftTransactionResponse {
    return {
      transactionBytes: isSet(object.transactionBytes) ? bytesFromBase64(object.transactionBytes) : new Uint8Array(0),
      summaryMarkdown: isSet(object.summaryMarkdown) ? globalThis.String(object.summaryMarkdown) : "",
      requiredCapabilities: globalThis.Array.isArray(object?.requiredCapabilities)
        ? object.requiredCapabilities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DraftTransactionResponse): unknown {
    const obj: any = {};
    if (message.transactionBytes.length !== 0) {
      obj.transactionBytes = base64FromBytes(message.transactionBytes);
    }
    if (message.summaryMarkdown !== "") {
      obj.summaryMarkdown = message.summaryMarkdown;
    }
    if (message.requiredCapabilities?.length) {
      obj.requiredCapabilities = message.requiredCapabilities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DraftTransactionResponse>, I>>(base?: I): DraftTransactionResponse {
    return DraftTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DraftTransactionResponse>, I>>(object: I): DraftTransactionResponse {
    const message = createBaseDraftTransactionResponse();
    message.transactionBytes = object.transactionBytes ?? new Uint8Array(0);
    message.summaryMarkdown = object.summaryMarkdown ?? "";
    message.requiredCapabilities = object.requiredCapabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetContextBlobRequest(): GetContextBlobRequest {
  return { blobHash: "" };
}

export const GetContextBlobRequest: MessageFns<GetContextBlobRequest> = {
  encode(message: GetContextBlobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blobHash !== "") {
      writer.uint32(10).string(message.blobHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContextBlobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextBlobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blobHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextBlobRequest {
    return { blobHash: isSet(object.blobHash) ? globalThis.String(object.blobHash) : "" };
  },

  toJSON(message: GetContextBlobRequest): unknown {
    const obj: any = {};
    if (message.blobHash !== "") {
      obj.blobHash = message.blobHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextBlobRequest>, I>>(base?: I): GetContextBlobRequest {
    return GetContextBlobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextBlobRequest>, I>>(object: I): GetContextBlobRequest {
    const message = createBaseGetContextBlobRequest();
    message.blobHash = object.blobHash ?? "";
    return message;
  },
};

function createBaseGetContextBlobResponse(): GetContextBlobResponse {
  return { data: new Uint8Array(0), mimeType: "" };
}

export const GetContextBlobResponse: MessageFns<GetContextBlobResponse> = {
  encode(message: GetContextBlobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContextBlobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContextBlobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContextBlobResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: GetContextBlobResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContextBlobResponse>, I>>(base?: I): GetContextBlobResponse {
    return GetContextBlobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContextBlobResponse>, I>>(object: I): GetContextBlobResponse {
    const message = createBaseGetContextBlobResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

export type PublicApiService = typeof PublicApiService;
export const PublicApiService = {
  /**
   * Submit a transaction to the mempool/ingestion queue.
   * Returns immediately with a receipt (hash) or an approval request.
   */
  submitTransaction: {
    path: "/ioi.public.v1.PublicApi/SubmitTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitTransactionRequest): Buffer =>
      Buffer.from(SubmitTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitTransactionRequest => SubmitTransactionRequest.decode(value),
    responseSerialize: (value: SubmitTransactionResponse): Buffer =>
      Buffer.from(SubmitTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitTransactionResponse => SubmitTransactionResponse.decode(value),
  },
  /** Check the status of a transaction hash. */
  getTransactionStatus: {
    path: "/ioi.public.v1.PublicApi/GetTransactionStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTransactionStatusRequest): Buffer =>
      Buffer.from(GetTransactionStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTransactionStatusRequest => GetTransactionStatusRequest.decode(value),
    responseSerialize: (value: GetTransactionStatusResponse): Buffer =>
      Buffer.from(GetTransactionStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetTransactionStatusResponse => GetTransactionStatusResponse.decode(value),
  },
  /** Proxy queries to the underlying Workload state (Merklized proof). */
  queryState: {
    path: "/ioi.public.v1.PublicApi/QueryState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryStateAtRequest): Buffer => Buffer.from(QueryStateAtRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryStateAtRequest => QueryStateAtRequest.decode(value),
    responseSerialize: (value: QueryStateAtResponse): Buffer =>
      Buffer.from(QueryStateAtResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryStateAtResponse => QueryStateAtResponse.decode(value),
  },
  /** Queries the raw state value directly from the latest committed state. */
  queryRawState: {
    path: "/ioi.public.v1.PublicApi/QueryRawState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRawStateRequest): Buffer => Buffer.from(QueryRawStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryRawStateRequest => QueryRawStateRequest.decode(value),
    responseSerialize: (value: QueryRawStateResponse): Buffer =>
      Buffer.from(QueryRawStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryRawStateResponse => QueryRawStateResponse.decode(value),
  },
  /** Get the current status of the chain (Height, etc). */
  getStatus: {
    path: "/ioi.public.v1.PublicApi/GetStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatusRequest): Buffer => Buffer.from(GetStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatusRequest => GetStatusRequest.decode(value),
    responseSerialize: (value: GetStatusResponse): Buffer => Buffer.from(GetStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetStatusResponse => GetStatusResponse.decode(value),
  },
  /** Get a block by its height. */
  getBlockByHeight: {
    path: "/ioi.public.v1.PublicApi/GetBlockByHeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBlockByHeightRequest): Buffer =>
      Buffer.from(GetBlockByHeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBlockByHeightRequest => GetBlockByHeightRequest.decode(value),
    responseSerialize: (value: GetBlockByHeightResponse): Buffer =>
      Buffer.from(GetBlockByHeightResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBlockByHeightResponse => GetBlockByHeightResponse.decode(value),
  },
  /**
   * [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
   * Critical for the "Visual Sovereignty" of the Autopilot GUI.
   */
  subscribeEvents: {
    path: "/ioi.public.v1.PublicApi/SubscribeEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeEventsRequest): Buffer =>
      Buffer.from(SubscribeEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubscribeEventsRequest => SubscribeEventsRequest.decode(value),
    responseSerialize: (value: ChainEvent): Buffer => Buffer.from(ChainEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): ChainEvent => ChainEvent.decode(value),
  },
  /**
   * [NEW] Converts a natural language intent into a signable transaction payload.
   */
  draftTransaction: {
    path: "/ioi.public.v1.PublicApi/DraftTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DraftTransactionRequest): Buffer =>
      Buffer.from(DraftTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DraftTransactionRequest => DraftTransactionRequest.decode(value),
    responseSerialize: (value: DraftTransactionResponse): Buffer =>
      Buffer.from(DraftTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DraftTransactionResponse => DraftTransactionResponse.decode(value),
  },
  /**
   * [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
   * This allows the GUI to display the agent's visual memory.
   */
  getContextBlob: {
    path: "/ioi.public.v1.PublicApi/GetContextBlob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContextBlobRequest): Buffer =>
      Buffer.from(GetContextBlobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContextBlobRequest => GetContextBlobRequest.decode(value),
    responseSerialize: (value: GetContextBlobResponse): Buffer =>
      Buffer.from(GetContextBlobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetContextBlobResponse => GetContextBlobResponse.decode(value),
  },
} as const;

export interface PublicApiServer extends UntypedServiceImplementation {
  /**
   * Submit a transaction to the mempool/ingestion queue.
   * Returns immediately with a receipt (hash) or an approval request.
   */
  submitTransaction: handleUnaryCall<SubmitTransactionRequest, SubmitTransactionResponse>;
  /** Check the status of a transaction hash. */
  getTransactionStatus: handleUnaryCall<GetTransactionStatusRequest, GetTransactionStatusResponse>;
  /** Proxy queries to the underlying Workload state (Merklized proof). */
  queryState: handleUnaryCall<QueryStateAtRequest, QueryStateAtResponse>;
  /** Queries the raw state value directly from the latest committed state. */
  queryRawState: handleUnaryCall<QueryRawStateRequest, QueryRawStateResponse>;
  /** Get the current status of the chain (Height, etc). */
  getStatus: handleUnaryCall<GetStatusRequest, GetStatusResponse>;
  /** Get a block by its height. */
  getBlockByHeight: handleUnaryCall<GetBlockByHeightRequest, GetBlockByHeightResponse>;
  /**
   * [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
   * Critical for the "Visual Sovereignty" of the Autopilot GUI.
   */
  subscribeEvents: handleServerStreamingCall<SubscribeEventsRequest, ChainEvent>;
  /**
   * [NEW] Converts a natural language intent into a signable transaction payload.
   */
  draftTransaction: handleUnaryCall<DraftTransactionRequest, DraftTransactionResponse>;
  /**
   * [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
   * This allows the GUI to display the agent's visual memory.
   */
  getContextBlob: handleUnaryCall<GetContextBlobRequest, GetContextBlobResponse>;
}

export interface PublicApiClient extends Client {
  /**
   * Submit a transaction to the mempool/ingestion queue.
   * Returns immediately with a receipt (hash) or an approval request.
   */
  submitTransaction(
    request: SubmitTransactionRequest,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  /** Check the status of a transaction hash. */
  getTransactionStatus(
    request: GetTransactionStatusRequest,
    callback: (error: ServiceError | null, response: GetTransactionStatusResponse) => void,
  ): ClientUnaryCall;
  getTransactionStatus(
    request: GetTransactionStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTransactionStatusResponse) => void,
  ): ClientUnaryCall;
  getTransactionStatus(
    request: GetTransactionStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTransactionStatusResponse) => void,
  ): ClientUnaryCall;
  /** Proxy queries to the underlying Workload state (Merklized proof). */
  queryState(
    request: QueryStateAtRequest,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  queryState(
    request: QueryStateAtRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  queryState(
    request: QueryStateAtRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  /** Queries the raw state value directly from the latest committed state. */
  queryRawState(
    request: QueryRawStateRequest,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  queryRawState(
    request: QueryRawStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  queryRawState(
    request: QueryRawStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  /** Get the current status of the chain (Height, etc). */
  getStatus(
    request: GetStatusRequest,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  getStatus(
    request: GetStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  getStatus(
    request: GetStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  /** Get a block by its height. */
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  /**
   * [NEW] Subscribe to a stream of real-time events (agent thoughts, actions, block commits).
   * Critical for the "Visual Sovereignty" of the Autopilot GUI.
   */
  subscribeEvents(request: SubscribeEventsRequest, options?: Partial<CallOptions>): ClientReadableStream<ChainEvent>;
  subscribeEvents(
    request: SubscribeEventsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ChainEvent>;
  /**
   * [NEW] Converts a natural language intent into a signable transaction payload.
   */
  draftTransaction(
    request: DraftTransactionRequest,
    callback: (error: ServiceError | null, response: DraftTransactionResponse) => void,
  ): ClientUnaryCall;
  draftTransaction(
    request: DraftTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DraftTransactionResponse) => void,
  ): ClientUnaryCall;
  draftTransaction(
    request: DraftTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DraftTransactionResponse) => void,
  ): ClientUnaryCall;
  /**
   * [NEW] Retrieve a raw context chunk (e.g. screenshot PNG) by its hash/ID from the SCS.
   * This allows the GUI to display the agent's visual memory.
   */
  getContextBlob(
    request: GetContextBlobRequest,
    callback: (error: ServiceError | null, response: GetContextBlobResponse) => void,
  ): ClientUnaryCall;
  getContextBlob(
    request: GetContextBlobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetContextBlobResponse) => void,
  ): ClientUnaryCall;
  getContextBlob(
    request: GetContextBlobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetContextBlobResponse) => void,
  ): ClientUnaryCall;
}

export const PublicApiClient = makeGenericClientConstructor(PublicApiService, "ioi.public.v1.PublicApi") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PublicApiClient;
  service: typeof PublicApiService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
