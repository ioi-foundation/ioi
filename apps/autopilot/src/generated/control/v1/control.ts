// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.12.4
// source: control/v1/control.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "ioi.control.v1";

/** Path: crates/ipc/proto/control/v1/control.proto */

export interface LoadModelRequest {
  modelId: string;
  /** Identifier for the shared memory region (e.g., shm_open name) */
  shmemRegionId: string;
}

export interface LoadModelResponse {
  success: boolean;
  /** Bytes allocated in shared memory for this context */
  memoryUsageBytes: number;
}

export interface ExecuteJobRequest {
  jobId: number;
  /** Offset in the shared memory region where the input (AgentContext) begins */
  inputOffset: number;
  /** Length of the input data */
  inputLength: number;
  /** The session ID used for key derivation (32 bytes) */
  sessionId: Uint8Array;
}

export interface ExecuteJobResponse {
  success: boolean;
  /** Offset in shared memory where the output (InferenceOutput) was written */
  outputOffset: number;
  outputLength: number;
  gasUsed: number;
  errorMessage: string;
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  ready: boolean;
  status: string;
}

export interface SecureEgressRequest {
  domain: string;
  path: string;
  method: string;
  body: Uint8Array;
  /**
   * The identifier of the secret to use (e.g., "openai_primary")
   * This maps to a file in the Guardian's secure keystore.
   */
  secretId: string;
  /**
   * [NEW] JSON path for payload injection (e.g. "payment.handlers[0].token")
   * If present, the Guardian parses the body as JSON and injects the secret here
   * instead of (or in addition to) the Authorization header.
   */
  jsonPatchPath: string;
}

export interface SecureEgressResponse {
  body: Uint8Array;
  /** The hash of the TLS certificate from the remote server. */
  certHash: Uint8Array;
  /** The Guardian's signature attesting to this network call. */
  guardianSignature: Uint8Array;
}

function createBaseLoadModelRequest(): LoadModelRequest {
  return { modelId: "", shmemRegionId: "" };
}

export const LoadModelRequest: MessageFns<LoadModelRequest> = {
  encode(message: LoadModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelId !== "") {
      writer.uint32(10).string(message.modelId);
    }
    if (message.shmemRegionId !== "") {
      writer.uint32(18).string(message.shmemRegionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shmemRegionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadModelRequest {
    return {
      modelId: isSet(object.modelId)
        ? globalThis.String(object.modelId)
        : isSet(object.model_id)
        ? globalThis.String(object.model_id)
        : "",
      shmemRegionId: isSet(object.shmemRegionId)
        ? globalThis.String(object.shmemRegionId)
        : isSet(object.shmem_region_id)
        ? globalThis.String(object.shmem_region_id)
        : "",
    };
  },

  toJSON(message: LoadModelRequest): unknown {
    const obj: any = {};
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.shmemRegionId !== "") {
      obj.shmemRegionId = message.shmemRegionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadModelRequest>, I>>(base?: I): LoadModelRequest {
    return LoadModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadModelRequest>, I>>(object: I): LoadModelRequest {
    const message = createBaseLoadModelRequest();
    message.modelId = object.modelId ?? "";
    message.shmemRegionId = object.shmemRegionId ?? "";
    return message;
  },
};

function createBaseLoadModelResponse(): LoadModelResponse {
  return { success: false, memoryUsageBytes: 0 };
}

export const LoadModelResponse: MessageFns<LoadModelResponse> = {
  encode(message: LoadModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.memoryUsageBytes !== 0) {
      writer.uint32(16).uint64(message.memoryUsageBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryUsageBytes = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadModelResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      memoryUsageBytes: isSet(object.memoryUsageBytes)
        ? globalThis.Number(object.memoryUsageBytes)
        : isSet(object.memory_usage_bytes)
        ? globalThis.Number(object.memory_usage_bytes)
        : 0,
    };
  },

  toJSON(message: LoadModelResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.memoryUsageBytes !== 0) {
      obj.memoryUsageBytes = Math.round(message.memoryUsageBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadModelResponse>, I>>(base?: I): LoadModelResponse {
    return LoadModelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadModelResponse>, I>>(object: I): LoadModelResponse {
    const message = createBaseLoadModelResponse();
    message.success = object.success ?? false;
    message.memoryUsageBytes = object.memoryUsageBytes ?? 0;
    return message;
  },
};

function createBaseExecuteJobRequest(): ExecuteJobRequest {
  return { jobId: 0, inputOffset: 0, inputLength: 0, sessionId: new Uint8Array(0) };
}

export const ExecuteJobRequest: MessageFns<ExecuteJobRequest> = {
  encode(message: ExecuteJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== 0) {
      writer.uint32(8).uint64(message.jobId);
    }
    if (message.inputOffset !== 0) {
      writer.uint32(16).uint64(message.inputOffset);
    }
    if (message.inputLength !== 0) {
      writer.uint32(24).uint64(message.inputLength);
    }
    if (message.sessionId.length !== 0) {
      writer.uint32(34).bytes(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.jobId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inputOffset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inputLength = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteJobRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.Number(object.jobId)
        : isSet(object.job_id)
        ? globalThis.Number(object.job_id)
        : 0,
      inputOffset: isSet(object.inputOffset)
        ? globalThis.Number(object.inputOffset)
        : isSet(object.input_offset)
        ? globalThis.Number(object.input_offset)
        : 0,
      inputLength: isSet(object.inputLength)
        ? globalThis.Number(object.inputLength)
        : isSet(object.input_length)
        ? globalThis.Number(object.input_length)
        : 0,
      sessionId: isSet(object.sessionId)
        ? bytesFromBase64(object.sessionId)
        : isSet(object.session_id)
        ? bytesFromBase64(object.session_id)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ExecuteJobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== 0) {
      obj.jobId = Math.round(message.jobId);
    }
    if (message.inputOffset !== 0) {
      obj.inputOffset = Math.round(message.inputOffset);
    }
    if (message.inputLength !== 0) {
      obj.inputLength = Math.round(message.inputLength);
    }
    if (message.sessionId.length !== 0) {
      obj.sessionId = base64FromBytes(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteJobRequest>, I>>(base?: I): ExecuteJobRequest {
    return ExecuteJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteJobRequest>, I>>(object: I): ExecuteJobRequest {
    const message = createBaseExecuteJobRequest();
    message.jobId = object.jobId ?? 0;
    message.inputOffset = object.inputOffset ?? 0;
    message.inputLength = object.inputLength ?? 0;
    message.sessionId = object.sessionId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseExecuteJobResponse(): ExecuteJobResponse {
  return { success: false, outputOffset: 0, outputLength: 0, gasUsed: 0, errorMessage: "" };
}

export const ExecuteJobResponse: MessageFns<ExecuteJobResponse> = {
  encode(message: ExecuteJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.outputOffset !== 0) {
      writer.uint32(16).uint64(message.outputOffset);
    }
    if (message.outputLength !== 0) {
      writer.uint32(24).uint64(message.outputLength);
    }
    if (message.gasUsed !== 0) {
      writer.uint32(32).uint64(message.gasUsed);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputOffset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outputLength = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gasUsed = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteJobResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      outputOffset: isSet(object.outputOffset)
        ? globalThis.Number(object.outputOffset)
        : isSet(object.output_offset)
        ? globalThis.Number(object.output_offset)
        : 0,
      outputLength: isSet(object.outputLength)
        ? globalThis.Number(object.outputLength)
        : isSet(object.output_length)
        ? globalThis.Number(object.output_length)
        : 0,
      gasUsed: isSet(object.gasUsed)
        ? globalThis.Number(object.gasUsed)
        : isSet(object.gas_used)
        ? globalThis.Number(object.gas_used)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: ExecuteJobResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.outputOffset !== 0) {
      obj.outputOffset = Math.round(message.outputOffset);
    }
    if (message.outputLength !== 0) {
      obj.outputLength = Math.round(message.outputLength);
    }
    if (message.gasUsed !== 0) {
      obj.gasUsed = Math.round(message.gasUsed);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteJobResponse>, I>>(base?: I): ExecuteJobResponse {
    return ExecuteJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteJobResponse>, I>>(object: I): ExecuteJobResponse {
    const message = createBaseExecuteJobResponse();
    message.success = object.success ?? false;
    message.outputOffset = object.outputOffset ?? 0;
    message.outputLength = object.outputLength ?? 0;
    message.gasUsed = object.gasUsed ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(_: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { ready: false, status: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ready !== false) {
      writer.uint32(8).bool(message.ready);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ready = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      ready: isSet(object.ready) ? globalThis.Boolean(object.ready) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.ready !== false) {
      obj.ready = message.ready;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.ready = object.ready ?? false;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseSecureEgressRequest(): SecureEgressRequest {
  return { domain: "", path: "", method: "", body: new Uint8Array(0), secretId: "", jsonPatchPath: "" };
}

export const SecureEgressRequest: MessageFns<SecureEgressRequest> = {
  encode(message: SecureEgressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.body.length !== 0) {
      writer.uint32(34).bytes(message.body);
    }
    if (message.secretId !== "") {
      writer.uint32(42).string(message.secretId);
    }
    if (message.jsonPatchPath !== "") {
      writer.uint32(50).string(message.jsonPatchPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecureEgressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecureEgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.secretId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.jsonPatchPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecureEgressRequest {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      secretId: isSet(object.secretId)
        ? globalThis.String(object.secretId)
        : isSet(object.secret_id)
        ? globalThis.String(object.secret_id)
        : "",
      jsonPatchPath: isSet(object.jsonPatchPath)
        ? globalThis.String(object.jsonPatchPath)
        : isSet(object.json_patch_path)
        ? globalThis.String(object.json_patch_path)
        : "",
    };
  },

  toJSON(message: SecureEgressRequest): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    if (message.jsonPatchPath !== "") {
      obj.jsonPatchPath = message.jsonPatchPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecureEgressRequest>, I>>(base?: I): SecureEgressRequest {
    return SecureEgressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecureEgressRequest>, I>>(object: I): SecureEgressRequest {
    const message = createBaseSecureEgressRequest();
    message.domain = object.domain ?? "";
    message.path = object.path ?? "";
    message.method = object.method ?? "";
    message.body = object.body ?? new Uint8Array(0);
    message.secretId = object.secretId ?? "";
    message.jsonPatchPath = object.jsonPatchPath ?? "";
    return message;
  },
};

function createBaseSecureEgressResponse(): SecureEgressResponse {
  return { body: new Uint8Array(0), certHash: new Uint8Array(0), guardianSignature: new Uint8Array(0) };
}

export const SecureEgressResponse: MessageFns<SecureEgressResponse> = {
  encode(message: SecureEgressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body.length !== 0) {
      writer.uint32(10).bytes(message.body);
    }
    if (message.certHash.length !== 0) {
      writer.uint32(18).bytes(message.certHash);
    }
    if (message.guardianSignature.length !== 0) {
      writer.uint32(26).bytes(message.guardianSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecureEgressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecureEgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.certHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.guardianSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecureEgressResponse {
    return {
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      certHash: isSet(object.certHash)
        ? bytesFromBase64(object.certHash)
        : isSet(object.cert_hash)
        ? bytesFromBase64(object.cert_hash)
        : new Uint8Array(0),
      guardianSignature: isSet(object.guardianSignature)
        ? bytesFromBase64(object.guardianSignature)
        : isSet(object.guardian_signature)
        ? bytesFromBase64(object.guardian_signature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SecureEgressResponse): unknown {
    const obj: any = {};
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.certHash.length !== 0) {
      obj.certHash = base64FromBytes(message.certHash);
    }
    if (message.guardianSignature.length !== 0) {
      obj.guardianSignature = base64FromBytes(message.guardianSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecureEgressResponse>, I>>(base?: I): SecureEgressResponse {
    return SecureEgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecureEgressResponse>, I>>(object: I): SecureEgressResponse {
    const message = createBaseSecureEgressResponse();
    message.body = object.body ?? new Uint8Array(0);
    message.certHash = object.certHash ?? new Uint8Array(0);
    message.guardianSignature = object.guardianSignature ?? new Uint8Array(0);
    return message;
  },
};

/**
 * The service provided by the Workload container to the Orchestrator.
 * Used for high-frequency, low-latency signaling.
 */
export type WorkloadControlService = typeof WorkloadControlService;
export const WorkloadControlService = {
  /** Prepares a model or execution context in memory. */
  loadModel: {
    path: "/ioi.control.v1.WorkloadControl/LoadModel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoadModelRequest): Buffer => Buffer.from(LoadModelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoadModelRequest => LoadModelRequest.decode(value),
    responseSerialize: (value: LoadModelResponse): Buffer => Buffer.from(LoadModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoadModelResponse => LoadModelResponse.decode(value),
  },
  /**
   * Triggers execution of a job.
   * Inputs/Outputs are read/written directly from Shared Memory via the Data Plane.
   */
  executeJob: {
    path: "/ioi.control.v1.WorkloadControl/ExecuteJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteJobRequest): Buffer => Buffer.from(ExecuteJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecuteJobRequest => ExecuteJobRequest.decode(value),
    responseSerialize: (value: ExecuteJobResponse): Buffer => Buffer.from(ExecuteJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecuteJobResponse => ExecuteJobResponse.decode(value),
  },
  /** Liveness probe. */
  healthCheck: {
    path: "/ioi.control.v1.WorkloadControl/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface WorkloadControlServer extends UntypedServiceImplementation {
  /** Prepares a model or execution context in memory. */
  loadModel: handleUnaryCall<LoadModelRequest, LoadModelResponse>;
  /**
   * Triggers execution of a job.
   * Inputs/Outputs are read/written directly from Shared Memory via the Data Plane.
   */
  executeJob: handleUnaryCall<ExecuteJobRequest, ExecuteJobResponse>;
  /** Liveness probe. */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface WorkloadControlClient extends Client {
  /** Prepares a model or execution context in memory. */
  loadModel(
    request: LoadModelRequest,
    callback: (error: ServiceError | null, response: LoadModelResponse) => void,
  ): ClientUnaryCall;
  loadModel(
    request: LoadModelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoadModelResponse) => void,
  ): ClientUnaryCall;
  loadModel(
    request: LoadModelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoadModelResponse) => void,
  ): ClientUnaryCall;
  /**
   * Triggers execution of a job.
   * Inputs/Outputs are read/written directly from Shared Memory via the Data Plane.
   */
  executeJob(
    request: ExecuteJobRequest,
    callback: (error: ServiceError | null, response: ExecuteJobResponse) => void,
  ): ClientUnaryCall;
  executeJob(
    request: ExecuteJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecuteJobResponse) => void,
  ): ClientUnaryCall;
  executeJob(
    request: ExecuteJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecuteJobResponse) => void,
  ): ClientUnaryCall;
  /** Liveness probe. */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const WorkloadControlClient = makeGenericClientConstructor(
  WorkloadControlService,
  "ioi.control.v1.WorkloadControl",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WorkloadControlClient;
  service: typeof WorkloadControlService;
  serviceName: string;
};

/**
 * Service exposed by the Guardian container to the Workload.
 * Used for secure egress and key management.
 */
export type GuardianControlService = typeof GuardianControlService;
export const GuardianControlService = {
  /** Execute an HTTP call using a secret securely held by the Guardian. */
  secureEgress: {
    path: "/ioi.control.v1.GuardianControl/SecureEgress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SecureEgressRequest): Buffer => Buffer.from(SecureEgressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SecureEgressRequest => SecureEgressRequest.decode(value),
    responseSerialize: (value: SecureEgressResponse): Buffer =>
      Buffer.from(SecureEgressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SecureEgressResponse => SecureEgressResponse.decode(value),
  },
} as const;

export interface GuardianControlServer extends UntypedServiceImplementation {
  /** Execute an HTTP call using a secret securely held by the Guardian. */
  secureEgress: handleUnaryCall<SecureEgressRequest, SecureEgressResponse>;
}

export interface GuardianControlClient extends Client {
  /** Execute an HTTP call using a secret securely held by the Guardian. */
  secureEgress(
    request: SecureEgressRequest,
    callback: (error: ServiceError | null, response: SecureEgressResponse) => void,
  ): ClientUnaryCall;
  secureEgress(
    request: SecureEgressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SecureEgressResponse) => void,
  ): ClientUnaryCall;
  secureEgress(
    request: SecureEgressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SecureEgressResponse) => void,
  ): ClientUnaryCall;
}

export const GuardianControlClient = makeGenericClientConstructor(
  GuardianControlService,
  "ioi.control.v1.GuardianControl",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GuardianControlClient;
  service: typeof GuardianControlService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
