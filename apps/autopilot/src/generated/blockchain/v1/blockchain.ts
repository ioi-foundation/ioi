// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.12.4
// source: blockchain/v1/blockchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../google/protobuf/empty";

export const protobufPackage = "ioi.blockchain.v1";

/** Path: crates/ipc/proto/blockchain/v1/blockchain.proto */

/** A pointer to data residing in the shared memory region (Zero-Copy). */
export interface SharedMemoryHandle {
  /** The identifier of the shared memory region (e.g., "/ioi_shmem_data_plane") */
  regionId: string;
  /** The byte offset where the data begins */
  offset: number;
  /** The length of the data in bytes */
  length: number;
}

/** BFT Voting Proof (QC) */
export interface QuorumCertificate {
  height: number;
  view: number;
  blockHash: Uint8Array;
  /** List of (Validator ID, Signature) tuples, SCALE encoded */
  signatures: Uint8Array;
}

export interface ProcessBlockRequest {
  /** SCALE-encoded Block<ChainTransaction> passed directly over gRPC. */
  blockBytesInline?:
    | Uint8Array
    | undefined;
  /** Pointer to block data in shared memory. */
  shmemHandle?: SharedMemoryHandle | undefined;
}

export interface ProcessBlockResponse {
  /** SCALE-encoded Block<ChainTransaction> (processed) */
  blockBytes: Uint8Array;
  events: Uint8Array[];
}

export interface GetBlocksRangeRequest {
  since: number;
  maxBlocks: number;
  maxBytes: number;
}

export interface GetBlocksRangeResponse {
  /** Standard gRPC list of blocks. */
  inline?:
    | BlockList
    | undefined;
  /** Pointer to serialized vector of blocks in shared memory. */
  shmem?: SharedMemoryHandle | undefined;
}

/** Wrapper message because `repeated` cannot be inside `oneof`. */
export interface BlockList {
  /** SCALE-encoded blocks */
  blocks: Uint8Array[];
}

export interface UpdateBlockHeaderRequest {
  /** SCALE-encoded Block */
  blockBytes: Uint8Array;
}

export interface UpdateBlockHeaderResponse {
}

export interface GetGenesisStatusRequest {
}

export interface GetGenesisStatusResponse {
  ready: boolean;
  root: Uint8Array;
  chainId: string;
}

export interface GetStatusRequest {
}

export interface GetStatusResponse {
  height: number;
  latestTimestamp: number;
  totalTransactions: number;
  isRunning: boolean;
}

export interface CheckTransactionsRequest {
  /** StateAnchor (32 bytes) */
  anchor: Uint8Array;
  expectedTimestampSecs: number;
  /** SCALE-encoded ChainTransaction */
  txs: Uint8Array[];
}

export interface CheckTransactionsResponse {
  results: CheckResult[];
}

export interface CheckResult {
  success: boolean;
  error: string;
}

export interface QueryStateAtRequest {
  /** StateRoot raw bytes */
  root: Uint8Array;
  key: Uint8Array;
}

export interface QueryStateAtResponse {
  /** SCALE-encoded QueryStateResponse struct (from api/chain) */
  responseBytes: Uint8Array;
}

export interface QueryRawStateRequest {
  key: Uint8Array;
}

export interface QueryRawStateResponse {
  /** Empty if null */
  value: Uint8Array;
  found: boolean;
}

export interface PrefixScanRequest {
  prefix: Uint8Array;
}

export interface PrefixScanResponse {
  pairs: KeyValuePair[];
}

export interface KeyValuePair {
  key: Uint8Array;
  value: Uint8Array;
}

export interface DeployContractRequest {
  code: Uint8Array;
  sender: Uint8Array;
}

export interface DeployContractResponse {
  address: Uint8Array;
  stateChanges: KeyValuePair[];
}

export interface CallContractRequest {
  address: Uint8Array;
  inputData: Uint8Array;
  /** SCALE-encoded ioi_api::vm::ExecutionContext */
  contextBytes: Uint8Array;
}

export interface CallContractResponse {
  /** SCALE-encoded ExecutionOutput */
  executionOutput: Uint8Array;
  /** Insertions/Updates */
  stateChanges: KeyValuePair[];
  /** Keys to delete */
  deletions: Uint8Array[];
}

export interface QueryContractRequest {
  address: Uint8Array;
  inputData: Uint8Array;
  contextBytes: Uint8Array;
}

export interface QueryContractResponse {
  executionOutput: Uint8Array;
}

export interface GetStakedValidatorsRequest {
}

export interface GetStakedValidatorsResponse {
  /** AccountId (hex string) -> stake */
  validators: { [key: string]: number };
}

export interface GetStakedValidatorsResponse_ValidatorsEntry {
  key: string;
  value: number;
}

export interface GetNextStakedValidatorsRequest {
}

export interface GetNextStakedValidatorsResponse {
  /** AccountId (hex string) -> stake */
  validators: { [key: string]: number };
}

export interface GetNextStakedValidatorsResponse_ValidatorsEntry {
  key: string;
  value: number;
}

export interface GetExpectedModelHashResponse {
  hash: Uint8Array;
}

export interface CheckAndTallyProposalsRequest {
  currentHeight: number;
}

export interface CheckAndTallyProposalsResponse {
  logs: string[];
}

export interface DebugPinHeightRequest {
  height: number;
}

export interface DebugUnpinHeightRequest {
  height: number;
}

export interface DebugTriggerGcResponse {
  heightsPruned: number;
  nodesDeleted: number;
}

function createBaseSharedMemoryHandle(): SharedMemoryHandle {
  return { regionId: "", offset: 0, length: 0 };
}

export const SharedMemoryHandle: MessageFns<SharedMemoryHandle> = {
  encode(message: SharedMemoryHandle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regionId !== "") {
      writer.uint32(10).string(message.regionId);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.length !== 0) {
      writer.uint32(24).uint64(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SharedMemoryHandle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSharedMemoryHandle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.length = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SharedMemoryHandle {
    return {
      regionId: isSet(object.regionId)
        ? globalThis.String(object.regionId)
        : isSet(object.region_id)
        ? globalThis.String(object.region_id)
        : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: SharedMemoryHandle): unknown {
    const obj: any = {};
    if (message.regionId !== "") {
      obj.regionId = message.regionId;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SharedMemoryHandle>, I>>(base?: I): SharedMemoryHandle {
    return SharedMemoryHandle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SharedMemoryHandle>, I>>(object: I): SharedMemoryHandle {
    const message = createBaseSharedMemoryHandle();
    message.regionId = object.regionId ?? "";
    message.offset = object.offset ?? 0;
    message.length = object.length ?? 0;
    return message;
  },
};

function createBaseQuorumCertificate(): QuorumCertificate {
  return { height: 0, view: 0, blockHash: new Uint8Array(0), signatures: new Uint8Array(0) };
}

export const QuorumCertificate: MessageFns<QuorumCertificate> = {
  encode(message: QuorumCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    if (message.view !== 0) {
      writer.uint32(16).uint64(message.view);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(26).bytes(message.blockHash);
    }
    if (message.signatures.length !== 0) {
      writer.uint32(34).bytes(message.signatures);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuorumCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuorumCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.view = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signatures = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuorumCertificate {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      view: isSet(object.view) ? globalThis.Number(object.view) : 0,
      blockHash: isSet(object.blockHash)
        ? bytesFromBase64(object.blockHash)
        : isSet(object.block_hash)
        ? bytesFromBase64(object.block_hash)
        : new Uint8Array(0),
      signatures: isSet(object.signatures) ? bytesFromBase64(object.signatures) : new Uint8Array(0),
    };
  },

  toJSON(message: QuorumCertificate): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.view !== 0) {
      obj.view = Math.round(message.view);
    }
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    if (message.signatures.length !== 0) {
      obj.signatures = base64FromBytes(message.signatures);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuorumCertificate>, I>>(base?: I): QuorumCertificate {
    return QuorumCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuorumCertificate>, I>>(object: I): QuorumCertificate {
    const message = createBaseQuorumCertificate();
    message.height = object.height ?? 0;
    message.view = object.view ?? 0;
    message.blockHash = object.blockHash ?? new Uint8Array(0);
    message.signatures = object.signatures ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProcessBlockRequest(): ProcessBlockRequest {
  return { blockBytesInline: undefined, shmemHandle: undefined };
}

export const ProcessBlockRequest: MessageFns<ProcessBlockRequest> = {
  encode(message: ProcessBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockBytesInline !== undefined) {
      writer.uint32(10).bytes(message.blockBytesInline);
    }
    if (message.shmemHandle !== undefined) {
      SharedMemoryHandle.encode(message.shmemHandle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockBytesInline = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shmemHandle = SharedMemoryHandle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessBlockRequest {
    return {
      blockBytesInline: isSet(object.blockBytesInline)
        ? bytesFromBase64(object.blockBytesInline)
        : isSet(object.block_bytes_inline)
        ? bytesFromBase64(object.block_bytes_inline)
        : undefined,
      shmemHandle: isSet(object.shmemHandle)
        ? SharedMemoryHandle.fromJSON(object.shmemHandle)
        : isSet(object.shmem_handle)
        ? SharedMemoryHandle.fromJSON(object.shmem_handle)
        : undefined,
    };
  },

  toJSON(message: ProcessBlockRequest): unknown {
    const obj: any = {};
    if (message.blockBytesInline !== undefined) {
      obj.blockBytesInline = base64FromBytes(message.blockBytesInline);
    }
    if (message.shmemHandle !== undefined) {
      obj.shmemHandle = SharedMemoryHandle.toJSON(message.shmemHandle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessBlockRequest>, I>>(base?: I): ProcessBlockRequest {
    return ProcessBlockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessBlockRequest>, I>>(object: I): ProcessBlockRequest {
    const message = createBaseProcessBlockRequest();
    message.blockBytesInline = object.blockBytesInline ?? undefined;
    message.shmemHandle = (object.shmemHandle !== undefined && object.shmemHandle !== null)
      ? SharedMemoryHandle.fromPartial(object.shmemHandle)
      : undefined;
    return message;
  },
};

function createBaseProcessBlockResponse(): ProcessBlockResponse {
  return { blockBytes: new Uint8Array(0), events: [] };
}

export const ProcessBlockResponse: MessageFns<ProcessBlockResponse> = {
  encode(message: ProcessBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockBytes.length !== 0) {
      writer.uint32(10).bytes(message.blockBytes);
    }
    for (const v of message.events) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockBytes = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.events.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessBlockResponse {
    return {
      blockBytes: isSet(object.blockBytes)
        ? bytesFromBase64(object.blockBytes)
        : isSet(object.block_bytes)
        ? bytesFromBase64(object.block_bytes)
        : new Uint8Array(0),
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: ProcessBlockResponse): unknown {
    const obj: any = {};
    if (message.blockBytes.length !== 0) {
      obj.blockBytes = base64FromBytes(message.blockBytes);
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessBlockResponse>, I>>(base?: I): ProcessBlockResponse {
    return ProcessBlockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessBlockResponse>, I>>(object: I): ProcessBlockResponse {
    const message = createBaseProcessBlockResponse();
    message.blockBytes = object.blockBytes ?? new Uint8Array(0);
    message.events = object.events?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBlocksRangeRequest(): GetBlocksRangeRequest {
  return { since: 0, maxBlocks: 0, maxBytes: 0 };
}

export const GetBlocksRangeRequest: MessageFns<GetBlocksRangeRequest> = {
  encode(message: GetBlocksRangeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.since !== 0) {
      writer.uint32(8).uint64(message.since);
    }
    if (message.maxBlocks !== 0) {
      writer.uint32(16).uint32(message.maxBlocks);
    }
    if (message.maxBytes !== 0) {
      writer.uint32(24).uint32(message.maxBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlocksRangeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlocksRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.since = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxBlocks = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxBytes = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlocksRangeRequest {
    return {
      since: isSet(object.since) ? globalThis.Number(object.since) : 0,
      maxBlocks: isSet(object.maxBlocks)
        ? globalThis.Number(object.maxBlocks)
        : isSet(object.max_blocks)
        ? globalThis.Number(object.max_blocks)
        : 0,
      maxBytes: isSet(object.maxBytes)
        ? globalThis.Number(object.maxBytes)
        : isSet(object.max_bytes)
        ? globalThis.Number(object.max_bytes)
        : 0,
    };
  },

  toJSON(message: GetBlocksRangeRequest): unknown {
    const obj: any = {};
    if (message.since !== 0) {
      obj.since = Math.round(message.since);
    }
    if (message.maxBlocks !== 0) {
      obj.maxBlocks = Math.round(message.maxBlocks);
    }
    if (message.maxBytes !== 0) {
      obj.maxBytes = Math.round(message.maxBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlocksRangeRequest>, I>>(base?: I): GetBlocksRangeRequest {
    return GetBlocksRangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlocksRangeRequest>, I>>(object: I): GetBlocksRangeRequest {
    const message = createBaseGetBlocksRangeRequest();
    message.since = object.since ?? 0;
    message.maxBlocks = object.maxBlocks ?? 0;
    message.maxBytes = object.maxBytes ?? 0;
    return message;
  },
};

function createBaseGetBlocksRangeResponse(): GetBlocksRangeResponse {
  return { inline: undefined, shmem: undefined };
}

export const GetBlocksRangeResponse: MessageFns<GetBlocksRangeResponse> = {
  encode(message: GetBlocksRangeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inline !== undefined) {
      BlockList.encode(message.inline, writer.uint32(10).fork()).join();
    }
    if (message.shmem !== undefined) {
      SharedMemoryHandle.encode(message.shmem, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlocksRangeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlocksRangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inline = BlockList.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shmem = SharedMemoryHandle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlocksRangeResponse {
    return {
      inline: isSet(object.inline) ? BlockList.fromJSON(object.inline) : undefined,
      shmem: isSet(object.shmem) ? SharedMemoryHandle.fromJSON(object.shmem) : undefined,
    };
  },

  toJSON(message: GetBlocksRangeResponse): unknown {
    const obj: any = {};
    if (message.inline !== undefined) {
      obj.inline = BlockList.toJSON(message.inline);
    }
    if (message.shmem !== undefined) {
      obj.shmem = SharedMemoryHandle.toJSON(message.shmem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlocksRangeResponse>, I>>(base?: I): GetBlocksRangeResponse {
    return GetBlocksRangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlocksRangeResponse>, I>>(object: I): GetBlocksRangeResponse {
    const message = createBaseGetBlocksRangeResponse();
    message.inline = (object.inline !== undefined && object.inline !== null)
      ? BlockList.fromPartial(object.inline)
      : undefined;
    message.shmem = (object.shmem !== undefined && object.shmem !== null)
      ? SharedMemoryHandle.fromPartial(object.shmem)
      : undefined;
    return message;
  },
};

function createBaseBlockList(): BlockList {
  return { blocks: [] };
}

export const BlockList: MessageFns<BlockList> = {
  encode(message: BlockList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blocks) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blocks.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockList {
    return {
      blocks: globalThis.Array.isArray(object?.blocks) ? object.blocks.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: BlockList): unknown {
    const obj: any = {};
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockList>, I>>(base?: I): BlockList {
    return BlockList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockList>, I>>(object: I): BlockList {
    const message = createBaseBlockList();
    message.blocks = object.blocks?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateBlockHeaderRequest(): UpdateBlockHeaderRequest {
  return { blockBytes: new Uint8Array(0) };
}

export const UpdateBlockHeaderRequest: MessageFns<UpdateBlockHeaderRequest> = {
  encode(message: UpdateBlockHeaderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockBytes.length !== 0) {
      writer.uint32(10).bytes(message.blockBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBlockHeaderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBlockHeaderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBlockHeaderRequest {
    return {
      blockBytes: isSet(object.blockBytes)
        ? bytesFromBase64(object.blockBytes)
        : isSet(object.block_bytes)
        ? bytesFromBase64(object.block_bytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: UpdateBlockHeaderRequest): unknown {
    const obj: any = {};
    if (message.blockBytes.length !== 0) {
      obj.blockBytes = base64FromBytes(message.blockBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBlockHeaderRequest>, I>>(base?: I): UpdateBlockHeaderRequest {
    return UpdateBlockHeaderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBlockHeaderRequest>, I>>(object: I): UpdateBlockHeaderRequest {
    const message = createBaseUpdateBlockHeaderRequest();
    message.blockBytes = object.blockBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUpdateBlockHeaderResponse(): UpdateBlockHeaderResponse {
  return {};
}

export const UpdateBlockHeaderResponse: MessageFns<UpdateBlockHeaderResponse> = {
  encode(_: UpdateBlockHeaderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBlockHeaderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBlockHeaderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateBlockHeaderResponse {
    return {};
  },

  toJSON(_: UpdateBlockHeaderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBlockHeaderResponse>, I>>(base?: I): UpdateBlockHeaderResponse {
    return UpdateBlockHeaderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBlockHeaderResponse>, I>>(_: I): UpdateBlockHeaderResponse {
    const message = createBaseUpdateBlockHeaderResponse();
    return message;
  },
};

function createBaseGetGenesisStatusRequest(): GetGenesisStatusRequest {
  return {};
}

export const GetGenesisStatusRequest: MessageFns<GetGenesisStatusRequest> = {
  encode(_: GetGenesisStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGenesisStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGenesisStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetGenesisStatusRequest {
    return {};
  },

  toJSON(_: GetGenesisStatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGenesisStatusRequest>, I>>(base?: I): GetGenesisStatusRequest {
    return GetGenesisStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGenesisStatusRequest>, I>>(_: I): GetGenesisStatusRequest {
    const message = createBaseGetGenesisStatusRequest();
    return message;
  },
};

function createBaseGetGenesisStatusResponse(): GetGenesisStatusResponse {
  return { ready: false, root: new Uint8Array(0), chainId: "" };
}

export const GetGenesisStatusResponse: MessageFns<GetGenesisStatusResponse> = {
  encode(message: GetGenesisStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ready !== false) {
      writer.uint32(8).bool(message.ready);
    }
    if (message.root.length !== 0) {
      writer.uint32(18).bytes(message.root);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGenesisStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGenesisStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ready = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.root = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGenesisStatusResponse {
    return {
      ready: isSet(object.ready) ? globalThis.Boolean(object.ready) : false,
      root: isSet(object.root) ? bytesFromBase64(object.root) : new Uint8Array(0),
      chainId: isSet(object.chainId)
        ? globalThis.String(object.chainId)
        : isSet(object.chain_id)
        ? globalThis.String(object.chain_id)
        : "",
    };
  },

  toJSON(message: GetGenesisStatusResponse): unknown {
    const obj: any = {};
    if (message.ready !== false) {
      obj.ready = message.ready;
    }
    if (message.root.length !== 0) {
      obj.root = base64FromBytes(message.root);
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGenesisStatusResponse>, I>>(base?: I): GetGenesisStatusResponse {
    return GetGenesisStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGenesisStatusResponse>, I>>(object: I): GetGenesisStatusResponse {
    const message = createBaseGetGenesisStatusResponse();
    message.ready = object.ready ?? false;
    message.root = object.root ?? new Uint8Array(0);
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseGetStatusRequest(): GetStatusRequest {
  return {};
}

export const GetStatusRequest: MessageFns<GetStatusRequest> = {
  encode(_: GetStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStatusRequest {
    return {};
  },

  toJSON(_: GetStatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatusRequest>, I>>(base?: I): GetStatusRequest {
    return GetStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatusRequest>, I>>(_: I): GetStatusRequest {
    const message = createBaseGetStatusRequest();
    return message;
  },
};

function createBaseGetStatusResponse(): GetStatusResponse {
  return { height: 0, latestTimestamp: 0, totalTransactions: 0, isRunning: false };
}

export const GetStatusResponse: MessageFns<GetStatusResponse> = {
  encode(message: GetStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    if (message.latestTimestamp !== 0) {
      writer.uint32(16).uint64(message.latestTimestamp);
    }
    if (message.totalTransactions !== 0) {
      writer.uint32(24).uint64(message.totalTransactions);
    }
    if (message.isRunning !== false) {
      writer.uint32(32).bool(message.isRunning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.latestTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalTransactions = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isRunning = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatusResponse {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      latestTimestamp: isSet(object.latestTimestamp)
        ? globalThis.Number(object.latestTimestamp)
        : isSet(object.latest_timestamp)
        ? globalThis.Number(object.latest_timestamp)
        : 0,
      totalTransactions: isSet(object.totalTransactions)
        ? globalThis.Number(object.totalTransactions)
        : isSet(object.total_transactions)
        ? globalThis.Number(object.total_transactions)
        : 0,
      isRunning: isSet(object.isRunning)
        ? globalThis.Boolean(object.isRunning)
        : isSet(object.is_running)
        ? globalThis.Boolean(object.is_running)
        : false,
    };
  },

  toJSON(message: GetStatusResponse): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.latestTimestamp !== 0) {
      obj.latestTimestamp = Math.round(message.latestTimestamp);
    }
    if (message.totalTransactions !== 0) {
      obj.totalTransactions = Math.round(message.totalTransactions);
    }
    if (message.isRunning !== false) {
      obj.isRunning = message.isRunning;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatusResponse>, I>>(base?: I): GetStatusResponse {
    return GetStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatusResponse>, I>>(object: I): GetStatusResponse {
    const message = createBaseGetStatusResponse();
    message.height = object.height ?? 0;
    message.latestTimestamp = object.latestTimestamp ?? 0;
    message.totalTransactions = object.totalTransactions ?? 0;
    message.isRunning = object.isRunning ?? false;
    return message;
  },
};

function createBaseCheckTransactionsRequest(): CheckTransactionsRequest {
  return { anchor: new Uint8Array(0), expectedTimestampSecs: 0, txs: [] };
}

export const CheckTransactionsRequest: MessageFns<CheckTransactionsRequest> = {
  encode(message: CheckTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchor.length !== 0) {
      writer.uint32(10).bytes(message.anchor);
    }
    if (message.expectedTimestampSecs !== 0) {
      writer.uint32(16).uint64(message.expectedTimestampSecs);
    }
    for (const v of message.txs) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.anchor = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expectedTimestampSecs = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckTransactionsRequest {
    return {
      anchor: isSet(object.anchor) ? bytesFromBase64(object.anchor) : new Uint8Array(0),
      expectedTimestampSecs: isSet(object.expectedTimestampSecs)
        ? globalThis.Number(object.expectedTimestampSecs)
        : isSet(object.expected_timestamp_secs)
        ? globalThis.Number(object.expected_timestamp_secs)
        : 0,
      txs: globalThis.Array.isArray(object?.txs) ? object.txs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: CheckTransactionsRequest): unknown {
    const obj: any = {};
    if (message.anchor.length !== 0) {
      obj.anchor = base64FromBytes(message.anchor);
    }
    if (message.expectedTimestampSecs !== 0) {
      obj.expectedTimestampSecs = Math.round(message.expectedTimestampSecs);
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckTransactionsRequest>, I>>(base?: I): CheckTransactionsRequest {
    return CheckTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckTransactionsRequest>, I>>(object: I): CheckTransactionsRequest {
    const message = createBaseCheckTransactionsRequest();
    message.anchor = object.anchor ?? new Uint8Array(0);
    message.expectedTimestampSecs = object.expectedTimestampSecs ?? 0;
    message.txs = object.txs?.map((e) => e) || [];
    return message;
  },
};

function createBaseCheckTransactionsResponse(): CheckTransactionsResponse {
  return { results: [] };
}

export const CheckTransactionsResponse: MessageFns<CheckTransactionsResponse> = {
  encode(message: CheckTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      CheckResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(CheckResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckTransactionsResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => CheckResult.fromJSON(e)) : [],
    };
  },

  toJSON(message: CheckTransactionsResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => CheckResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckTransactionsResponse>, I>>(base?: I): CheckTransactionsResponse {
    return CheckTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckTransactionsResponse>, I>>(object: I): CheckTransactionsResponse {
    const message = createBaseCheckTransactionsResponse();
    message.results = object.results?.map((e) => CheckResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCheckResult(): CheckResult {
  return { success: false, error: "" };
}

export const CheckResult: MessageFns<CheckResult> = {
  encode(message: CheckResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckResult {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CheckResult): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckResult>, I>>(base?: I): CheckResult {
    return CheckResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckResult>, I>>(object: I): CheckResult {
    const message = createBaseCheckResult();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseQueryStateAtRequest(): QueryStateAtRequest {
  return { root: new Uint8Array(0), key: new Uint8Array(0) };
}

export const QueryStateAtRequest: MessageFns<QueryStateAtRequest> = {
  encode(message: QueryStateAtRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.root.length !== 0) {
      writer.uint32(10).bytes(message.root);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStateAtRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateAtRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.root = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateAtRequest {
    return {
      root: isSet(object.root) ? bytesFromBase64(object.root) : new Uint8Array(0),
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryStateAtRequest): unknown {
    const obj: any = {};
    if (message.root.length !== 0) {
      obj.root = base64FromBytes(message.root);
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStateAtRequest>, I>>(base?: I): QueryStateAtRequest {
    return QueryStateAtRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStateAtRequest>, I>>(object: I): QueryStateAtRequest {
    const message = createBaseQueryStateAtRequest();
    message.root = object.root ?? new Uint8Array(0);
    message.key = object.key ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryStateAtResponse(): QueryStateAtResponse {
  return { responseBytes: new Uint8Array(0) };
}

export const QueryStateAtResponse: MessageFns<QueryStateAtResponse> = {
  encode(message: QueryStateAtResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseBytes.length !== 0) {
      writer.uint32(10).bytes(message.responseBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStateAtResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateAtResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.responseBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateAtResponse {
    return {
      responseBytes: isSet(object.responseBytes)
        ? bytesFromBase64(object.responseBytes)
        : isSet(object.response_bytes)
        ? bytesFromBase64(object.response_bytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryStateAtResponse): unknown {
    const obj: any = {};
    if (message.responseBytes.length !== 0) {
      obj.responseBytes = base64FromBytes(message.responseBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStateAtResponse>, I>>(base?: I): QueryStateAtResponse {
    return QueryStateAtResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStateAtResponse>, I>>(object: I): QueryStateAtResponse {
    const message = createBaseQueryStateAtResponse();
    message.responseBytes = object.responseBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryRawStateRequest(): QueryRawStateRequest {
  return { key: new Uint8Array(0) };
}

export const QueryRawStateRequest: MessageFns<QueryRawStateRequest> = {
  encode(message: QueryRawStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRawStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRawStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRawStateRequest {
    return { key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0) };
  },

  toJSON(message: QueryRawStateRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRawStateRequest>, I>>(base?: I): QueryRawStateRequest {
    return QueryRawStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRawStateRequest>, I>>(object: I): QueryRawStateRequest {
    const message = createBaseQueryRawStateRequest();
    message.key = object.key ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryRawStateResponse(): QueryRawStateResponse {
  return { value: new Uint8Array(0), found: false };
}

export const QueryRawStateResponse: MessageFns<QueryRawStateResponse> = {
  encode(message: QueryRawStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRawStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRawStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRawStateResponse {
    return {
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryRawStateResponse): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRawStateResponse>, I>>(base?: I): QueryRawStateResponse {
    return QueryRawStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRawStateResponse>, I>>(object: I): QueryRawStateResponse {
    const message = createBaseQueryRawStateResponse();
    message.value = object.value ?? new Uint8Array(0);
    message.found = object.found ?? false;
    return message;
  },
};

function createBasePrefixScanRequest(): PrefixScanRequest {
  return { prefix: new Uint8Array(0) };
}

export const PrefixScanRequest: MessageFns<PrefixScanRequest> = {
  encode(message: PrefixScanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefix.length !== 0) {
      writer.uint32(10).bytes(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrefixScanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefixScanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prefix = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrefixScanRequest {
    return { prefix: isSet(object.prefix) ? bytesFromBase64(object.prefix) : new Uint8Array(0) };
  },

  toJSON(message: PrefixScanRequest): unknown {
    const obj: any = {};
    if (message.prefix.length !== 0) {
      obj.prefix = base64FromBytes(message.prefix);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrefixScanRequest>, I>>(base?: I): PrefixScanRequest {
    return PrefixScanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrefixScanRequest>, I>>(object: I): PrefixScanRequest {
    const message = createBasePrefixScanRequest();
    message.prefix = object.prefix ?? new Uint8Array(0);
    return message;
  },
};

function createBasePrefixScanResponse(): PrefixScanResponse {
  return { pairs: [] };
}

export const PrefixScanResponse: MessageFns<PrefixScanResponse> = {
  encode(message: PrefixScanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pairs) {
      KeyValuePair.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrefixScanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefixScanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairs.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrefixScanResponse {
    return {
      pairs: globalThis.Array.isArray(object?.pairs) ? object.pairs.map((e: any) => KeyValuePair.fromJSON(e)) : [],
    };
  },

  toJSON(message: PrefixScanResponse): unknown {
    const obj: any = {};
    if (message.pairs?.length) {
      obj.pairs = message.pairs.map((e) => KeyValuePair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrefixScanResponse>, I>>(base?: I): PrefixScanResponse {
    return PrefixScanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrefixScanResponse>, I>>(object: I): PrefixScanResponse {
    const message = createBasePrefixScanResponse();
    message.pairs = object.pairs?.map((e) => KeyValuePair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyValuePair(): KeyValuePair {
  return { key: new Uint8Array(0), value: new Uint8Array(0) };
}

export const KeyValuePair: MessageFns<KeyValuePair> = {
  encode(message: KeyValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValuePair {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: KeyValuePair): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyValuePair>, I>>(base?: I): KeyValuePair {
    return KeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyValuePair>, I>>(object: I): KeyValuePair {
    const message = createBaseKeyValuePair();
    message.key = object.key ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeployContractRequest(): DeployContractRequest {
  return { code: new Uint8Array(0), sender: new Uint8Array(0) };
}

export const DeployContractRequest: MessageFns<DeployContractRequest> = {
  encode(message: DeployContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code.length !== 0) {
      writer.uint32(10).bytes(message.code);
    }
    if (message.sender.length !== 0) {
      writer.uint32(18).bytes(message.sender);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployContractRequest {
    return {
      code: isSet(object.code) ? bytesFromBase64(object.code) : new Uint8Array(0),
      sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(0),
    };
  },

  toJSON(message: DeployContractRequest): unknown {
    const obj: any = {};
    if (message.code.length !== 0) {
      obj.code = base64FromBytes(message.code);
    }
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployContractRequest>, I>>(base?: I): DeployContractRequest {
    return DeployContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployContractRequest>, I>>(object: I): DeployContractRequest {
    const message = createBaseDeployContractRequest();
    message.code = object.code ?? new Uint8Array(0);
    message.sender = object.sender ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeployContractResponse(): DeployContractResponse {
  return { address: new Uint8Array(0), stateChanges: [] };
}

export const DeployContractResponse: MessageFns<DeployContractResponse> = {
  encode(message: DeployContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    for (const v of message.stateChanges) {
      KeyValuePair.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stateChanges.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployContractResponse {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      stateChanges: globalThis.Array.isArray(object?.stateChanges)
        ? object.stateChanges.map((e: any) => KeyValuePair.fromJSON(e))
        : globalThis.Array.isArray(object?.state_changes)
        ? object.state_changes.map((e: any) => KeyValuePair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DeployContractResponse): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.stateChanges?.length) {
      obj.stateChanges = message.stateChanges.map((e) => KeyValuePair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployContractResponse>, I>>(base?: I): DeployContractResponse {
    return DeployContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployContractResponse>, I>>(object: I): DeployContractResponse {
    const message = createBaseDeployContractResponse();
    message.address = object.address ?? new Uint8Array(0);
    message.stateChanges = object.stateChanges?.map((e) => KeyValuePair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallContractRequest(): CallContractRequest {
  return { address: new Uint8Array(0), inputData: new Uint8Array(0), contextBytes: new Uint8Array(0) };
}

export const CallContractRequest: MessageFns<CallContractRequest> = {
  encode(message: CallContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.inputData.length !== 0) {
      writer.uint32(18).bytes(message.inputData);
    }
    if (message.contextBytes.length !== 0) {
      writer.uint32(26).bytes(message.contextBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputData = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contextBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractRequest {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      inputData: isSet(object.inputData)
        ? bytesFromBase64(object.inputData)
        : isSet(object.input_data)
        ? bytesFromBase64(object.input_data)
        : new Uint8Array(0),
      contextBytes: isSet(object.contextBytes)
        ? bytesFromBase64(object.contextBytes)
        : isSet(object.context_bytes)
        ? bytesFromBase64(object.context_bytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CallContractRequest): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.inputData.length !== 0) {
      obj.inputData = base64FromBytes(message.inputData);
    }
    if (message.contextBytes.length !== 0) {
      obj.contextBytes = base64FromBytes(message.contextBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractRequest>, I>>(base?: I): CallContractRequest {
    return CallContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractRequest>, I>>(object: I): CallContractRequest {
    const message = createBaseCallContractRequest();
    message.address = object.address ?? new Uint8Array(0);
    message.inputData = object.inputData ?? new Uint8Array(0);
    message.contextBytes = object.contextBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCallContractResponse(): CallContractResponse {
  return { executionOutput: new Uint8Array(0), stateChanges: [], deletions: [] };
}

export const CallContractResponse: MessageFns<CallContractResponse> = {
  encode(message: CallContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executionOutput.length !== 0) {
      writer.uint32(10).bytes(message.executionOutput);
    }
    for (const v of message.stateChanges) {
      KeyValuePair.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.deletions) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executionOutput = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stateChanges.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deletions.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResponse {
    return {
      executionOutput: isSet(object.executionOutput)
        ? bytesFromBase64(object.executionOutput)
        : isSet(object.execution_output)
        ? bytesFromBase64(object.execution_output)
        : new Uint8Array(0),
      stateChanges: globalThis.Array.isArray(object?.stateChanges)
        ? object.stateChanges.map((e: any) => KeyValuePair.fromJSON(e))
        : globalThis.Array.isArray(object?.state_changes)
        ? object.state_changes.map((e: any) => KeyValuePair.fromJSON(e))
        : [],
      deletions: globalThis.Array.isArray(object?.deletions)
        ? object.deletions.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: CallContractResponse): unknown {
    const obj: any = {};
    if (message.executionOutput.length !== 0) {
      obj.executionOutput = base64FromBytes(message.executionOutput);
    }
    if (message.stateChanges?.length) {
      obj.stateChanges = message.stateChanges.map((e) => KeyValuePair.toJSON(e));
    }
    if (message.deletions?.length) {
      obj.deletions = message.deletions.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResponse>, I>>(base?: I): CallContractResponse {
    return CallContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResponse>, I>>(object: I): CallContractResponse {
    const message = createBaseCallContractResponse();
    message.executionOutput = object.executionOutput ?? new Uint8Array(0);
    message.stateChanges = object.stateChanges?.map((e) => KeyValuePair.fromPartial(e)) || [];
    message.deletions = object.deletions?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryContractRequest(): QueryContractRequest {
  return { address: new Uint8Array(0), inputData: new Uint8Array(0), contextBytes: new Uint8Array(0) };
}

export const QueryContractRequest: MessageFns<QueryContractRequest> = {
  encode(message: QueryContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.inputData.length !== 0) {
      writer.uint32(18).bytes(message.inputData);
    }
    if (message.contextBytes.length !== 0) {
      writer.uint32(26).bytes(message.contextBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputData = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contextBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryContractRequest {
    return {
      address: isSet(object.address) ? bytesFromBase64(object.address) : new Uint8Array(0),
      inputData: isSet(object.inputData)
        ? bytesFromBase64(object.inputData)
        : isSet(object.input_data)
        ? bytesFromBase64(object.input_data)
        : new Uint8Array(0),
      contextBytes: isSet(object.contextBytes)
        ? bytesFromBase64(object.contextBytes)
        : isSet(object.context_bytes)
        ? bytesFromBase64(object.context_bytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryContractRequest): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.inputData.length !== 0) {
      obj.inputData = base64FromBytes(message.inputData);
    }
    if (message.contextBytes.length !== 0) {
      obj.contextBytes = base64FromBytes(message.contextBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryContractRequest>, I>>(base?: I): QueryContractRequest {
    return QueryContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryContractRequest>, I>>(object: I): QueryContractRequest {
    const message = createBaseQueryContractRequest();
    message.address = object.address ?? new Uint8Array(0);
    message.inputData = object.inputData ?? new Uint8Array(0);
    message.contextBytes = object.contextBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryContractResponse(): QueryContractResponse {
  return { executionOutput: new Uint8Array(0) };
}

export const QueryContractResponse: MessageFns<QueryContractResponse> = {
  encode(message: QueryContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executionOutput.length !== 0) {
      writer.uint32(10).bytes(message.executionOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executionOutput = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryContractResponse {
    return {
      executionOutput: isSet(object.executionOutput)
        ? bytesFromBase64(object.executionOutput)
        : isSet(object.execution_output)
        ? bytesFromBase64(object.execution_output)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryContractResponse): unknown {
    const obj: any = {};
    if (message.executionOutput.length !== 0) {
      obj.executionOutput = base64FromBytes(message.executionOutput);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryContractResponse>, I>>(base?: I): QueryContractResponse {
    return QueryContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryContractResponse>, I>>(object: I): QueryContractResponse {
    const message = createBaseQueryContractResponse();
    message.executionOutput = object.executionOutput ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetStakedValidatorsRequest(): GetStakedValidatorsRequest {
  return {};
}

export const GetStakedValidatorsRequest: MessageFns<GetStakedValidatorsRequest> = {
  encode(_: GetStakedValidatorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakedValidatorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakedValidatorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStakedValidatorsRequest {
    return {};
  },

  toJSON(_: GetStakedValidatorsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStakedValidatorsRequest>, I>>(base?: I): GetStakedValidatorsRequest {
    return GetStakedValidatorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStakedValidatorsRequest>, I>>(_: I): GetStakedValidatorsRequest {
    const message = createBaseGetStakedValidatorsRequest();
    return message;
  },
};

function createBaseGetStakedValidatorsResponse(): GetStakedValidatorsResponse {
  return { validators: {} };
}

export const GetStakedValidatorsResponse: MessageFns<GetStakedValidatorsResponse> = {
  encode(message: GetStakedValidatorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.validators).forEach(([key, value]: [string, number]) => {
      GetStakedValidatorsResponse_ValidatorsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakedValidatorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakedValidatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetStakedValidatorsResponse_ValidatorsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.validators[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakedValidatorsResponse {
    return {
      validators: isObject(object.validators)
        ? (globalThis.Object.entries(object.validators) as [string, any][]).reduce(
          (acc: { [key: string]: number }, [key, value]: [string, any]) => {
            acc[key] = globalThis.Number(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetStakedValidatorsResponse): unknown {
    const obj: any = {};
    if (message.validators) {
      const entries = globalThis.Object.entries(message.validators) as [string, number][];
      if (entries.length > 0) {
        obj.validators = {};
        entries.forEach(([k, v]) => {
          obj.validators[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStakedValidatorsResponse>, I>>(base?: I): GetStakedValidatorsResponse {
    return GetStakedValidatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStakedValidatorsResponse>, I>>(object: I): GetStakedValidatorsResponse {
    const message = createBaseGetStakedValidatorsResponse();
    message.validators = (globalThis.Object.entries(object.validators ?? {}) as [string, number][]).reduce(
      (acc: { [key: string]: number }, [key, value]: [string, number]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetStakedValidatorsResponse_ValidatorsEntry(): GetStakedValidatorsResponse_ValidatorsEntry {
  return { key: "", value: 0 };
}

export const GetStakedValidatorsResponse_ValidatorsEntry: MessageFns<GetStakedValidatorsResponse_ValidatorsEntry> = {
  encode(
    message: GetStakedValidatorsResponse_ValidatorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakedValidatorsResponse_ValidatorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakedValidatorsResponse_ValidatorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakedValidatorsResponse_ValidatorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GetStakedValidatorsResponse_ValidatorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStakedValidatorsResponse_ValidatorsEntry>, I>>(
    base?: I,
  ): GetStakedValidatorsResponse_ValidatorsEntry {
    return GetStakedValidatorsResponse_ValidatorsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStakedValidatorsResponse_ValidatorsEntry>, I>>(
    object: I,
  ): GetStakedValidatorsResponse_ValidatorsEntry {
    const message = createBaseGetStakedValidatorsResponse_ValidatorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGetNextStakedValidatorsRequest(): GetNextStakedValidatorsRequest {
  return {};
}

export const GetNextStakedValidatorsRequest: MessageFns<GetNextStakedValidatorsRequest> = {
  encode(_: GetNextStakedValidatorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextStakedValidatorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextStakedValidatorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNextStakedValidatorsRequest {
    return {};
  },

  toJSON(_: GetNextStakedValidatorsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNextStakedValidatorsRequest>, I>>(base?: I): GetNextStakedValidatorsRequest {
    return GetNextStakedValidatorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNextStakedValidatorsRequest>, I>>(_: I): GetNextStakedValidatorsRequest {
    const message = createBaseGetNextStakedValidatorsRequest();
    return message;
  },
};

function createBaseGetNextStakedValidatorsResponse(): GetNextStakedValidatorsResponse {
  return { validators: {} };
}

export const GetNextStakedValidatorsResponse: MessageFns<GetNextStakedValidatorsResponse> = {
  encode(message: GetNextStakedValidatorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.validators).forEach(([key, value]: [string, number]) => {
      GetNextStakedValidatorsResponse_ValidatorsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextStakedValidatorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextStakedValidatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetNextStakedValidatorsResponse_ValidatorsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.validators[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNextStakedValidatorsResponse {
    return {
      validators: isObject(object.validators)
        ? (globalThis.Object.entries(object.validators) as [string, any][]).reduce(
          (acc: { [key: string]: number }, [key, value]: [string, any]) => {
            acc[key] = globalThis.Number(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetNextStakedValidatorsResponse): unknown {
    const obj: any = {};
    if (message.validators) {
      const entries = globalThis.Object.entries(message.validators) as [string, number][];
      if (entries.length > 0) {
        obj.validators = {};
        entries.forEach(([k, v]) => {
          obj.validators[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNextStakedValidatorsResponse>, I>>(base?: I): GetNextStakedValidatorsResponse {
    return GetNextStakedValidatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNextStakedValidatorsResponse>, I>>(
    object: I,
  ): GetNextStakedValidatorsResponse {
    const message = createBaseGetNextStakedValidatorsResponse();
    message.validators = (globalThis.Object.entries(object.validators ?? {}) as [string, number][]).reduce(
      (acc: { [key: string]: number }, [key, value]: [string, number]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetNextStakedValidatorsResponse_ValidatorsEntry(): GetNextStakedValidatorsResponse_ValidatorsEntry {
  return { key: "", value: 0 };
}

export const GetNextStakedValidatorsResponse_ValidatorsEntry: MessageFns<
  GetNextStakedValidatorsResponse_ValidatorsEntry
> = {
  encode(
    message: GetNextStakedValidatorsResponse_ValidatorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextStakedValidatorsResponse_ValidatorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextStakedValidatorsResponse_ValidatorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNextStakedValidatorsResponse_ValidatorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GetNextStakedValidatorsResponse_ValidatorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNextStakedValidatorsResponse_ValidatorsEntry>, I>>(
    base?: I,
  ): GetNextStakedValidatorsResponse_ValidatorsEntry {
    return GetNextStakedValidatorsResponse_ValidatorsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNextStakedValidatorsResponse_ValidatorsEntry>, I>>(
    object: I,
  ): GetNextStakedValidatorsResponse_ValidatorsEntry {
    const message = createBaseGetNextStakedValidatorsResponse_ValidatorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGetExpectedModelHashResponse(): GetExpectedModelHashResponse {
  return { hash: new Uint8Array(0) };
}

export const GetExpectedModelHashResponse: MessageFns<GetExpectedModelHashResponse> = {
  encode(message: GetExpectedModelHashResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExpectedModelHashResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExpectedModelHashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExpectedModelHashResponse {
    return { hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0) };
  },

  toJSON(message: GetExpectedModelHashResponse): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExpectedModelHashResponse>, I>>(base?: I): GetExpectedModelHashResponse {
    return GetExpectedModelHashResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExpectedModelHashResponse>, I>>(object: I): GetExpectedModelHashResponse {
    const message = createBaseGetExpectedModelHashResponse();
    message.hash = object.hash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCheckAndTallyProposalsRequest(): CheckAndTallyProposalsRequest {
  return { currentHeight: 0 };
}

export const CheckAndTallyProposalsRequest: MessageFns<CheckAndTallyProposalsRequest> = {
  encode(message: CheckAndTallyProposalsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentHeight !== 0) {
      writer.uint32(8).uint64(message.currentHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckAndTallyProposalsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckAndTallyProposalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentHeight = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckAndTallyProposalsRequest {
    return {
      currentHeight: isSet(object.currentHeight)
        ? globalThis.Number(object.currentHeight)
        : isSet(object.current_height)
        ? globalThis.Number(object.current_height)
        : 0,
    };
  },

  toJSON(message: CheckAndTallyProposalsRequest): unknown {
    const obj: any = {};
    if (message.currentHeight !== 0) {
      obj.currentHeight = Math.round(message.currentHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckAndTallyProposalsRequest>, I>>(base?: I): CheckAndTallyProposalsRequest {
    return CheckAndTallyProposalsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckAndTallyProposalsRequest>, I>>(
    object: I,
  ): CheckAndTallyProposalsRequest {
    const message = createBaseCheckAndTallyProposalsRequest();
    message.currentHeight = object.currentHeight ?? 0;
    return message;
  },
};

function createBaseCheckAndTallyProposalsResponse(): CheckAndTallyProposalsResponse {
  return { logs: [] };
}

export const CheckAndTallyProposalsResponse: MessageFns<CheckAndTallyProposalsResponse> = {
  encode(message: CheckAndTallyProposalsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckAndTallyProposalsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckAndTallyProposalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckAndTallyProposalsResponse {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: CheckAndTallyProposalsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckAndTallyProposalsResponse>, I>>(base?: I): CheckAndTallyProposalsResponse {
    return CheckAndTallyProposalsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckAndTallyProposalsResponse>, I>>(
    object: I,
  ): CheckAndTallyProposalsResponse {
    const message = createBaseCheckAndTallyProposalsResponse();
    message.logs = object.logs?.map((e) => e) || [];
    return message;
  },
};

function createBaseDebugPinHeightRequest(): DebugPinHeightRequest {
  return { height: 0 };
}

export const DebugPinHeightRequest: MessageFns<DebugPinHeightRequest> = {
  encode(message: DebugPinHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugPinHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugPinHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugPinHeightRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: DebugPinHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebugPinHeightRequest>, I>>(base?: I): DebugPinHeightRequest {
    return DebugPinHeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebugPinHeightRequest>, I>>(object: I): DebugPinHeightRequest {
    const message = createBaseDebugPinHeightRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseDebugUnpinHeightRequest(): DebugUnpinHeightRequest {
  return { height: 0 };
}

export const DebugUnpinHeightRequest: MessageFns<DebugUnpinHeightRequest> = {
  encode(message: DebugUnpinHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugUnpinHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugUnpinHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugUnpinHeightRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: DebugUnpinHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebugUnpinHeightRequest>, I>>(base?: I): DebugUnpinHeightRequest {
    return DebugUnpinHeightRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebugUnpinHeightRequest>, I>>(object: I): DebugUnpinHeightRequest {
    const message = createBaseDebugUnpinHeightRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseDebugTriggerGcResponse(): DebugTriggerGcResponse {
  return { heightsPruned: 0, nodesDeleted: 0 };
}

export const DebugTriggerGcResponse: MessageFns<DebugTriggerGcResponse> = {
  encode(message: DebugTriggerGcResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heightsPruned !== 0) {
      writer.uint32(8).uint64(message.heightsPruned);
    }
    if (message.nodesDeleted !== 0) {
      writer.uint32(16).uint64(message.nodesDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugTriggerGcResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugTriggerGcResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.heightsPruned = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodesDeleted = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugTriggerGcResponse {
    return {
      heightsPruned: isSet(object.heightsPruned)
        ? globalThis.Number(object.heightsPruned)
        : isSet(object.heights_pruned)
        ? globalThis.Number(object.heights_pruned)
        : 0,
      nodesDeleted: isSet(object.nodesDeleted)
        ? globalThis.Number(object.nodesDeleted)
        : isSet(object.nodes_deleted)
        ? globalThis.Number(object.nodes_deleted)
        : 0,
    };
  },

  toJSON(message: DebugTriggerGcResponse): unknown {
    const obj: any = {};
    if (message.heightsPruned !== 0) {
      obj.heightsPruned = Math.round(message.heightsPruned);
    }
    if (message.nodesDeleted !== 0) {
      obj.nodesDeleted = Math.round(message.nodesDeleted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebugTriggerGcResponse>, I>>(base?: I): DebugTriggerGcResponse {
    return DebugTriggerGcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebugTriggerGcResponse>, I>>(object: I): DebugTriggerGcResponse {
    const message = createBaseDebugTriggerGcResponse();
    message.heightsPruned = object.heightsPruned ?? 0;
    message.nodesDeleted = object.nodesDeleted ?? 0;
    return message;
  },
};

/**
 * Services for blockchain lifecycle management (Consensus -> Execution)
 * Minimised for Guardian-driven consensus.
 */
export type ChainControlService = typeof ChainControlService;
export const ChainControlService = {
  /** Processes a block. Supports Hybrid Data Plane (Inline vs Shared Memory). */
  processBlock: {
    path: "/ioi.blockchain.v1.ChainControl/ProcessBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessBlockRequest): Buffer => Buffer.from(ProcessBlockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessBlockRequest => ProcessBlockRequest.decode(value),
    responseSerialize: (value: ProcessBlockResponse): Buffer =>
      Buffer.from(ProcessBlockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessBlockResponse => ProcessBlockResponse.decode(value),
  },
  /** Fetches a range of blocks for sync. Supports Hybrid Data Plane. */
  getBlocksRange: {
    path: "/ioi.blockchain.v1.ChainControl/GetBlocksRange",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBlocksRangeRequest): Buffer =>
      Buffer.from(GetBlocksRangeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBlocksRangeRequest => GetBlocksRangeRequest.decode(value),
    responseSerialize: (value: GetBlocksRangeResponse): Buffer =>
      Buffer.from(GetBlocksRangeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBlocksRangeResponse => GetBlocksRangeResponse.decode(value),
  },
  /** Updates the header of a stored block (used for adding signatures/oracle data). */
  updateBlockHeader: {
    path: "/ioi.blockchain.v1.ChainControl/UpdateBlockHeader",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBlockHeaderRequest): Buffer =>
      Buffer.from(UpdateBlockHeaderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateBlockHeaderRequest => UpdateBlockHeaderRequest.decode(value),
    responseSerialize: (value: UpdateBlockHeaderResponse): Buffer =>
      Buffer.from(UpdateBlockHeaderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateBlockHeaderResponse => UpdateBlockHeaderResponse.decode(value),
  },
  /** Checks if the chain genesis is ready. */
  getGenesisStatus: {
    path: "/ioi.blockchain.v1.ChainControl/GetGenesisStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGenesisStatusRequest): Buffer =>
      Buffer.from(GetGenesisStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGenesisStatusRequest => GetGenesisStatusRequest.decode(value),
    responseSerialize: (value: GetGenesisStatusResponse): Buffer =>
      Buffer.from(GetGenesisStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetGenesisStatusResponse => GetGenesisStatusResponse.decode(value),
  },
  /** Gets the current chain status (height, timestamp, etc.). */
  getStatus: {
    path: "/ioi.blockchain.v1.ChainControl/GetStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatusRequest): Buffer => Buffer.from(GetStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatusRequest => GetStatusRequest.decode(value),
    responseSerialize: (value: GetStatusResponse): Buffer => Buffer.from(GetStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetStatusResponse => GetStatusResponse.decode(value),
  },
} as const;

export interface ChainControlServer extends UntypedServiceImplementation {
  /** Processes a block. Supports Hybrid Data Plane (Inline vs Shared Memory). */
  processBlock: handleUnaryCall<ProcessBlockRequest, ProcessBlockResponse>;
  /** Fetches a range of blocks for sync. Supports Hybrid Data Plane. */
  getBlocksRange: handleUnaryCall<GetBlocksRangeRequest, GetBlocksRangeResponse>;
  /** Updates the header of a stored block (used for adding signatures/oracle data). */
  updateBlockHeader: handleUnaryCall<UpdateBlockHeaderRequest, UpdateBlockHeaderResponse>;
  /** Checks if the chain genesis is ready. */
  getGenesisStatus: handleUnaryCall<GetGenesisStatusRequest, GetGenesisStatusResponse>;
  /** Gets the current chain status (height, timestamp, etc.). */
  getStatus: handleUnaryCall<GetStatusRequest, GetStatusResponse>;
}

export interface ChainControlClient extends Client {
  /** Processes a block. Supports Hybrid Data Plane (Inline vs Shared Memory). */
  processBlock(
    request: ProcessBlockRequest,
    callback: (error: ServiceError | null, response: ProcessBlockResponse) => void,
  ): ClientUnaryCall;
  processBlock(
    request: ProcessBlockRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProcessBlockResponse) => void,
  ): ClientUnaryCall;
  processBlock(
    request: ProcessBlockRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProcessBlockResponse) => void,
  ): ClientUnaryCall;
  /** Fetches a range of blocks for sync. Supports Hybrid Data Plane. */
  getBlocksRange(
    request: GetBlocksRangeRequest,
    callback: (error: ServiceError | null, response: GetBlocksRangeResponse) => void,
  ): ClientUnaryCall;
  getBlocksRange(
    request: GetBlocksRangeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBlocksRangeResponse) => void,
  ): ClientUnaryCall;
  getBlocksRange(
    request: GetBlocksRangeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBlocksRangeResponse) => void,
  ): ClientUnaryCall;
  /** Updates the header of a stored block (used for adding signatures/oracle data). */
  updateBlockHeader(
    request: UpdateBlockHeaderRequest,
    callback: (error: ServiceError | null, response: UpdateBlockHeaderResponse) => void,
  ): ClientUnaryCall;
  updateBlockHeader(
    request: UpdateBlockHeaderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateBlockHeaderResponse) => void,
  ): ClientUnaryCall;
  updateBlockHeader(
    request: UpdateBlockHeaderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateBlockHeaderResponse) => void,
  ): ClientUnaryCall;
  /** Checks if the chain genesis is ready. */
  getGenesisStatus(
    request: GetGenesisStatusRequest,
    callback: (error: ServiceError | null, response: GetGenesisStatusResponse) => void,
  ): ClientUnaryCall;
  getGenesisStatus(
    request: GetGenesisStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetGenesisStatusResponse) => void,
  ): ClientUnaryCall;
  getGenesisStatus(
    request: GetGenesisStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetGenesisStatusResponse) => void,
  ): ClientUnaryCall;
  /** Gets the current chain status (height, timestamp, etc.). */
  getStatus(
    request: GetStatusRequest,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  getStatus(
    request: GetStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
  getStatus(
    request: GetStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStatusResponse) => void,
  ): ClientUnaryCall;
}

export const ChainControlClient = makeGenericClientConstructor(
  ChainControlService,
  "ioi.blockchain.v1.ChainControl",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ChainControlClient;
  service: typeof ChainControlService;
  serviceName: string;
};

/** Services for state queries and transaction pre-checks */
export type StateQueryService = typeof StateQueryService;
export const StateQueryService = {
  /** Performs pre-execution checks on transactions against a specific state anchor. */
  checkTransactions: {
    path: "/ioi.blockchain.v1.StateQuery/CheckTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckTransactionsRequest): Buffer =>
      Buffer.from(CheckTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckTransactionsRequest => CheckTransactionsRequest.decode(value),
    responseSerialize: (value: CheckTransactionsResponse): Buffer =>
      Buffer.from(CheckTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckTransactionsResponse => CheckTransactionsResponse.decode(value),
  },
  /** Queries the state at a specific root hash, returning a Merkle proof. */
  queryStateAt: {
    path: "/ioi.blockchain.v1.StateQuery/QueryStateAt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryStateAtRequest): Buffer => Buffer.from(QueryStateAtRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryStateAtRequest => QueryStateAtRequest.decode(value),
    responseSerialize: (value: QueryStateAtResponse): Buffer =>
      Buffer.from(QueryStateAtResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryStateAtResponse => QueryStateAtResponse.decode(value),
  },
  /** Queries the raw state value (without proof). */
  queryRawState: {
    path: "/ioi.blockchain.v1.StateQuery/QueryRawState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRawStateRequest): Buffer => Buffer.from(QueryRawStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryRawStateRequest => QueryRawStateRequest.decode(value),
    responseSerialize: (value: QueryRawStateResponse): Buffer =>
      Buffer.from(QueryRawStateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryRawStateResponse => QueryRawStateResponse.decode(value),
  },
  /** Scans keys with a given prefix. */
  prefixScan: {
    path: "/ioi.blockchain.v1.StateQuery/PrefixScan",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PrefixScanRequest): Buffer => Buffer.from(PrefixScanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PrefixScanRequest => PrefixScanRequest.decode(value),
    responseSerialize: (value: PrefixScanResponse): Buffer => Buffer.from(PrefixScanResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PrefixScanResponse => PrefixScanResponse.decode(value),
  },
} as const;

export interface StateQueryServer extends UntypedServiceImplementation {
  /** Performs pre-execution checks on transactions against a specific state anchor. */
  checkTransactions: handleUnaryCall<CheckTransactionsRequest, CheckTransactionsResponse>;
  /** Queries the state at a specific root hash, returning a Merkle proof. */
  queryStateAt: handleUnaryCall<QueryStateAtRequest, QueryStateAtResponse>;
  /** Queries the raw state value (without proof). */
  queryRawState: handleUnaryCall<QueryRawStateRequest, QueryRawStateResponse>;
  /** Scans keys with a given prefix. */
  prefixScan: handleUnaryCall<PrefixScanRequest, PrefixScanResponse>;
}

export interface StateQueryClient extends Client {
  /** Performs pre-execution checks on transactions against a specific state anchor. */
  checkTransactions(
    request: CheckTransactionsRequest,
    callback: (error: ServiceError | null, response: CheckTransactionsResponse) => void,
  ): ClientUnaryCall;
  checkTransactions(
    request: CheckTransactionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckTransactionsResponse) => void,
  ): ClientUnaryCall;
  checkTransactions(
    request: CheckTransactionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckTransactionsResponse) => void,
  ): ClientUnaryCall;
  /** Queries the state at a specific root hash, returning a Merkle proof. */
  queryStateAt(
    request: QueryStateAtRequest,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  queryStateAt(
    request: QueryStateAtRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  queryStateAt(
    request: QueryStateAtRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryStateAtResponse) => void,
  ): ClientUnaryCall;
  /** Queries the raw state value (without proof). */
  queryRawState(
    request: QueryRawStateRequest,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  queryRawState(
    request: QueryRawStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  queryRawState(
    request: QueryRawStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRawStateResponse) => void,
  ): ClientUnaryCall;
  /** Scans keys with a given prefix. */
  prefixScan(
    request: PrefixScanRequest,
    callback: (error: ServiceError | null, response: PrefixScanResponse) => void,
  ): ClientUnaryCall;
  prefixScan(
    request: PrefixScanRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PrefixScanResponse) => void,
  ): ClientUnaryCall;
  prefixScan(
    request: PrefixScanRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PrefixScanResponse) => void,
  ): ClientUnaryCall;
}

export const StateQueryClient = makeGenericClientConstructor(
  StateQueryService,
  "ioi.blockchain.v1.StateQuery",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): StateQueryClient;
  service: typeof StateQueryService;
  serviceName: string;
};

/** Services for Smart Contract interaction (VM) */
export type ContractControlService = typeof ContractControlService;
export const ContractControlService = {
  /** Deploys a new smart contract. */
  deployContract: {
    path: "/ioi.blockchain.v1.ContractControl/DeployContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeployContractRequest): Buffer =>
      Buffer.from(DeployContractRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeployContractRequest => DeployContractRequest.decode(value),
    responseSerialize: (value: DeployContractResponse): Buffer =>
      Buffer.from(DeployContractResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeployContractResponse => DeployContractResponse.decode(value),
  },
  /** Calls a smart contract (state transition). */
  callContract: {
    path: "/ioi.blockchain.v1.ContractControl/CallContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CallContractRequest): Buffer => Buffer.from(CallContractRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CallContractRequest => CallContractRequest.decode(value),
    responseSerialize: (value: CallContractResponse): Buffer =>
      Buffer.from(CallContractResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CallContractResponse => CallContractResponse.decode(value),
  },
  /** Queries a smart contract (read-only). */
  queryContract: {
    path: "/ioi.blockchain.v1.ContractControl/QueryContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryContractRequest): Buffer => Buffer.from(QueryContractRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QueryContractRequest => QueryContractRequest.decode(value),
    responseSerialize: (value: QueryContractResponse): Buffer =>
      Buffer.from(QueryContractResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QueryContractResponse => QueryContractResponse.decode(value),
  },
} as const;

export interface ContractControlServer extends UntypedServiceImplementation {
  /** Deploys a new smart contract. */
  deployContract: handleUnaryCall<DeployContractRequest, DeployContractResponse>;
  /** Calls a smart contract (state transition). */
  callContract: handleUnaryCall<CallContractRequest, CallContractResponse>;
  /** Queries a smart contract (read-only). */
  queryContract: handleUnaryCall<QueryContractRequest, QueryContractResponse>;
}

export interface ContractControlClient extends Client {
  /** Deploys a new smart contract. */
  deployContract(
    request: DeployContractRequest,
    callback: (error: ServiceError | null, response: DeployContractResponse) => void,
  ): ClientUnaryCall;
  deployContract(
    request: DeployContractRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeployContractResponse) => void,
  ): ClientUnaryCall;
  deployContract(
    request: DeployContractRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeployContractResponse) => void,
  ): ClientUnaryCall;
  /** Calls a smart contract (state transition). */
  callContract(
    request: CallContractRequest,
    callback: (error: ServiceError | null, response: CallContractResponse) => void,
  ): ClientUnaryCall;
  callContract(
    request: CallContractRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CallContractResponse) => void,
  ): ClientUnaryCall;
  callContract(
    request: CallContractRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CallContractResponse) => void,
  ): ClientUnaryCall;
  /** Queries a smart contract (read-only). */
  queryContract(
    request: QueryContractRequest,
    callback: (error: ServiceError | null, response: QueryContractResponse) => void,
  ): ClientUnaryCall;
  queryContract(
    request: QueryContractRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryContractResponse) => void,
  ): ClientUnaryCall;
  queryContract(
    request: QueryContractRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryContractResponse) => void,
  ): ClientUnaryCall;
}

export const ContractControlClient = makeGenericClientConstructor(
  ContractControlService,
  "ioi.blockchain.v1.ContractControl",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ContractControlClient;
  service: typeof ContractControlService;
  serviceName: string;
};

/** Services for Staking and Validator Set management */
export type StakingControlService = typeof StakingControlService;
export const StakingControlService = {
  /** Gets the current set of staked validators and their weights. */
  getStakedValidators: {
    path: "/ioi.blockchain.v1.StakingControl/GetStakedValidators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStakedValidatorsRequest): Buffer =>
      Buffer.from(GetStakedValidatorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStakedValidatorsRequest => GetStakedValidatorsRequest.decode(value),
    responseSerialize: (value: GetStakedValidatorsResponse): Buffer =>
      Buffer.from(GetStakedValidatorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetStakedValidatorsResponse => GetStakedValidatorsResponse.decode(value),
  },
  /** Gets the pending next set of staked validators. */
  getNextStakedValidators: {
    path: "/ioi.blockchain.v1.StakingControl/GetNextStakedValidators",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNextStakedValidatorsRequest): Buffer =>
      Buffer.from(GetNextStakedValidatorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNextStakedValidatorsRequest => GetNextStakedValidatorsRequest.decode(value),
    responseSerialize: (value: GetNextStakedValidatorsResponse): Buffer =>
      Buffer.from(GetNextStakedValidatorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetNextStakedValidatorsResponse =>
      GetNextStakedValidatorsResponse.decode(value),
  },
} as const;

export interface StakingControlServer extends UntypedServiceImplementation {
  /** Gets the current set of staked validators and their weights. */
  getStakedValidators: handleUnaryCall<GetStakedValidatorsRequest, GetStakedValidatorsResponse>;
  /** Gets the pending next set of staked validators. */
  getNextStakedValidators: handleUnaryCall<GetNextStakedValidatorsRequest, GetNextStakedValidatorsResponse>;
}

export interface StakingControlClient extends Client {
  /** Gets the current set of staked validators and their weights. */
  getStakedValidators(
    request: GetStakedValidatorsRequest,
    callback: (error: ServiceError | null, response: GetStakedValidatorsResponse) => void,
  ): ClientUnaryCall;
  getStakedValidators(
    request: GetStakedValidatorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStakedValidatorsResponse) => void,
  ): ClientUnaryCall;
  getStakedValidators(
    request: GetStakedValidatorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStakedValidatorsResponse) => void,
  ): ClientUnaryCall;
  /** Gets the pending next set of staked validators. */
  getNextStakedValidators(
    request: GetNextStakedValidatorsRequest,
    callback: (error: ServiceError | null, response: GetNextStakedValidatorsResponse) => void,
  ): ClientUnaryCall;
  getNextStakedValidators(
    request: GetNextStakedValidatorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNextStakedValidatorsResponse) => void,
  ): ClientUnaryCall;
  getNextStakedValidators(
    request: GetNextStakedValidatorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNextStakedValidatorsResponse) => void,
  ): ClientUnaryCall;
}

export const StakingControlClient = makeGenericClientConstructor(
  StakingControlService,
  "ioi.blockchain.v1.StakingControl",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): StakingControlClient;
  service: typeof StakingControlService;
  serviceName: string;
};

/** Services for System operations and Debugging */
export type SystemControlService = typeof SystemControlService;
export const SystemControlService = {
  /** Gets the expected hash of the semantic model (AI/Agentic). */
  getExpectedModelHash: {
    path: "/ioi.blockchain.v1.SystemControl/GetExpectedModelHash",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: GetExpectedModelHashResponse): Buffer =>
      Buffer.from(GetExpectedModelHashResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetExpectedModelHashResponse => GetExpectedModelHashResponse.decode(value),
  },
  /** Triggers proposal tallying (legacy governance hook). */
  checkAndTallyProposals: {
    path: "/ioi.blockchain.v1.SystemControl/CheckAndTallyProposals",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckAndTallyProposalsRequest): Buffer =>
      Buffer.from(CheckAndTallyProposalsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckAndTallyProposalsRequest => CheckAndTallyProposalsRequest.decode(value),
    responseSerialize: (value: CheckAndTallyProposalsResponse): Buffer =>
      Buffer.from(CheckAndTallyProposalsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckAndTallyProposalsResponse =>
      CheckAndTallyProposalsResponse.decode(value),
  },
  /** Pins a state version to prevent pruning. */
  debugPinHeight: {
    path: "/ioi.blockchain.v1.SystemControl/DebugPinHeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DebugPinHeightRequest): Buffer =>
      Buffer.from(DebugPinHeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DebugPinHeightRequest => DebugPinHeightRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Unpins a state version. */
  debugUnpinHeight: {
    path: "/ioi.blockchain.v1.SystemControl/DebugUnpinHeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DebugUnpinHeightRequest): Buffer =>
      Buffer.from(DebugUnpinHeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DebugUnpinHeightRequest => DebugUnpinHeightRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Triggers a manual Garbage Collection pass. */
  debugTriggerGc: {
    path: "/ioi.blockchain.v1.SystemControl/DebugTriggerGc",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: DebugTriggerGcResponse): Buffer =>
      Buffer.from(DebugTriggerGcResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DebugTriggerGcResponse => DebugTriggerGcResponse.decode(value),
  },
} as const;

export interface SystemControlServer extends UntypedServiceImplementation {
  /** Gets the expected hash of the semantic model (AI/Agentic). */
  getExpectedModelHash: handleUnaryCall<Empty, GetExpectedModelHashResponse>;
  /** Triggers proposal tallying (legacy governance hook). */
  checkAndTallyProposals: handleUnaryCall<CheckAndTallyProposalsRequest, CheckAndTallyProposalsResponse>;
  /** Pins a state version to prevent pruning. */
  debugPinHeight: handleUnaryCall<DebugPinHeightRequest, Empty>;
  /** Unpins a state version. */
  debugUnpinHeight: handleUnaryCall<DebugUnpinHeightRequest, Empty>;
  /** Triggers a manual Garbage Collection pass. */
  debugTriggerGc: handleUnaryCall<Empty, DebugTriggerGcResponse>;
}

export interface SystemControlClient extends Client {
  /** Gets the expected hash of the semantic model (AI/Agentic). */
  getExpectedModelHash(
    request: Empty,
    callback: (error: ServiceError | null, response: GetExpectedModelHashResponse) => void,
  ): ClientUnaryCall;
  getExpectedModelHash(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetExpectedModelHashResponse) => void,
  ): ClientUnaryCall;
  getExpectedModelHash(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetExpectedModelHashResponse) => void,
  ): ClientUnaryCall;
  /** Triggers proposal tallying (legacy governance hook). */
  checkAndTallyProposals(
    request: CheckAndTallyProposalsRequest,
    callback: (error: ServiceError | null, response: CheckAndTallyProposalsResponse) => void,
  ): ClientUnaryCall;
  checkAndTallyProposals(
    request: CheckAndTallyProposalsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckAndTallyProposalsResponse) => void,
  ): ClientUnaryCall;
  checkAndTallyProposals(
    request: CheckAndTallyProposalsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckAndTallyProposalsResponse) => void,
  ): ClientUnaryCall;
  /** Pins a state version to prevent pruning. */
  debugPinHeight(
    request: DebugPinHeightRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  debugPinHeight(
    request: DebugPinHeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  debugPinHeight(
    request: DebugPinHeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Unpins a state version. */
  debugUnpinHeight(
    request: DebugUnpinHeightRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  debugUnpinHeight(
    request: DebugUnpinHeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  debugUnpinHeight(
    request: DebugUnpinHeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Triggers a manual Garbage Collection pass. */
  debugTriggerGc(
    request: Empty,
    callback: (error: ServiceError | null, response: DebugTriggerGcResponse) => void,
  ): ClientUnaryCall;
  debugTriggerGc(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DebugTriggerGcResponse) => void,
  ): ClientUnaryCall;
  debugTriggerGc(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DebugTriggerGcResponse) => void,
  ): ClientUnaryCall;
}

export const SystemControlClient = makeGenericClientConstructor(
  SystemControlService,
  "ioi.blockchain.v1.SystemControl",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SystemControlClient;
  service: typeof SystemControlService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
