diff --git a/.gitignore b/.gitignore
index d8a1ea2..969c794 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,8 +5,9 @@ tools/
 Cargo.lock
 codebase_snapshot.md
 keypair.seed
-state1.json
-state2.json
+state_node1.json
+state_node2.json
 output.txt
 .git
 .gitignore
+output.txt
\ No newline at end of file
diff --git a/Cargo.lock b/Cargo.lock
index c64884c..c7d983b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -883,7 +883,9 @@ dependencies = [
  "futures",
  "libp2p",
  "log",
+ "rand",
  "serde",
+ "serde_bytes",
  "serde_json",
  "tokio",
  "toml",
@@ -1680,9 +1682,9 @@ dependencies = [
  "libp2p-metrics",
  "libp2p-noise",
  "libp2p-quic",
+ "libp2p-request-response",
  "libp2p-swarm",
  "libp2p-tcp",
- "libp2p-tls",
  "libp2p-upnp",
  "libp2p-yamux",
  "multiaddr",
@@ -1894,6 +1896,24 @@ dependencies = [
  "tokio",
 ]
 
+[[package]]
+name = "libp2p-request-response"
+version = "0.25.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d8e3b4d67870478db72bac87bfc260ee6641d0734e0e3e275798f089c3fecfd4"
+dependencies = [
+ "async-trait",
+ "futures",
+ "instant",
+ "libp2p-core",
+ "libp2p-identity",
+ "libp2p-swarm",
+ "log",
+ "rand",
+ "smallvec",
+ "void",
+]
+
 [[package]]
 name = "libp2p-swarm"
 version = "0.43.7"
@@ -1907,6 +1927,7 @@ dependencies = [
  "instant",
  "libp2p-core",
  "libp2p-identity",
+ "libp2p-swarm-derive",
  "log",
  "multistream-select",
  "once_cell",
@@ -1916,6 +1937,19 @@ dependencies = [
  "void",
 ]
 
+[[package]]
+name = "libp2p-swarm-derive"
+version = "0.33.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c4d5ec2a3df00c7836d7696c136274c9c59705bac69133253696a6c932cd1d74"
+dependencies = [
+ "heck 0.4.1",
+ "proc-macro-warning",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.104",
+]
+
 [[package]]
 name = "libp2p-tcp"
 version = "0.40.1"
@@ -2469,6 +2503,17 @@ dependencies = [
  "zerocopy",
 ]
 
+[[package]]
+name = "proc-macro-warning"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d1eaa7fa0aa1929ffdf7eeb6eac234dde6268914a14ad44d23521ab6a9b258e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.104",
+]
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.95"
@@ -2826,6 +2871,15 @@ dependencies = [
  "serde_derive",
 ]
 
+[[package]]
+name = "serde_bytes"
+version = "0.11.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8437fd221bde2d4ca316d61b90e337e9e702b3820b87d63caa9ba6c02bd06d96"
+dependencies = [
+ "serde",
+]
+
 [[package]]
 name = "serde_derive"
 version = "1.0.219"
diff --git a/Cargo.toml b/Cargo.toml
index f83628b..7e33721 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -21,13 +21,13 @@ members = [
 libp2p = { version = "0.52.4", features = [
     "tokio",
     "tcp",
-    "tls",
     "noise",
     "yamux",
     "gossipsub",
+    "request-response",
+    "macros",
 ] }
 
-
 # Async
 tokio = { version = "1", features = ["full"] }
 futures = "0.3"
@@ -39,6 +39,7 @@ serde_json = "1.0"
 toml = "0.8"
 bytes = "1"
 hex = "0.4"
+serde_bytes = "0.11"
 
 # Cryptography
 sha2 = "0.10"
diff --git a/codebase_snapshot.md b/codebase_snapshot.md
deleted file mode 100644
index 142dd82..0000000
--- a/codebase_snapshot.md
+++ /dev/null
@@ -1,14948 +0,0 @@
-# Codebase Snapshot: crates
-Created: Tue Jul 29 02:25:53 AM UTC 2025
-Target: /workspaces/depin-sdk/crates
-Line threshold for included files: 1500
-
-## Summary Statistics
-
-* Total files: 152
-* Total directories: 117
-
-### Directory: /workspaces/depin-sdk/crates
-
-#### Directory: chain
-
-##### Directory: chain/src
-
-###### Directory: chain/src/app
-
-####### File: chain/src/app/mod.rs
-####*Size: 12K, Lines: 225, Type: ASCII text*
-
-```rust
-// Path: crates/chain/src/app/mod.rs
-
-//! The private implementation for the `SovereignChain` trait.
-
-use crate::upgrade_manager::ModuleUpgradeManager;
-use async_trait::async_trait;
-use depin_sdk_core::app::{Block, BlockHeader, ChainError, ChainStatus, SovereignAppChain};
-use depin_sdk_core::chain::SovereignChain;
-use depin_sdk_core::commitment::CommitmentScheme;
-// REMOVED: Unused import `StateError`
-use depin_sdk_core::services::UpgradableService;
-// REMOVED: Unused import `StateTree`
-use depin_sdk_core::state::StateManager;
-use depin_sdk_core::transaction::TransactionModel;
-use depin_sdk_core::validator::WorkloadContainer;
-use depin_sdk_validator::traits::WorkloadLogic;
-use std::fmt::Debug;
-use std::sync::Arc;
-use std::time::{SystemTime, UNIX_EPOCH};
-
-// Define a well-known key for storing the chain status in the state tree.
-const STATUS_KEY: &[u8] = b"chain::status";
-
-/// A container struct that holds the chain's data (`SovereignAppChain`) and its
-/// associated logic managers (`ModuleUpgradeManager`).
-/// This struct implements the `SovereignChain` trait.
-#[derive(Debug)]
-pub struct ChainLogic<CS, TM: TransactionModel> {
-    app_chain: SovereignAppChain<CS, TM>,
-    #[allow(dead_code)]
-    service_manager: ModuleUpgradeManager,
-}
-
-impl<CS, TM> ChainLogic<CS, TM>
-where
-    CS: CommitmentScheme,
-    TM: TransactionModel<CommitmentScheme = CS>,
-{
-    /// The `new` constructor is an inherent method on the logic struct,
-    /// which allows the `SovereignChain` trait to be object-safe.
-    pub fn new(
-        commitment_scheme: CS,
-        transaction_model: TM,
-        chain_id: &str,
-        initial_services: Vec<Arc<dyn UpgradableService>>,
-    ) -> Self {
-        // This now creates a default/genesis status, which will be overwritten
-        // by load_or_initialize_status if state exists.
-        let status = ChainStatus {
-            height: 0,
-            latest_timestamp: SystemTime::now()
-                .duration_since(UNIX_EPOCH)
-                .unwrap()
-                .as_secs(),
-            total_transactions: 0,
-            is_running: false,
-        };
-
-        let mut service_manager = ModuleUpgradeManager::new();
-        for service in initial_services {
-            service_manager.register_service(service);
-        }
-
-        let app_chain = SovereignAppChain {
-            commitment_scheme,
-            transaction_model,
-            chain_id: chain_id.to_string(),
-            status,
-            recent_blocks: Vec::new(),
-            max_recent_blocks: 100,
-        };
-
-        Self {
-            app_chain,
-            service_manager,
-        }
-    }
-
-    /// [NEW METHOD] Loads chain status from the state manager, or initializes it if not found.
-    pub async fn load_or_initialize_status<ST>(
-        &mut self,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError>
-    where
-        ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
-    {
-        // FIX: Create a longer-lived binding for the Arc<Mutex> to solve the lifetime error.
-        let state_tree = workload.state_tree();
-        let mut state = state_tree.lock().await;
-
-        match state.get(STATUS_KEY) {
-            Ok(Some(status_bytes)) => {
-                let status: ChainStatus = serde_json::from_slice(&status_bytes)
-                    .map_err(|e| ChainError::Transaction(format!("Failed to deserialize status: {}", e)))?;
-                log::info!("Loaded chain status: height {}", status.height);
-                self.app_chain.status = status;
-            }
-            Ok(None) => {
-                log::info!("No existing chain status found. Initializing and saving genesis status.");
-                let status_bytes = serde_json::to_vec(&self.app_chain.status).unwrap();
-                state
-                    .insert(STATUS_KEY, &status_bytes)
-                    .map_err(|e| ChainError::Transaction(e.to_string()))?;
-            }
-            Err(e) => return Err(ChainError::Transaction(e.to_string())),
-        }
-        Ok(())
-    }
-}
-
-/// Implements the `dyn`-safe `SovereignChain` trait for the `ChainLogic` struct.
-#[async_trait]
-impl<CS, TM, ST> SovereignChain<CS, TM, ST> for ChainLogic<CS, TM>
-where
-    CS: CommitmentScheme + Send + Sync + 'static,
-    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static + Debug,
-    TM::Transaction: Clone + Send + Sync + Debug,
-    CS::Commitment: Send + Sync + Debug,
-    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
-{
-    fn status(&self) -> &ChainStatus {
-        &self.app_chain.status
-    }
-
-    fn transaction_model(&self) -> &TM {
-        &self.app_chain.transaction_model
-    }
-
-    /// Processes a transaction by delegating execution to the WorkloadContainer.
-    async fn process_transaction(
-        &mut self,
-        tx: &TM::Transaction,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError> {
-        workload
-            .execute_transaction(
-                tx,
-                <Self as SovereignChain<CS, TM, ST>>::transaction_model(self),
-            )
-            .await
-            .map_err(|e| ChainError::Transaction(e.to_string()))?;
-
-        self.app_chain.status.total_transactions += 1;
-        Ok(())
-    }
-
-    /// Processes a full block by iterating through its transactions and delegating
-    /// each one to the WorkloadContainer for execution.
-    async fn process_block(
-        &mut self,
-        mut block: Block<TM::Transaction>,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError> {
-        if block.header.height != self.app_chain.status.height + 1 {
-            return Err(ChainError::Block("Invalid block height".to_string()));
-        }
-
-        for tx in &block.transactions {
-            self.process_transaction(tx, workload).await?;
-        }
-
-        // After all transactions are processed, get the final state root from the workload container.
-        let state_root =
-            workload.state_tree().lock().await.root_commitment();
-        block.header.state_root = state_root.as_ref().to_vec();
-
-        self.app_chain.status.height = block.header.height;
-        self.app_chain.status.latest_timestamp = block.header.timestamp;
-        self.app_chain.recent_blocks.push(block);
-        if self.app_chain.recent_blocks.len() > self.app_chain.max_recent_blocks {
-            self.app_chain.recent_blocks.remove(0);
-        }
-
-        // [MODIFIED] Persist the updated status to the state tree.
-        let status_bytes = serde_json::to_vec(&self.app_chain.status)
-            .map_err(|e| ChainError::Transaction(format!("Failed to serialize status: {}", e)))?;
-        workload
-            .state_tree()
-            .lock()
-            .await
-            .insert(STATUS_KEY, &status_bytes)
-            .map_err(|e| ChainError::Transaction(e.to_string()))?;
-
-        Ok(())
-    }
-
-    /// Creates a new block template to be filled by a block producer.
-    fn create_block(
-        &self,
-        transactions: Vec<TM::Transaction>,
-        _workload: &WorkloadContainer<ST>,
-    ) -> Block<TM::Transaction> {
-        let prev_hash = self
-            .app_chain
-            .recent_blocks
-            .last()
-            .map_or(vec![0; 32], |b| b.header.state_root.clone());
-
-        // FIX: The state_root here is just a placeholder. The real root is calculated
-        // and overwritten in `process_block` after all transactions are executed.
-        // We remove the illegal `block_on` call and just use the previous hash as the initial value.
-        let state_root = prev_hash.clone();
-
-        let header = BlockHeader {
-            height: self.app_chain.status.height + 1,
-            prev_hash,
-            state_root,
-            transactions_root: vec![0; 32],
-            timestamp: SystemTime::now()
-                .duration_since(UNIX_EPOCH)
-                .unwrap()
-                .as_secs(),
-        };
-        Block {
-            header,
-            transactions,
-        }
-    }
-
-    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>> {
-        self.app_chain
-            .recent_blocks
-            .iter()
-            .find(|b| b.header.height == height)
-    }
-}```
-
-###### Directory: chain/src/bin
-
-####### File: chain/src/bin/mvsc.rs
-####*Size: 8.0K, Lines: 104, Type: C source, ASCII text*
-
-```rust
-// Path: crates/chain/src/bin/mvsc.rs
-
-//! # Minimum Viable Single-Node Chain (MVSC)
-//!
-//! This binary acts as the composition root for the validator node. It initializes
-//! all core components (chain logic, state, containers) and wires them together.
-
-use anyhow::anyhow;
-use clap::Parser;
-use depin_sdk_chain::ChainLogic;
-use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-// FIX: Import the Container trait to bring start() and stop() methods into scope.
-use depin_sdk_core::app::ChainError;
-use depin_sdk_core::Container;
-use depin_sdk_core::config::WorkloadConfig;
-use depin_sdk_core::validator::WorkloadContainer;
-use depin_sdk_state_trees::file::FileStateTree;
-use depin_sdk_transaction_models::utxo::UTXOModel;
-// FIXME: The following components must be made public in the `depin-sdk-validator` crate
-// for this binary to compile. This requires editing `crates/validator/src/common/mod.rs`
-// and `crates/validator/src/standard/mod.rs`.
-use depin_sdk_validator::common::GuardianContainer;
-use depin_sdk_validator::standard::OrchestrationContainer;
-use std::path::PathBuf;
-use std::sync::Arc;
-use tokio::sync::Mutex;
-
-#[derive(Parser, Debug)]
-#[clap(name = "mvsc", about = "A minimum viable sovereign chain node.")]
-struct Opts {
-    #[clap(long, default_value = "state.json")]
-    state_file: String,
-    #[clap(long, default_value = "./config")]
-    config_dir: String,
-}
-
-#[tokio::main]
-async fn main() -> anyhow::Result<()> {
-    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-    let opts = Opts::parse();
-    log::info!("Initializing DePIN SDK Node...");
-
-    // --- 1. Initialize Independent Components ---
-    let commitment_scheme = HashCommitmentScheme::new();
-    let transaction_model = UTXOModel::new(commitment_scheme.clone());
-    let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
-    let workload_config = WorkloadConfig { enabled_vms: vec!["WASM".to_string()] };
-
-    // --- 2. Build the Validator Containers ---
-    let workload_container = Arc::new(WorkloadContainer::new(workload_config, state_tree));
-
-    // FIX: Correctly construct PathBuf from String and borrow it.
-    let config_path = PathBuf::from(&opts.config_dir);
-    let orchestration_container = Arc::new(
-        OrchestrationContainer::<
-            HashCommitmentScheme,
-            UTXOModel<HashCommitmentScheme>,
-            FileStateTree<HashCommitmentScheme>,
-        >::new(&config_path.join("orchestration.toml"))
-        .await?,
-    );
-    let guardian_container = GuardianContainer::new(
-        &config_path.join("guardian.toml"),
-    )?;
-
-    // --- 3. Create and Initialize the SovereignChain Logic ---
-    // FIX: Move `transaction_model` instead of cloning it, as it's no longer needed here.
-    let mut chain_logic = ChainLogic::new(
-        commitment_scheme.clone(),
-        transaction_model,
-        "mvsc-chain-1",
-        vec![],
-    );
-    // [MODIFIED] Load status from state or initialize it.
-    chain_logic
-        .load_or_initialize_status(&workload_container)
-        .await
-        .map_err(|e| anyhow!("Failed to load or initialize chain status: {:?}", e))?;
-    let chain_ref: Arc<Mutex<ChainLogic<HashCommitmentScheme, UTXOModel<HashCommitmentScheme>>>> = Arc::new(Mutex::new(chain_logic));
-
-    // --- 4. Wire Up the Components (Inversion of Control) ---
-    orchestration_container.set_chain_and_workload_ref(
-        chain_ref.clone(),
-        workload_container.clone(),
-    );
-
-    // --- 5. Start the Validator Services ---
-    // FIX: Add .await to all async start/stop calls.
-    guardian_container.start().await.map_err(|e| anyhow!(e))?;
-    orchestration_container.start().await.map_err(|e| anyhow!(e))?;
-    workload_container.start().await.map_err(|e| anyhow!(e))?;
-
-    log::info!("Node successfully started. Running indefinitely...");
-
-    // 6. Keep the main thread alive.
-    tokio::signal::ctrl_c().await?;
-
-    log::info!("Shutdown signal received. Stopping node...");
-    orchestration_container.stop().await.map_err(|e| anyhow!(e))?;
-    workload_container.stop().await.map_err(|e| anyhow!(e))?;
-    guardian_container.stop().await.map_err(|e| anyhow!(e))?;
-    log::info!("Node stopped gracefully.");
-
-    Ok(())
-}```
-
-###### Directory: chain/src/traits
-
-####### File: chain/src/traits/mod.rs
-####*Size: 4.0K, Lines: 56, Type: ASCII text*
-
-```rust
-// Path: crates/chain/src/traits.rs
-
-//! This module defines the public traits that describe the core logic of a sovereign chain.
-
-use depin_sdk_core::app::{Block, ChainError, ChainStatus};
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::state::{StateManager, StateTree};
-use depin_sdk_core::transaction::TransactionModel;
-use depin_sdk_core::validator::WorkloadContainer;
-
-/// A trait that defines the logic and capabilities of a sovereign chain state machine.
-// FIX: The `Sized` bound is removed, making this trait object-safe (`dyn`).
-pub trait SovereignChain<CS, TM>
-where
-    CS: CommitmentScheme,
-    TM: TransactionModel<CommitmentScheme = CS>,
-{
-    // FIX: `new` is removed from the trait. Construction is now an inherent method on the impl struct.
-
-    // Accessor methods remain.
-    fn status(&self) -> &ChainStatus;
-    fn transaction_model(&self) -> &TM;
-
-    fn process_transaction<ST>(
-        &mut self,
-        tx: &TM::Transaction,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError>
-    where
-        ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-            + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-            + Send + Sync + 'static;
-
-    fn process_block<ST>(
-        &mut self,
-        block: Block<TM::Transaction>,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError>
-    where
-        ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-            + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-            + Send + Sync + 'static,
-        CS::Commitment: Send + Sync;
-
-    fn create_block<ST>(
-        &self,
-        transactions: Vec<TM::Transaction>,
-        workload: &WorkloadContainer<ST>,
-    ) -> Block<TM::Transaction>
-    where
-        ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-            + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-            + Send + Sync + 'static,
-        CS::Commitment: Send + Sync;
-    
-    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>>;
-}```
-
-###### Directory: chain/src/upgrade_manager
-
-####### File: chain/src/upgrade_manager/mod.rs
-####*Size: 8.0K, Lines: 193, Type: ASCII text*
-
-```rust
-use depin_sdk_core::error::CoreError;
-use depin_sdk_core::services::{ServiceType, UpgradableService};
-use std::collections::HashMap;
-use std::fmt;
-use std::sync::Arc;
-
-/// Manages runtime upgrades of blockchain services
-pub struct ModuleUpgradeManager {
-    /// Holds the currently active, concrete service implementations
-    active_services: HashMap<ServiceType, Arc<dyn UpgradableService>>,
-    /// Tracks upgrade history for each service type
-    upgrade_history: HashMap<ServiceType, Vec<u64>>,
-    /// Scheduled upgrades by block height
-    scheduled_upgrades: HashMap<u64, Vec<(ServiceType, Vec<u8>)>>,
-}
-
-// FIX: Manually implement Debug because Arc<dyn UpgradableService> does not implement Debug.
-// This implementation prints the service types instead of the service objects themselves.
-impl fmt::Debug for ModuleUpgradeManager {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        f.debug_struct("ModuleUpgradeManager")
-            .field("active_services", &self.active_services.keys())
-            .field("upgrade_history", &self.upgrade_history)
-            .field("scheduled_upgrades", &self.scheduled_upgrades)
-            .finish()
-    }
-}
-
-impl ModuleUpgradeManager {
-    /// Create a new module upgrade manager
-    pub fn new() -> Self {
-        Self {
-            active_services: HashMap::new(),
-            upgrade_history: HashMap::new(),
-            scheduled_upgrades: HashMap::new(),
-        }
-    }
-
-    /// Register a service with the manager
-    pub fn register_service(&mut self, service: Arc<dyn UpgradableService>) {
-        let service_type = service.service_type();
-        self.active_services.insert(service_type.clone(), service);
-
-        // Initialize upgrade history if not present
-        self.upgrade_history
-            .entry(service_type)
-            .or_insert_with(Vec::new);
-    }
-
-    /// Get a service by type
-    pub fn get_service(&self, service_type: &ServiceType) -> Option<Arc<dyn UpgradableService>> {
-        self.active_services.get(service_type).cloned()
-    }
-
-    /// Schedule an upgrade for a specific block height
-    pub fn schedule_upgrade(
-        &mut self,
-        service_type: ServiceType,
-        upgrade_data: Vec<u8>,
-        activation_height: u64,
-    ) -> Result<(), CoreError> {
-        self.scheduled_upgrades
-            .entry(activation_height)
-            .or_insert_with(Vec::new)
-            .push((service_type, upgrade_data));
-
-        Ok(())
-    }
-
-    /// Apply any upgrades scheduled for the given block height
-    pub fn apply_upgrades_at_height(&mut self, height: u64) -> Result<usize, CoreError> {
-        let upgrades = match self.scheduled_upgrades.remove(&height) {
-            Some(upgrades) => upgrades,
-            None => return Ok(0),
-        };
-
-        let mut applied_count = 0;
-
-        for (service_type, upgrade_data) in upgrades {
-            match self.execute_upgrade(&service_type, &upgrade_data) {
-                Ok(()) => {
-                    applied_count += 1;
-                    // Record the upgrade in history
-                    if let Some(history) = self.upgrade_history.get_mut(&service_type) {
-                        history.push(height);
-                    }
-                }
-                Err(e) => {
-                    // Log error but continue with other upgrades
-                    eprintln!("Failed to upgrade service {:?}: {}", service_type, e);
-                }
-            }
-        }
-
-        Ok(applied_count)
-    }
-
-    /// Execute an upgrade for a specific service
-    pub fn execute_upgrade(
-        &mut self,
-        service_type: &ServiceType,
-        new_module_wasm: &[u8],
-    ) -> Result<(), CoreError> {
-        let active_service = self
-            .active_services
-            .get_mut(service_type)
-            .ok_or_else(|| CoreError::ServiceNotFound(format!("{:?}", service_type)))?;
-
-        // 1. Prepare: Get the state snapshot from the current service
-        let _snapshot = active_service
-            .prepare_upgrade(new_module_wasm)
-            .map_err(|e| CoreError::UpgradeError(e.to_string()))?;
-
-        // 2. TODO: Instantiate new service from WASM (or other format)
-        // This would require a proper WASM loading mechanism
-        // For now, we'll create a placeholder
-
-        // 3. TODO: Complete the upgrade by migrating state to new service
-        // new_service.complete_upgrade(&snapshot)?;
-
-        // 4. TODO: Atomically swap the implementation
-        // self.active_services.insert(service_type.clone(), Arc::new(new_service));
-
-        // For now, just return success as this is a stub implementation
-        Ok(())
-    }
-
-    /// Get upgrade history for a service
-    pub fn get_upgrade_history(&self, service_type: &ServiceType) -> Vec<u64> {
-        self.upgrade_history
-            .get(service_type)
-            .cloned()
-            .unwrap_or_default()
-    }
-
-    /// Check health status of all services
-    pub fn check_all_health(&self) -> Vec<(ServiceType, bool)> {
-        self.active_services
-            .iter()
-            .map(|(service_type, service)| {
-                let is_healthy = match service.health_check() {
-                    Ok(_) => true,
-                    Err(_) => false,
-                };
-                (service_type.clone(), is_healthy)
-            })
-            .collect()
-    }
-
-    /// Start all registered services
-    pub fn start_all_services(&mut self) -> Result<(), CoreError> {
-        for (service_type, service) in &self.active_services {
-            service.start().map_err(|e| {
-                CoreError::Custom(format!(
-                    "Failed to start service {:?}: {}",
-                    service_type, e
-                ))
-            })?;
-        }
-        Ok(())
-    }
-
-    /// Stop all registered services
-    pub fn stop_all_services(&mut self) -> Result<(), CoreError> {
-        for (service_type, service) in &self.active_services {
-            service.stop().map_err(|e| {
-                CoreError::Custom(format!("Failed to stop service {:?}: {}", service_type, e))
-            })?;
-        }
-        Ok(())
-    }
-
-    /// Reset the manager to initial state
-    pub fn reset(&mut self) -> Result<(), CoreError> {
-        // Stop all services first
-        self.stop_all_services()?;
-
-        // Clear all state
-        self.active_services.clear();
-        self.upgrade_history.clear();
-        self.scheduled_upgrades.clear();
-
-        Ok(())
-    }
-}
-
-/// Helper function to load a service from WASM bytes
-/// TODO: Implement actual WASM loading logic
-#[allow(dead_code)]
-fn load_service_from_wasm(_wasm_bytes: &[u8]) -> Result<Box<dyn UpgradableService>, CoreError> {
-    Err(CoreError::Custom(
-        "WASM loading not implemented yet".to_string(),
-    ))
-}```
-
-###### File: chain/src/lib.rs
-###*Size: 4.0K, Lines: 10, Type: ASCII text*
-
-```rust
-//! # DePIN SDK Chain
-//!
-//! This crate provides the implementation logic for the `SovereignAppChain` state machine.
-
-mod app;
-pub mod upgrade_manager;
-pub mod traits;
-
-// FIX: Corrected the path to ChainLogic, removing the non-existent 'logic' module.
-pub use app::ChainLogic;
-pub use upgrade_manager::ModuleUpgradeManager;```
-
-##### File: chain/Cargo.toml
-##*Size: 4.0K, Lines: 45, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-chain"
-version = "0.1.0"
-edition = "2021"
-description = "Chain implementation components for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-consensus = { path = "../consensus" }
-depin-sdk-core = { path = "../core" }
-depin-sdk-commitment-schemes = { path = "../commitment_schemes" }
-depin-sdk-state-trees = { path = "../state_trees" }
-depin-sdk-transaction-models = { path = "../transaction_models" }
-depin-sdk-validator = { path = "../validator" }
-log = { workspace = true }
-serde = { workspace = true, features = ["derive"] }
-serde_json = { workspace = true }
-thiserror = { workspace = true }
-anyhow = { workspace = true }
-tokio = { workspace = true, features = ["full"], optional = true }
-futures = { workspace = true, optional = true }
-hex = { workspace = true, optional = true }
-clap = { workspace = true, features = ["derive"], optional = true }
-env_logger = { workspace = true, optional = true }
-libp2p = { workspace = true, optional = true }
-# FIX: Add the missing async-trait dependency.
-async-trait = { workspace = true }
-
-[features]
-default = []
-tendermint = []
-custom-consensus = []
-mvsc-bin = [
-    "dep:tokio",
-    "dep:futures",
-    "dep:hex",
-    "dep:clap",
-    "dep:env_logger",
-    "dep:libp2p",
-]
-
-[[bin]]
-name = "mvsc"
-path = "src/bin/mvsc.rs"
-required-features = ["mvsc-bin"]
-```
-
-#### Directory: commitment_schemes
-
-##### Directory: commitment_schemes/src
-
-###### Directory: commitment_schemes/src/elliptical_curve
-
-####### File: commitment_schemes/src/elliptical_curve/mod.rs
-####*Size: 16K, Lines: 381, Type: ASCII text*
-
-```rust
-//! Elliptical curve commitment implementation
-// File: crates/commitment_schemes/src/elliptical_curve/mod.rs
-//! Elliptical curve commitment implementation
-
-use depin_sdk_crypto::algorithms::hash;
-use dcrypt::algorithms::ec::k256::{self as k256, Point, Scalar};
-use rand::{rngs::OsRng, RngCore};
-
-use depin_sdk_core::commitment::{
-    CommitmentScheme, HomomorphicCommitmentScheme, HomomorphicOperation, ProofContext,
-    SchemeIdentifier, Selector,
-};
-
-/// Elliptical curve commitment scheme
-#[derive(Debug, Clone)]
-pub struct EllipticalCurveCommitmentScheme {
-    /// Generator points
-    generators: Vec<Point>,
-}
-
-/// Elliptical curve commitment
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct EllipticalCurveCommitment([u8; k256::K256_POINT_COMPRESSED_SIZE]);
-
-impl AsRef<[u8]> for EllipticalCurveCommitment {
-    fn as_ref(&self) -> &[u8] {
-        &self.0
-    }
-}
-
-/// Elliptical curve proof
-#[derive(Debug, Clone)]
-pub struct EllipticalCurveProof {
-    /// Blinding factor
-    blinding: Scalar,
-    /// Position in the commitment
-    position: usize,
-    /// Value
-    value: Vec<u8>,
-}
-
-impl EllipticalCurveCommitmentScheme {
-    /// Create a new elliptical curve commitment scheme with the specified number of generators
-    pub fn new(num_generators: usize) -> Self {
-        // Generate deterministic generators for reproducible tests
-        let mut generators = Vec::with_capacity(num_generators);
-        let g = k256::base_point_g();
-        for i in 0..num_generators {
-            // Use a SHA-256 hash to derive a scalar for each generator point
-            let scalar = Self::hash_to_scalar(format!("generator-{}", i).as_bytes());
-            generators.push(g.mul(&scalar).expect("Failed to create generator"));
-        }
-
-        Self { generators }
-    }
-
-    /// Generate a random blinding factor
-    fn random_blinding() -> k256::Scalar {
-        let mut rng = OsRng;
-        loop {
-            let mut bytes = [0u8; 32];
-            rng.fill_bytes(&mut bytes);
-            if let Ok(scalar) = Scalar::new(bytes) {
-                return scalar;
-            }
-        }
-    }
-
-    /// Convert value to scalar
-    fn value_to_scalar(value: &impl AsRef<[u8]>) -> k256::Scalar {
-        Self::hash_to_scalar(value.as_ref())
-    }
-
-    /// Helper to convert a hash to a valid scalar, retrying if needed.
-    fn hash_to_scalar(data: &[u8]) -> k256::Scalar {
-        let mut hash_bytes = hash::sha256(data);
-        loop {
-            // Create a fixed-size array from the vector's slice to avoid moving hash_bytes.
-            let mut array = [0u8; 32];
-            array.copy_from_slice(&hash_bytes);
-            if let Ok(scalar) = Scalar::new(array) {
-                return scalar;
-            }
-            // Re-hash if the hash corresponds to an invalid scalar (e.g., zero)
-            hash_bytes = hash::sha256(&hash_bytes);
-        }
-    }
-}
-
-impl CommitmentScheme for EllipticalCurveCommitmentScheme {
-    type Commitment = EllipticalCurveCommitment;
-    type Proof = EllipticalCurveProof;
-    type Value = Vec<u8>;
-
-    fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-        // Start with identity point
-        let mut commitment_point = Point::identity();
-
-        // Use generators for each value
-        for (i, value_opt) in values.iter().enumerate() {
-            if i >= self.generators.len() {
-                break; // Don't exceed available generators
-            }
-
-            if let Some(value) = value_opt {
-                // Convert value to scalar
-                let scalar = Self::value_to_scalar(value);
-
-                // Add generator_i * value_scalar to the commitment point
-                let term = self.generators[i].mul(&scalar).expect("Scalar mul failed");
-                commitment_point = commitment_point.add(&term);
-            }
-        }
-
-        // Add a random blinding factor with the last generator if we have one
-        if !self.generators.is_empty() {
-            let blinding = Self::random_blinding();
-            let blinding_term = self.generators[self.generators.len() - 1].mul(&blinding).expect("Blinding failed");
-            commitment_point = commitment_point.add(&blinding_term);
-        }
-
-        // Return the compressed point representation
-        EllipticalCurveCommitment(commitment_point.serialize_compressed())
-    }
-
-    fn create_proof(
-        &self,
-        selector: &Selector,
-        value: &Self::Value,
-    ) -> Result<Self::Proof, String> {
-        // Extract position from selector
-        let position = match selector {
-            Selector::Position(pos) => *pos,
-            // For now, we only support position-based selectors
-            _ => return Err("Only position-based selectors are supported".to_string()),
-        };
-
-        if position >= self.generators.len() {
-            return Err(format!("Position {} out of bounds", position));
-        }
-
-        // Create a random blinding factor
-        let blinding = Self::random_blinding();
-
-        // Return a proof with position, value, and blinding
-        Ok(EllipticalCurveProof {
-            blinding,
-            position,
-            value: value.clone(),
-        })
-    }
-
-    fn verify(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        selector: &Selector,
-        value: &Self::Value,
-        context: &ProofContext,
-    ) -> bool {
-        // Extract position from selector
-        let position = match selector {
-            Selector::Position(pos) => *pos,
-            // For now, we only support position-based selectors
-            _ => return false,
-        };
-
-        // Check position matches
-        if position != proof.position || position >= self.generators.len() {
-            return false;
-        }
-
-        // Check value matches
-        if proof.value != *value {
-            return false;
-        }
-
-        // Use context to check for verification flags or parameters
-        // This is a placeholder implementation to demonstrate context usage
-
-        /* The context parameter in a real-world scenario might include:
-         * 1. Cryptographic domain separation parameters to prevent cross-protocol attacks
-         * 2. Chain-specific verification rules (e.g., specific validation rules per blockchain)
-         * 3. Security level parameters (e.g., required bit security level)
-         * 4. Curve-specific parameters or optimizations
-         * 5. Batch verification settings to optimize multiple proof verifications
-         * 6. Time bounds for time-sensitive commitments
-         * 7. Circuit-specific parameters for zero-knowledge proofs
-         * 8. Public parameters needed for verification
-         * 9. Reusable values to prevent recomputation across multiple verifications
-         * 10. Context-specific verification flags like the one demonstrated below
-         */
-
-        let strict_verification = context
-            .get_data("strict_verification")
-            .map(|v| !v.is_empty() && v[0] == 1)
-            .unwrap_or(false);
-
-        // Apply additional verification logic based on context
-        if strict_verification {
-            // In strict mode, we might perform additional checks
-            // For example, ensure the commitment is not identity
-            if commitment.as_ref() == [0u8; 32] {
-                return false;
-            }
-        }
-
-        // In a real implementation, we'd need to properly verify the commitment
-        // with the blinding factor. This is a simplified implementation.
-
-        // Convert value to scalar
-        let value_scalar = Self::value_to_scalar(value);
-
-        // Recreate the point for the value and blinding factor
-        let blinding_generator = &self.generators[self.generators.len() - 1];
-        let value_term = self.generators[position].mul(&value_scalar).expect("Scalar mul failed");
-        let blinding_term = blinding_generator.mul(&proof.blinding).expect("Blinding failed");
-        let computed_point = value_term.add(&blinding_term);
-
-        // Check if the computed commitment matches the provided one
-        let computed_commitment = EllipticalCurveCommitment(computed_point.serialize_compressed());
-
-        // This is a simplified check - a real implementation would be more complex
-        // for multiple values
-        commitment.as_ref() == computed_commitment.as_ref()
-    }
-
-    fn scheme_id() -> SchemeIdentifier {
-        SchemeIdentifier::new("elliptical_curve")
-    }
-}
-
-impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
-    fn add(&self, a: &Self::Commitment, b: &Self::Commitment) -> Result<Self::Commitment, String> {
-        // Decompress points
-        let point_a = Point::deserialize_compressed(a.as_ref()).map_err(|e| e.to_string())?;
-        let point_b = Point::deserialize_compressed(b.as_ref()).map_err(|e| e.to_string())?;
-
-        // Homomorphic addition is point addition
-        let result_point = point_a.add(&point_b);
-
-        Ok(EllipticalCurveCommitment(result_point.serialize_compressed()))
-    }
-
-    fn scalar_multiply(
-        &self,
-        a: &Self::Commitment,
-        scalar: i32,
-    ) -> Result<Self::Commitment, String> {
-        if scalar <= 0 {
-            return Err("Scalar must be positive".to_string());
-        }
-
-        // Decompress point
-        let point = Point::deserialize_compressed(a.as_ref()).map_err(|e| e.to_string())?;
-
-        // Convert i32 to Scalar. This is a simplified conversion for small, positive integers.
-        let mut scalar_bytes = [0u8; 32];
-        scalar_bytes[..8].copy_from_slice(&(scalar as u64).to_le_bytes());
-        let s = Scalar::new(scalar_bytes).map_err(|e| e.to_string())?;
-
-        // Scalar multiplication
-        let result_point = point.mul(&s).map_err(|e| e.to_string())?;
-
-        Ok(EllipticalCurveCommitment(result_point.serialize_compressed()))
-    }
-
-    fn supports_operation(&self, operation: HomomorphicOperation) -> bool {
-        matches!(
-            operation,
-            HomomorphicOperation::Addition | HomomorphicOperation::ScalarMultiplication
-        )
-    }
-}
-
-// Add utility methods for EllipticalCurveCommitment
-impl EllipticalCurveCommitment {
-    /// Create a new EllipticalCurveCommitment from a compressed point
-    pub fn new(point: [u8; k256::K256_POINT_COMPRESSED_SIZE]) -> Self {
-        Self(point)
-    }
-
-    /// Get the compressed point
-    pub fn point(&self) -> &[u8; k256::K256_POINT_COMPRESSED_SIZE] {
-        &self.0
-    }
-
-    /// Convert to a byte representation
-    pub fn to_bytes(&self) -> Vec<u8> {
-        self.0.to_vec()
-    }
-
-    /// Create from bytes
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        let array: [u8; k256::K256_POINT_COMPRESSED_SIZE] = bytes.try_into().map_err(|_| "Invalid point length".to_string())?;
-        Ok(Self(array))
-    }
-}
-
-// Utility methods for EllipticalCurveProof
-impl EllipticalCurveProof {
-    /// Create a new proof
-    pub fn new(blinding: Scalar, position: usize, value: Vec<u8>) -> Self {
-        Self {
-            blinding,
-            position,
-            value,
-        }
-    }
-
-    /// Get the blinding factor
-    pub fn blinding(&self) -> &Scalar {
-        &self.blinding
-    }
-
-    /// Get the position
-    pub fn position(&self) -> usize {
-        self.position
-    }
-
-    /// Get the value
-    pub fn value(&self) -> &[u8] {
-        &self.value
-    }
-
-    /// Serialize the proof
-    pub fn to_bytes(&self) -> Vec<u8> {
-        let mut result = Vec::with_capacity(32 + 8 + self.value.len() + 4);
-
-        // Serialize blinding factor (32 bytes)
-        result.extend_from_slice(self.blinding.serialize().as_ref());
-
-        // Serialize position (8 bytes)
-        result.extend_from_slice(&self.position.to_le_bytes());
-
-        // Serialize value length and value
-        result.extend_from_slice(&(self.value.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.value);
-
-        result
-    }
-
-    /// Deserialize from bytes
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        if bytes.len() < 44 {
-            // 32 + 8 + 4 (minimum for blinding, position, and value length)
-            return Err("Invalid proof length".to_string());
-        }
-
-        let mut pos = 0;
-
-        // Read blinding
-        let mut blinding_bytes = [0u8; 32];
-        blinding_bytes.copy_from_slice(&bytes[pos..pos + 32]);
-        let blinding = Scalar::new(blinding_bytes).map_err(|e| e.to_string())?;
-        pos += 32;
-
-        // Read position
-        let mut position_bytes = [0u8; 8];
-        position_bytes.copy_from_slice(&bytes[pos..pos + 8]);
-        let position = usize::from_le_bytes(position_bytes);
-        pos += 8;
-
-        // Read value length
-        let mut len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        let value_len = u32::from_le_bytes(len_bytes) as usize;
-        pos += 4;
-
-        // Read value
-        if pos + value_len > bytes.len() {
-            return Err("Invalid value length".to_string());
-        }
-        let value = bytes[pos..pos + value_len].to_vec();
-
-        Ok(Self {
-            blinding,
-            position,
-            value,
-        })
-    }
-}```
-
-###### Directory: commitment_schemes/src/hash
-
-####### File: commitment_schemes/src/hash/mod.rs
-####*Size: 12K, Lines: 375, Type: ASCII text*
-
-```rust
-//! Hash-based commitment scheme implementations
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
-use depin_sdk_crypto::algorithms::hash;
-use std::fmt::Debug;
-
-/// Hash-based commitment scheme
-#[derive(Debug, Clone)]
-pub struct HashCommitmentScheme {
-    /// Hash function to use (defaults to SHA-256)
-    hash_function: HashFunction,
-}
-
-/// Available hash functions
-#[derive(Debug, Clone, Copy)]
-pub enum HashFunction {
-    /// SHA-256
-    Sha256,
-    /// SHA-512
-    Sha512,
-}
-
-/// Hash-based commitment
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct HashCommitment(Vec<u8>);
-
-impl AsRef<[u8]> for HashCommitment {
-    fn as_ref(&self) -> &[u8] {
-        &self.0
-    }
-}
-
-/// Hash-based proof
-#[derive(Debug, Clone)]
-pub struct HashProof {
-    /// Value hash
-    pub value_hash: Vec<u8>,
-    /// Selector used for this proof
-    pub selector: Selector,
-    /// Additional proof data
-    pub additional_data: Vec<u8>,
-}
-
-impl HashCommitmentScheme {
-    /// Create a new hash commitment scheme with the default hash function (SHA-256)
-    pub fn new() -> Self {
-        Self {
-            hash_function: HashFunction::Sha256,
-        }
-    }
-
-    /// Create a new hash commitment scheme with a specific hash function
-    pub fn with_hash_function(hash_function: HashFunction) -> Self {
-        Self { hash_function }
-    }
-
-    /// Helper function to hash data using the selected hash function
-    pub fn hash_data(&self, data: &[u8]) -> Vec<u8> {
-        match self.hash_function {
-            HashFunction::Sha256 => hash::sha256(data),
-            HashFunction::Sha512 => hash::sha512(data),
-        }
-    }
-
-    /// Get the current hash function
-    pub fn hash_function(&self) -> HashFunction {
-        self.hash_function
-    }
-
-    /// Get the digest size in bytes
-    pub fn digest_size(&self) -> usize {
-        match self.hash_function {
-            HashFunction::Sha256 => 32,
-            HashFunction::Sha512 => 64,
-        }
-    }
-}
-
-impl CommitmentScheme for HashCommitmentScheme {
-    type Commitment = HashCommitment;
-    type Proof = HashProof;
-    type Value = Vec<u8>;
-
-    fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-        // Simple commitment: hash the concatenation of all values
-        let mut combined = Vec::new();
-
-        for value in values {
-            if let Some(v) = value {
-                // Add length prefix to prevent collision attacks
-                combined.extend_from_slice(&(v.len() as u32).to_le_bytes());
-                combined.extend_from_slice(v);
-            } else {
-                // Mark None values with a zero length
-                combined.extend_from_slice(&0u32.to_le_bytes());
-            }
-        }
-
-        // If there are no values, hash an empty array
-        if combined.is_empty() {
-            return HashCommitment(self.hash_data(&[]));
-        }
-
-        // Return the hash of the combined data
-        HashCommitment(self.hash_data(&combined))
-    }
-
-    fn create_proof(
-        &self,
-        selector: &Selector,
-        value: &Self::Value,
-    ) -> Result<Self::Proof, String> {
-        // Calculate the hash of the value
-        let value_hash = self.hash_data(value);
-
-        // Create additional data based on selector type
-        let additional_data = match selector {
-            Selector::Key(key) => {
-                // For key-based selectors, include the key hash
-                self.hash_data(key)
-            }
-            Selector::Position(pos) => {
-                // For position-based selectors, include the position
-                pos.to_le_bytes().to_vec()
-            }
-            _ => Vec::new(),
-        };
-
-        Ok(HashProof {
-            value_hash,
-            selector: selector.clone(),
-            additional_data,
-        })
-    }
-
-    fn verify(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        selector: &Selector,
-        value: &Self::Value,
-        context: &ProofContext,
-    ) -> bool {
-        // FIX: The compiler detected that `selector` was being compared to itself.
-        // We need to compare the proof's selector with the one passed to the function.
-        if &proof.selector != selector {
-            return false;
-        }
-
-        // Verify that the value hash matches
-        let computed_hash = self.hash_data(value);
-        if computed_hash != proof.value_hash {
-            return false;
-        }
-
-        // Basic direct verification for simple cases
-        match selector {
-            Selector::None => {
-                // For a single value, directly compare the hash
-                proof.value_hash == commitment.as_ref()
-            }
-            Selector::Key(key) => {
-                // For a key-value pair, hash the combination
-                let mut combined = Vec::new();
-                combined.extend_from_slice(key);
-                combined.extend_from_slice(value);
-                let key_value_hash = self.hash_data(&combined);
-
-                // Use context if provided
-                if let Some(verification_flag) = context.get_data("strict_verification") {
-                    if !verification_flag.is_empty() && verification_flag[0] == 1 {
-                        // Strict verification mode would go here
-                        return key_value_hash == commitment.as_ref();
-                    }
-                }
-
-                // Simple verification - not suitable for complex structures
-                // In practice, state trees would implement proper verification
-                key_value_hash == commitment.as_ref()
-            }
-            _ => {
-                // For position or predicate selectors, this basic commitment scheme
-                // cannot verify on its own - would require tree structure knowledge
-                // This would be handled by state tree implementations
-                false
-            }
-        }
-    }
-
-    fn scheme_id() -> SchemeIdentifier {
-        SchemeIdentifier::new("hash")
-    }
-}
-
-// Default implementation
-impl Default for HashCommitmentScheme {
-    fn default() -> Self {
-        Self::new()
-    }
-}
-
-// Additional utility methods for HashCommitment
-impl HashCommitment {
-    /// Create a new commitment from raw bytes
-    pub fn new(bytes: Vec<u8>) -> Self {
-        Self(bytes)
-    }
-
-    /// Get the raw commitment bytes
-    pub fn as_bytes(&self) -> &[u8] {
-        &self.0
-    }
-
-    /// Convert to a new owned Vec<u8>
-    pub fn to_vec(&self) -> Vec<u8> {
-        self.0.clone()
-    }
-}
-
-// Additional utility methods for HashProof
-impl HashProof {
-    /// Create a new proof
-    pub fn new(value_hash: Vec<u8>, selector: Selector, additional_data: Vec<u8>) -> Self {
-        Self {
-            value_hash,
-            selector,
-            additional_data,
-        }
-    }
-
-    /// Get the selector
-    pub fn selector(&self) -> &Selector {
-        &self.selector
-    }
-
-    /// Get the value hash
-    pub fn value_hash(&self) -> &[u8] {
-        &self.value_hash
-    }
-
-    /// Get the additional data
-    pub fn additional_data(&self) -> &[u8] {
-        &self.additional_data
-    }
-
-    /// Convert to a serializable format
-    pub fn to_bytes(&self) -> Vec<u8> {
-        // Simplified serialization
-        let mut result = Vec::new();
-
-        // Serialize selector
-        match &self.selector {
-            Selector::Position(pos) => {
-                result.push(1); // Selector type
-                result.extend_from_slice(&pos.to_le_bytes());
-            }
-            Selector::Key(key) => {
-                result.push(2); // Selector type
-                result.extend_from_slice(&(key.len() as u32).to_le_bytes());
-                result.extend_from_slice(key);
-            }
-            Selector::Predicate(pred) => {
-                result.push(3); // Selector type
-                result.extend_from_slice(&(pred.len() as u32).to_le_bytes());
-                result.extend_from_slice(pred);
-            }
-            Selector::None => {
-                result.push(0); // Selector type
-            }
-        }
-
-        // Serialize value hash
-        result.extend_from_slice(&(self.value_hash.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.value_hash);
-
-        // Serialize additional data
-        result.extend_from_slice(&(self.additional_data.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.additional_data);
-
-        result
-    }
-
-    /// Create from serialized format
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        if bytes.is_empty() {
-            return Err("Empty bytes".to_string());
-        }
-
-        let mut pos = 0;
-
-        // Deserialize selector
-        let selector_type = bytes[pos];
-        pos += 1;
-
-        let selector = match selector_type {
-            0 => Selector::None,
-            1 => {
-                if pos + 8 > bytes.len() {
-                    return Err("Invalid position selector".to_string());
-                }
-                let mut position_bytes = [0u8; 8];
-                position_bytes.copy_from_slice(&bytes[pos..pos + 8]);
-                pos += 8;
-                Selector::Position(usize::from_le_bytes(position_bytes))
-            }
-            2 => {
-                if pos + 4 > bytes.len() {
-                    return Err("Invalid key selector".to_string());
-                }
-                let mut len_bytes = [0u8; 4];
-                len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-                pos += 4;
-                let key_len = u32::from_le_bytes(len_bytes) as usize;
-
-                if pos + key_len > bytes.len() {
-                    return Err("Invalid key length".to_string());
-                }
-                let key = bytes[pos..pos + key_len].to_vec();
-                pos += key_len;
-                Selector::Key(key)
-            }
-            3 => {
-                if pos + 4 > bytes.len() {
-                    return Err("Invalid predicate selector".to_string());
-                }
-                let mut len_bytes = [0u8; 4];
-                len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-                pos += 4;
-                let pred_len = u32::from_le_bytes(len_bytes) as usize;
-
-                if pos + pred_len > bytes.len() {
-                    return Err("Invalid predicate length".to_string());
-                }
-                let pred = bytes[pos..pos + pred_len].to_vec();
-                pos += pred_len;
-                Selector::Predicate(pred)
-            }
-            _ => return Err(format!("Unknown selector type: {}", selector_type)),
-        };
-
-        // Deserialize value hash
-        if pos + 4 > bytes.len() {
-            return Err("Invalid value hash length".to_string());
-        }
-        let mut len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        pos += 4;
-        let hash_len = u32::from_le_bytes(len_bytes) as usize;
-
-        if pos + hash_len > bytes.len() {
-            return Err("Invalid hash length".to_string());
-        }
-        let value_hash = bytes[pos..pos + hash_len].to_vec();
-        pos += hash_len;
-
-        // Deserialize additional data
-        if pos + 4 > bytes.len() {
-            return Err("Invalid additional data length".to_string());
-        }
-        let mut len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        pos += 4;
-        let add_len = u32::from_le_bytes(len_bytes) as usize;
-
-        if pos + add_len > bytes.len() {
-            return Err("Invalid additional data length".to_string());
-        }
-        let additional_data = bytes[pos..pos + add_len].to_vec();
-
-        Ok(HashProof {
-            value_hash,
-            selector,
-            additional_data,
-        })
-    }
-}```
-
-###### Directory: commitment_schemes/src/kzg
-
-####### File: commitment_schemes/src/kzg/mod.rs
-####*Size: 12K, Lines: 320, Type: Unicode text, UTF-8 text*
-
-```rust
-//! KZG Polynomial Commitment Scheme Implementation
-//!
-//! # Implementation Status
-//!
-//! IMPORTANT: This is still a placeholder implementation with dummy cryptographic operations.
-//! A full implementation would require:
-//!
-//! 1. Integration with an elliptic curve library for bilinear pairings
-//!    - Need a pairing-friendly curve like BLS12-381
-//!    - Requires efficient implementation of the bilinear map e: G  G  GT
-//!
-//! 2. Proper finite field arithmetic
-//!    - Field operations in Fp for polynomial coefficients
-//!    - Polynomial arithmetic (addition, multiplication, division)
-//!    - Evaluation at arbitrary points
-//!
-//! 3. Structured reference string generation or loading
-//!    - Implementation of trusted setup ceremony or loading from trusted source
-//!    - Secure handling of setup parameters
-//!    - Verification of SRS integrity
-//!
-//! 4. Complete polynomial evaluation logic
-//!    - Division by (X - z) to create quotient polynomial
-//!    - Batch verification techniques for efficiency
-//!    - Handling edge cases and potential attack vectors
-//!
-//! # Mathematical Background
-//!
-//! KZG polynomial commitments use a bilinear pairing e: G  G  GT over elliptic curve groups
-//! to create and verify commitments to polynomials. The scheme requires a trusted setup to generate
-//! a structured reference string (SRS) containing powers of a secret value.
-//!
-//! The KZG scheme consists of four main operations:
-//! - Setup: Generate SRS parameters (G = []G and G = []G) where  is a secret
-//! - Commit: For a polynomial p(X) =  cX, compute C =  cG
-//! - Prove: For a point z, compute proof  that p(z) = y using the quotient polynomial q(X) = (p(X) - y)/(X - z)
-//! - Verify: Check if e(C - [y]G, G) = e(, G - [z]G)
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
-use std::fmt::Debug;
-
-/// Structured Reference String (from trusted setup)
-#[derive(Debug, Clone)]
-pub struct KZGParams {
-    /// G1 points
-    pub g1_points: Vec<Vec<u8>>, // Simplified - would be actual curve points
-    /// G2 points
-    pub g2_points: Vec<Vec<u8>>, // Simplified - would be actual curve points
-}
-
-/// KZG polynomial commitment scheme
-#[derive(Debug)]
-pub struct KZGCommitmentScheme {
-    /// Cryptographic parameters from trusted setup
-    params: KZGParams,
-}
-
-/// KZG commitment to a polynomial
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct KZGCommitment(Vec<u8>);
-
-/// KZG proof for a polynomial evaluation
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct KZGProof {
-    /// The quotient polynomial commitment
-    quotient: Vec<u8>,
-    /// The evaluation point
-    point: Vec<u8>,
-    /// The claimed evaluation value
-    value: Vec<u8>,
-}
-
-/// Polynomial representation
-#[derive(Debug, Clone)]
-pub struct Polynomial {
-    /// Coefficients of the polynomial
-    coefficients: Vec<Vec<u8>>, // Simplified - would be field elements
-}
-
-impl KZGCommitmentScheme {
-    /// Create a new KZG commitment scheme with the given parameters
-    pub fn new(params: KZGParams) -> Self {
-        Self { params }
-    }
-
-    /// Create a default scheme with dummy parameters (for testing only)
-    pub fn default() -> Self {
-        Self {
-            params: KZGParams {
-                g1_points: vec![vec![0; 32]; 10], // Dummy parameters
-                g2_points: vec![vec![0; 64]; 10], // Dummy parameters
-            },
-        }
-    }
-
-    /// Commit to a polynomial directly
-    pub fn commit_polynomial(&self, polynomial: &Polynomial) -> KZGCommitment {
-        // In a real implementation, this would compute:
-        // C =  cG where c are polynomial coefficients
-
-        // For now, return a dummy commitment
-        KZGCommitment(vec![0; 32])
-    }
-
-    /// Create a proof for a polynomial evaluation at a point
-    pub fn create_evaluation_proof(
-        &self,
-        polynomial: &Polynomial,
-        point: &[u8],
-        commitment: &KZGCommitment,
-    ) -> Result<KZGProof, String> {
-        // In a real implementation, this would:
-        // 1. Evaluate the polynomial at the point: y = p(z)
-        // 2. Compute the quotient polynomial q(X) = (p(X) - y) / (X - z)
-        // 3. Commit to the quotient polynomial
-
-        // For now, return a dummy proof
-        let value = vec![0; 32]; // Dummy evaluation result
-
-        Ok(KZGProof {
-            quotient: vec![0; 32],
-            point: point.to_vec(),
-            value,
-        })
-    }
-
-    /// Verify a polynomial evaluation proof
-    pub fn verify_evaluation(&self, commitment: &KZGCommitment, proof: &KZGProof) -> bool {
-        // In a real implementation, this would verify:
-        // e(C - [y]G, G) = e(, G - [z]G)
-
-        // For now, always return true
-        true
-    }
-}
-
-impl AsRef<[u8]> for KZGCommitment {
-    fn as_ref(&self) -> &[u8] {
-        &self.0
-    }
-}
-
-// Implement CommitmentScheme trait to integrate with the existing system
-impl CommitmentScheme for KZGCommitmentScheme {
-    type Commitment = KZGCommitment;
-    type Proof = KZGProof;
-    type Value = Vec<u8>;
-
-    fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-        // Convert values to a polynomial
-        let coefficients = values.iter().filter_map(|opt| opt.clone()).collect();
-
-        let polynomial = Polynomial { coefficients };
-
-        // Use the specialized method for polynomial commitment
-        self.commit_polynomial(&polynomial)
-    }
-
-    fn create_proof(
-        &self,
-        selector: &Selector,
-        value: &Self::Value,
-    ) -> Result<Self::Proof, String> {
-        // Extract point from selector
-        let point = match selector {
-            Selector::Position(pos) => {
-                // Convert position to a field element
-                (*pos as u64).to_le_bytes().to_vec()
-            }
-            Selector::Key(key) => {
-                // Use key directly as the evaluation point
-                key.clone()
-            }
-            _ => return Err("KZG only supports Position or Key selectors".to_string()),
-        };
-
-        // We don't have the polynomial here, so we create a dummy proof
-        // In practice, create_proof would need access to the original polynomial
-        let dummy_polynomial = Polynomial {
-            coefficients: vec![value.clone()], // Not actually correct
-        };
-
-        let dummy_commitment = KZGCommitment(vec![0; 32]);
-        self.create_evaluation_proof(&dummy_polynomial, &point, &dummy_commitment)
-    }
-
-    fn verify(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        _selector: &Selector,
-        _value: &Self::Value,
-        _context: &ProofContext,
-    ) -> bool {
-        // Use the specialized verification method
-        self.verify_evaluation(commitment, proof)
-    }
-
-    fn scheme_id() -> SchemeIdentifier {
-        SchemeIdentifier::new("kzg")
-    }
-}
-
-// Utility methods for KZGCommitment
-impl KZGCommitment {
-    /// Create a new KZG commitment from raw data
-    pub fn new(data: Vec<u8>) -> Self {
-        Self(data)
-    }
-
-    /// Get the commitment data
-    pub fn data(&self) -> &[u8] {
-        &self.0
-    }
-
-    /// Convert to bytes for serialization
-    pub fn to_bytes(&self) -> Vec<u8> {
-        self.0.clone()
-    }
-
-    /// Create from bytes
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        Ok(Self(bytes.to_vec()))
-    }
-}
-
-// Utility methods for KZGProof
-impl KZGProof {
-    /// Create a new KZG proof from components
-    pub fn new(quotient: Vec<u8>, point: Vec<u8>, value: Vec<u8>) -> Self {
-        Self {
-            quotient,
-            point,
-            value,
-        }
-    }
-
-    /// Get the quotient polynomial commitment
-    pub fn quotient(&self) -> &[u8] {
-        &self.quotient
-    }
-
-    /// Get the evaluation point
-    pub fn point(&self) -> &[u8] {
-        &self.point
-    }
-
-    /// Get the evaluation value
-    pub fn value(&self) -> &[u8] {
-        &self.value
-    }
-
-    /// Convert to bytes for serialization
-    pub fn to_bytes(&self) -> Vec<u8> {
-        let mut result = Vec::new();
-
-        // Quotient length and data
-        result.extend_from_slice(&(self.quotient.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.quotient);
-
-        // Point length and data
-        result.extend_from_slice(&(self.point.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.point);
-
-        // Value length and data
-        result.extend_from_slice(&(self.value.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.value);
-
-        result
-    }
-
-    /// Create from bytes
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        if bytes.len() < 12 {
-            return Err("Invalid proof format: too short".to_string());
-        }
-
-        let mut pos = 0;
-
-        // Read quotient
-        let mut len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        pos += 4;
-        let quotient_len = u32::from_le_bytes(len_bytes) as usize;
-
-        if pos + quotient_len > bytes.len() {
-            return Err("Invalid proof format: quotient truncated".to_string());
-        }
-        let quotient = bytes[pos..pos + quotient_len].to_vec();
-        pos += quotient_len;
-
-        // Read point
-        len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        pos += 4;
-        let point_len = u32::from_le_bytes(len_bytes) as usize;
-
-        if pos + point_len > bytes.len() {
-            return Err("Invalid proof format: point truncated".to_string());
-        }
-        let point = bytes[pos..pos + point_len].to_vec();
-        pos += point_len;
-
-        // Read value
-        len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        pos += 4;
-        let value_len = u32::from_le_bytes(len_bytes) as usize;
-
-        if pos + value_len > bytes.len() {
-            return Err("Invalid proof format: value truncated".to_string());
-        }
-        let value = bytes[pos..pos + value_len].to_vec();
-
-        Ok(Self {
-            quotient,
-            point,
-            value,
-        })
-    }
-}```
-
-####### File: commitment_schemes/src/kzg/mod.rs:108:9
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-####### File: commitment_schemes/src/kzg/mod.rs:110:9
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-####### File: commitment_schemes/src/kzg/mod.rs:128:37
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-####### File: commitment_schemes/src/kzg/mod.rs:128:65
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-####### File: commitment_schemes/src/kzg/mod.rs:55:5
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-####### File: commitment_schemes/src/kzg/mod.rs:77:5
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-####### File: commitment_schemes/src/kzg/mod.rs:97:37
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-###### Directory: commitment_schemes/src/lattice
-
-####### File: commitment_schemes/src/lattice/mod.rs
-####*Size: 8.0K, Lines: 231, Type: ASCII text*
-
-```rust
-//! Lattice-based commitment scheme implementation
-//!
-//! This module implements a lattice-based commitment scheme using
-//! cryptographic primitives from lattice-based cryptography.
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
-use std::fmt::Debug;
-
-/// Lattice-based commitment scheme
-#[derive(Debug)]
-pub struct LatticeCommitmentScheme {
-    /// Dimension of the lattice
-    dimension: usize,
-}
-
-/// Lattice-based commitment
-#[derive(Debug, Clone)]
-pub struct LatticeCommitment(Vec<u8>);
-
-impl AsRef<[u8]> for LatticeCommitment {
-    fn as_ref(&self) -> &[u8] {
-        &self.0
-    }
-}
-
-/// Lattice-based proof
-#[derive(Debug, Clone)]
-pub struct LatticeProof {
-    /// Proof data
-    data: Vec<u8>,
-    /// Position
-    position: usize,
-}
-
-impl LatticeCommitmentScheme {
-    /// Create a new lattice-based commitment scheme with specified dimension
-    pub fn new(dimension: usize) -> Self {
-        Self { dimension }
-    }
-
-    /// Get the dimension of the lattice
-    pub fn dimension(&self) -> usize {
-        self.dimension
-    }
-
-    /// Default parameters suitable for 128-bit security
-    pub fn default_params() -> Self {
-        Self { dimension: 512 }
-    }
-}
-
-impl CommitmentScheme for LatticeCommitmentScheme {
-    type Commitment = LatticeCommitment;
-    type Proof = LatticeProof;
-    type Value = Vec<u8>;
-
-    fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-        // In a real implementation, this would:
-        // 1. Convert values to polynomial coefficients
-        // 2. Generate a random lattice-based commitment
-        // 3. Return the commitment
-
-        // Simplified implementation for now
-        let mut combined = Vec::new();
-        for maybe_value in values {
-            if let Some(value) = maybe_value {
-                combined.extend_from_slice(value.as_ref());
-            }
-        }
-
-        // Add some "randomness" based on the dimension
-        combined.extend_from_slice(&self.dimension.to_le_bytes());
-
-        // Return a placeholder commitment
-        LatticeCommitment(combined)
-    }
-
-    fn create_proof(
-        &self,
-        selector: &Selector,
-        value: &Self::Value,
-    ) -> Result<Self::Proof, String> {
-        // Extract position from selector
-        let position = match selector {
-            Selector::Position(pos) => *pos,
-            _ => return Err("Only position-based selectors are supported".to_string()),
-        };
-
-        // In a real implementation, this would:
-        // 1. Generate a zero-knowledge proof that the value at position
-        //    is correctly committed to in the commitment
-        // 2. Use lattice-based techniques to create the proof
-
-        // For now, return a simple proof that just wraps the value and position
-        let mut proof_data = Vec::new();
-        proof_data.extend_from_slice(value.as_ref());
-        proof_data.extend_from_slice(&position.to_le_bytes());
-
-        Ok(LatticeProof {
-            data: proof_data,
-            position,
-        })
-    }
-
-    fn verify(
-        &self,
-        _commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        selector: &Selector,
-        value: &Self::Value,
-        _context: &ProofContext,
-    ) -> bool {
-        // Extract position from selector
-        let position = match selector {
-            Selector::Position(pos) => *pos,
-            _ => return false, // Only support position-based selectors for now
-        };
-
-        // Check position matches
-        if position != proof.position {
-            return false;
-        }
-
-        // In a real implementation, this would:
-        // 1. Verify the zero-knowledge proof against the commitment
-        // 2. Check that the proof correctly authenticates the value
-
-        // For this simplified implementation, we'll check if the proof contains the value
-        let mut expected_data = Vec::new();
-        expected_data.extend_from_slice(value.as_ref());
-        expected_data.extend_from_slice(&position.to_le_bytes());
-
-        proof.data.starts_with(value.as_ref())
-    }
-
-    fn scheme_id() -> SchemeIdentifier {
-        SchemeIdentifier::new("lattice")
-    }
-}
-
-impl Default for LatticeCommitmentScheme {
-    fn default() -> Self {
-        Self::default_params()
-    }
-}
-
-// Additional utility methods for LatticeCommitment
-impl LatticeCommitment {
-    /// Create a new commitment from raw bytes
-    pub fn new(data: Vec<u8>) -> Self {
-        Self(data)
-    }
-
-    /// Get the raw commitment data
-    pub fn data(&self) -> &[u8] {
-        &self.0
-    }
-
-    /// Convert to bytes for serialization
-    pub fn to_bytes(&self) -> Vec<u8> {
-        self.0.clone()
-    }
-
-    /// Create from bytes
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        if bytes.is_empty() {
-            return Err("Empty commitment data".to_string());
-        }
-        Ok(Self(bytes.to_vec()))
-    }
-}
-
-// Additional utility methods for LatticeProof
-impl LatticeProof {
-    /// Create a new proof
-    pub fn new(data: Vec<u8>, position: usize) -> Self {
-        Self { data, position }
-    }
-
-    /// Get the proof data
-    pub fn data(&self) -> &[u8] {
-        &self.data
-    }
-
-    /// Get the position
-    pub fn position(&self) -> usize {
-        self.position
-    }
-
-    /// Convert to bytes for serialization
-    pub fn to_bytes(&self) -> Vec<u8> {
-        let mut result = Vec::new();
-        result.extend_from_slice(&(self.data.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.data);
-        result.extend_from_slice(&self.position.to_le_bytes());
-        result
-    }
-
-    /// Create from bytes
-    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        if bytes.len() < 12 {
-            // 4 bytes for length + at least 0 bytes for data + 8 bytes for position
-            return Err("Invalid proof format: too short".to_string());
-        }
-
-        let mut pos = 0;
-
-        // Read data length
-        let mut len_bytes = [0u8; 4];
-        len_bytes.copy_from_slice(&bytes[pos..pos + 4]);
-        pos += 4;
-        let data_len = u32::from_le_bytes(len_bytes) as usize;
-
-        // Read data
-        if pos + data_len > bytes.len() {
-            return Err("Invalid proof format: data truncated".to_string());
-        }
-        let data = bytes[pos..pos + data_len].to_vec();
-        pos += data_len;
-
-        // Read position
-        if pos + 8 > bytes.len() {
-            return Err("Invalid proof format: position truncated".to_string());
-        }
-        let mut pos_bytes = [0u8; 8];
-        pos_bytes.copy_from_slice(&bytes[pos..pos + 8]);
-        let position = usize::from_le_bytes(pos_bytes);
-
-        Ok(Self { data, position })
-    }
-}
-```
-
-###### File: commitment_schemes/src/lib.rs
-###*Size: 4.0K, Lines: 8, Type: ASCII text*
-
-```rust
-//! # DePIN SDK Commitment Schemes
-//!
-//! Implementations of various commitment schemes for the DePIN SDK.
-
-pub mod elliptical_curve;
-pub mod hash;
-pub mod kzg;
-pub mod lattice; // Renamed from module_lwe
-```
-
-##### File: commitment_schemes/Cargo.toml
-##*Size: 4.0K, Lines: 23, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-commitment-schemes"
-version = "0.1.0"
-edition = "2021"
-description = "Commitment scheme implementations for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-depin-sdk-crypto = { path = "../crypto" }
-dcrypt = { version = "0.12.0-beta.1", features = ["full"] }
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-bytes = { workspace = true }
-rand = { workspace = true }
-
-[features]
-default = []
-hash = []
-kzg = []
-module_lwe = ["depin-sdk-core/post-quantum"]
-elliptical_curve = ["depin-sdk-core/homomorphic"]
-```
-
-#### Directory: consensus
-
-##### Directory: consensus/src
-
-###### Directory: consensus/src/tests
-
-####### File: consensus/src/tests/mod.rs
-####*Size: 0, Lines: 0, Type: empty*
-
-####*File content not included (exceeds threshold or non-text file)*
-
-###### File: consensus/src/lib.rs
-###*Size: 4.0K, Lines: 120, Type: ASCII text*
-
-```rust
-//! Consensus module implementations for the DePIN SDK
-
-use std::time::Duration;
-
-/// Consensus algorithm types
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum ConsensusAlgorithm {
-    /// Proof of Stake
-    ProofOfStake,
-    /// Delegated Proof of Stake
-    DelegatedProofOfStake,
-    /// Proof of Authority
-    ProofOfAuthority,
-    /// Custom consensus algorithm
-    Custom(u32),
-}
-
-/// Consensus configuration
-#[derive(Debug, Clone)]
-pub struct ConsensusConfig {
-    /// Consensus algorithm
-    pub algorithm: ConsensusAlgorithm,
-    /// Block time target
-    pub block_time: Duration,
-    /// Number of validators
-    pub validator_count: usize,
-    /// Minimum stake amount
-    pub min_stake: u64,
-}
-
-impl Default for ConsensusConfig {
-    fn default() -> Self {
-        Self {
-            algorithm: ConsensusAlgorithm::ProofOfStake,
-            block_time: Duration::from_secs(5),
-            validator_count: 21,
-            min_stake: 1000,
-        }
-    }
-}
-
-/// Consensus engine interface
-pub trait ConsensusEngine {
-    /// Start the consensus engine
-    fn start(&self) -> Result<(), String>;
-
-    /// Stop the consensus engine
-    fn stop(&self) -> Result<(), String>;
-
-    /// Check if the consensus engine is running
-    fn is_running(&self) -> bool;
-
-    /// Get the consensus configuration
-    fn config(&self) -> &ConsensusConfig;
-}
-
-/// Basic implementation of a consensus engine
-pub struct BasicConsensusEngine {
-    /// Configuration
-    config: ConsensusConfig,
-    /// Running status
-    running: bool,
-}
-
-impl BasicConsensusEngine {
-    /// Create a new basic consensus engine
-    pub fn new(config: ConsensusConfig) -> Self {
-        Self {
-            config,
-            running: false,
-        }
-    }
-}
-
-impl ConsensusEngine for BasicConsensusEngine {
-    fn start(&self) -> Result<(), String> {
-        // In a real implementation, this would start the consensus process
-        Ok(())
-    }
-
-    fn stop(&self) -> Result<(), String> {
-        // In a real implementation, this would stop the consensus process
-        Ok(())
-    }
-
-    fn is_running(&self) -> bool {
-        self.running
-    }
-
-    fn config(&self) -> &ConsensusConfig {
-        &self.config
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_consensus_config_default() {
-        let config = ConsensusConfig::default();
-        assert_eq!(config.algorithm, ConsensusAlgorithm::ProofOfStake);
-        assert_eq!(config.block_time, Duration::from_secs(5));
-        assert_eq!(config.validator_count, 21);
-        assert_eq!(config.min_stake, 1000);
-    }
-
-    #[test]
-    fn test_basic_consensus_engine() {
-        let config = ConsensusConfig::default();
-        let engine = BasicConsensusEngine::new(config);
-
-        assert!(!engine.is_running());
-        assert_eq!(engine.config().algorithm, ConsensusAlgorithm::ProofOfStake);
-
-        // Test start and stop
-        engine.start().unwrap();
-        engine.stop().unwrap();
-    }
-}
-```
-
-##### File: consensus/Cargo.toml
-##*Size: 4.0K, Lines: 16, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-consensus"
-version = "0.1.0"
-edition = "2021"
-description = "Consensus for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-bytes = { workspace = true }
-anyhow = { workspace = true }
-
-[features]
-default = []
-```
-
-#### Directory: core
-
-##### Directory: core/src
-
-###### Directory: core/src/app
-
-####### File: core/src/app/mod.rs
-####*Size: 4.0K, Lines: 46, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/app/mod.rs
-
-use crate::transaction::TransactionModel;
-use serde::{Deserialize, Serialize};
-
-#[derive(Serialize, Deserialize, Debug)]
-pub struct ChainStatus {
-    pub height: u64,
-    pub latest_timestamp: u64,
-    pub total_transactions: u64,
-    pub is_running: bool,
-}
-
-// FIX: Add derive(Clone, Debug). Clone is needed for block processing,
-// and Debug is needed for `.unwrap()` calls on Results containing the block.
-#[derive(Serialize, Deserialize, Debug, Clone)]
-pub struct Block<T> {
-    pub header: BlockHeader,
-    pub transactions: Vec<T>,
-}
-
-#[derive(Serialize, Deserialize, Debug, Clone)]
-pub struct BlockHeader {
-    pub height: u64,
-    pub prev_hash: Vec<u8>,
-    pub state_root: Vec<u8>,
-    pub transactions_root: Vec<u8>,
-    pub timestamp: u64,
-}
-
-#[derive(Debug)]
-pub enum ChainError {
-    Block(String),
-    Transaction(String),
-}
-
-/// A struct that holds the core, serializable state of a sovereign chain.
-/// This is distinct from its logic, which is defined by the `SovereignChain` trait.
-#[derive(Debug)]
-pub struct SovereignAppChain<CS, TM: TransactionModel> {
-    pub commitment_scheme: CS,
-    pub transaction_model: TM,
-    pub chain_id: String,
-    pub status: ChainStatus,
-    pub recent_blocks: Vec<Block<TM::Transaction>>,
-    pub max_recent_blocks: usize,
-}```
-
-###### Directory: core/src/chain
-
-####### File: core/src/chain/mod.rs
-####*Size: 4.0K, Lines: 40, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/chain/mod.rs
-
-use crate::app::{Block, ChainError, ChainStatus};
-use crate::commitment::CommitmentScheme;
-use crate::state::StateManager;
-use crate::transaction::TransactionModel;
-use crate::validator::WorkloadContainer;
-use async_trait::async_trait;
-use std::fmt::Debug;
-
-/// A trait that defines the logic and capabilities of a sovereign chain state machine.
-#[async_trait]
-pub trait SovereignChain<CS, TM, ST>: Debug + Send
-where
-    CS: CommitmentScheme,
-    TM: TransactionModel<CommitmentScheme = CS>,
-    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
-{
-    fn status(&self) -> &ChainStatus;
-    fn transaction_model(&self) -> &TM;
-
-    async fn process_transaction(
-        &mut self,
-        tx: &TM::Transaction,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError>;
-
-    async fn process_block(
-        &mut self,
-        block: Block<TM::Transaction>,
-        workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError>;
-
-    fn create_block(
-        &self,
-        transactions: Vec<TM::Transaction>,
-        workload: &WorkloadContainer<ST>,
-    ) -> Block<TM::Transaction>;
-
-    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>>;
-}```
-
-###### Directory: core/src/commitment
-
-####### Directory: core/src/commitment/tests
-
-######## File: core/src/commitment/tests/commitment_tests.rs
-#####*Size: 8.0K, Lines: 205, Type: ASCII text*
-
-```rust
-//! Tests for the commitment scheme traits
-
-#[cfg(test)]
-mod tests {
-    use crate::commitment::{
-        CommitmentScheme, HomomorphicCommitmentScheme, HomomorphicOperation, ProofContext,
-        SchemeIdentifier, Selector,
-    };
-
-    // Define a mock commitment scheme for testing
-    #[derive(Debug)]
-    struct MockCommitmentScheme;
-
-    #[derive(Debug, Clone)]
-    struct MockCommitment(Vec<u8>);
-
-    impl AsRef<[u8]> for MockCommitment {
-        fn as_ref(&self) -> &[u8] {
-            &self.0
-        }
-    }
-
-    #[derive(Clone)]
-    struct MockProof(Vec<u8>);
-
-    impl CommitmentScheme for MockCommitmentScheme {
-        type Commitment = MockCommitment;
-        type Proof = MockProof;
-        type Value = Vec<u8>; // Added missing Value associated type
-
-        fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-            // Simple mock implementation for testing
-            let combined: Vec<u8> = values
-                .iter()
-                .flat_map(|v| v.clone().unwrap_or_default())
-                .collect();
-            MockCommitment(combined)
-        }
-
-        fn create_proof(
-            &self,
-            selector: &Selector,
-            value: &Self::Value,
-        ) -> Result<Self::Proof, String> {
-            // Simple mock implementation for testing
-            Ok(MockProof(value.clone()))
-        }
-
-        fn verify(
-            &self,
-            _commitment: &Self::Commitment,
-            proof: &Self::Proof,
-            _selector: &Selector,
-            value: &Self::Value,
-            _context: &ProofContext, // Added context parameter
-        ) -> bool {
-            // Simple mock implementation for testing
-            proof.0 == *value
-        }
-
-        fn scheme_id() -> SchemeIdentifier {
-            SchemeIdentifier::new("mock")
-        }
-    }
-
-    #[derive(Debug)]
-    struct MockHomomorphicCommitmentScheme;
-
-    impl CommitmentScheme for MockHomomorphicCommitmentScheme {
-        type Commitment = MockCommitment;
-        type Proof = MockProof;
-        type Value = Vec<u8>; // Added missing Value associated type
-
-        fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-            // Simple mock implementation for testing
-            let combined: Vec<u8> = values
-                .iter()
-                .flat_map(|v| v.clone().unwrap_or_default())
-                .collect();
-            MockCommitment(combined)
-        }
-
-        fn create_proof(
-            &self,
-            selector: &Selector,
-            value: &Self::Value,
-        ) -> Result<Self::Proof, String> {
-            // Simple mock implementation for testing
-            Ok(MockProof(value.clone()))
-        }
-
-        fn verify(
-            &self,
-            _commitment: &Self::Commitment,
-            proof: &Self::Proof,
-            _selector: &Selector,
-            value: &Self::Value,
-            _context: &ProofContext, // Added context parameter
-        ) -> bool {
-            // Simple mock implementation for testing
-            proof.0 == *value
-        }
-
-        fn scheme_id() -> SchemeIdentifier {
-            SchemeIdentifier::new("mock-homomorphic")
-        }
-    }
-
-    impl HomomorphicCommitmentScheme for MockHomomorphicCommitmentScheme {
-        fn add(
-            &self,
-            a: &Self::Commitment,
-            b: &Self::Commitment,
-        ) -> Result<Self::Commitment, String> {
-            // Simple mock implementation for testing
-            let mut result = a.0.clone();
-            result.extend_from_slice(&b.0);
-            Ok(MockCommitment(result))
-        }
-
-        fn scalar_multiply(
-            &self,
-            a: &Self::Commitment,
-            scalar: i32,
-        ) -> Result<Self::Commitment, String> {
-            // Simple mock implementation for testing
-            if scalar <= 0 {
-                return Err("Scalar must be positive".to_string());
-            }
-
-            let mut result = Vec::new();
-            for _ in 0..scalar {
-                result.extend_from_slice(a.as_ref());
-            }
-
-            Ok(MockCommitment(result))
-        }
-
-        fn supports_operation(&self, operation: HomomorphicOperation) -> bool {
-            // Simple mock implementation for testing
-            match operation {
-                HomomorphicOperation::Addition | HomomorphicOperation::ScalarMultiplication => true,
-                HomomorphicOperation::Custom(_) => false,
-            }
-        }
-    }
-
-    #[test]
-    fn test_commitment_scheme() {
-        let scheme = MockCommitmentScheme;
-
-        // Test commit
-        let values = vec![Some(vec![1, 2, 3]), Some(vec![4, 5, 6])];
-        let commitment = scheme.commit(&values);
-
-        // Test create_proof
-        let proof = scheme
-            .create_proof(&Selector::Position(0), &vec![1, 2, 3])
-            .unwrap();
-
-        // Test verify
-        let context = ProofContext::default();
-        assert!(scheme.verify(
-            &commitment,
-            &proof,
-            &Selector::Position(0),
-            &vec![1, 2, 3],
-            &context
-        ));
-        assert!(!scheme.verify(
-            &commitment,
-            &proof,
-            &Selector::Position(0),
-            &vec![7, 8, 9],
-            &context
-        ));
-
-        // Test scheme_id
-        assert_eq!(MockCommitmentScheme::scheme_id().0, "mock");
-    }
-
-    #[test]
-    fn test_homomorphic_commitment_scheme() {
-        let scheme = MockHomomorphicCommitmentScheme;
-
-        // Test commit
-        let values1 = vec![Some(vec![1, 2, 3])];
-        let values2 = vec![Some(vec![4, 5, 6])];
-        let commitment1 = scheme.commit(&values1);
-        let commitment2 = scheme.commit(&values2);
-
-        // Test add
-        let sum = scheme.add(&commitment1, &commitment2).unwrap();
-        assert_eq!(sum.0, vec![1, 2, 3, 4, 5, 6]);
-
-        // Test scalar_multiply
-        let product = scheme.scalar_multiply(&commitment1, 3).unwrap();
-        assert_eq!(product.0, vec![1, 2, 3, 1, 2, 3, 1, 2, 3]);
-
-        // Test supports_operation
-        assert!(scheme.supports_operation(HomomorphicOperation::Addition));
-        assert!(scheme.supports_operation(HomomorphicOperation::ScalarMultiplication));
-        assert!(!scheme.supports_operation(HomomorphicOperation::Custom(42)));
-    }
-}
-```
-
-######## File: core/src/commitment/tests/mod.rs
-#####*Size: 4.0K, Lines: 3, Type: ASCII text*
-
-```rust
-//! Tests for commitment scheme traits
-
-mod commitment_tests;
-```
-
-####### File: core/src/commitment/homomorphic.rs
-####*Size: 4.0K, Lines: 25, Type: ASCII text*
-
-```rust
-// File: crates/core/src/commitment/homomorphic.rs
-
-use crate::commitment::scheme::CommitmentScheme;
-
-/// Type of homomorphic operation supported
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum HomomorphicOperation {
-    /// Addition of two commitments
-    Addition,
-    /// Scalar multiplication
-    ScalarMultiplication,
-    /// Custom operation
-    Custom(u32),
-}
-
-/// Extended trait for commitment schemes supporting homomorphic operations
-pub trait HomomorphicCommitmentScheme: CommitmentScheme {
-    /// Add two commitments
-    fn add(&self, a: &Self::Commitment, b: &Self::Commitment) -> Result<Self::Commitment, String>;
-    
-    /// Multiply a commitment by a scalar
-    fn scalar_multiply(&self, a: &Self::Commitment, scalar: i32) -> Result<Self::Commitment, String>;
-    
-    /// Check if this commitment scheme supports specific homomorphic operations
-    fn supports_operation(&self, operation: HomomorphicOperation) -> bool;
-}```
-
-####### File: core/src/commitment/identifiers.rs
-####*Size: 4.0K, Lines: 12, Type: ASCII text*
-
-```rust
-//! Scheme identifier definitions for different commitment types
-
-/// Identifier for commitment schemes
-#[derive(Debug, Clone, PartialEq, Eq, Hash)]
-pub struct SchemeIdentifier(pub String);
-
-impl SchemeIdentifier {
-    /// Create a new scheme identifier
-    pub fn new(value: &str) -> Self {
-        Self(value.to_string())
-    }
-}
-```
-
-####### File: core/src/commitment/mod.rs
-####*Size: 4.0K, Lines: 12, Type: ASCII text*
-
-```rust
-//! Commitment scheme trait definitions
-
-mod scheme;
-mod homomorphic;
-mod identifiers;
-
-#[cfg(test)]
-mod tests;
-
-pub use scheme::*;
-pub use homomorphic::*;
-pub use identifiers::*;
-```
-
-####### File: core/src/commitment/scheme.rs
-####*Size: 4.0K, Lines: 123, Type: ASCII text*
-
-```rust
-// File: crates/core/src/commitment/scheme.rs
-
-use std::fmt::Debug;
-use crate::commitment::identifiers::SchemeIdentifier;
-use std::collections::HashMap;
-
-/// Selector for addressing elements in a commitment
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum Selector {
-    /// Index-based position (for ordered commitments like Merkle trees)
-    Position(usize),
-    /// Key-based selector (for map-like commitments)
-    Key(Vec<u8>),
-    /// Predicate-based selector (for advanced schemes)
-    Predicate(Vec<u8>), // Serialized predicate
-    /// No selector (for single-value commitments)
-    None,
-}
-
-/// Context for proof verification
-#[derive(Debug, Clone, Default)]
-pub struct ProofContext {
-    /// Additional data for verification
-    pub data: HashMap<String, Vec<u8>>,
-}
-
-impl ProofContext {
-    /// Create a new empty proof context
-    pub fn new() -> Self {
-        Self {
-            data: HashMap::new(),
-        }
-    }
-
-    /// Add data to the context
-    pub fn add_data(&mut self, key: &str, value: Vec<u8>) {
-        self.data.insert(key.to_string(), value);
-    }
-
-    /// Get data from the context
-    pub fn get_data(&self, key: &str) -> Option<&Vec<u8>> {
-        self.data.get(key)
-    }
-}
-
-/// Core trait for all commitment schemes
-pub trait CommitmentScheme: Debug + Send + Sync + 'static {
-    /// The type of commitment produced
-    type Commitment: AsRef<[u8]> + Clone + Send + Sync + 'static;
-
-    /// The type of proof for this commitment scheme
-    type Proof: Clone + Send + Sync + 'static;
-
-    /// The type of values this scheme commits to
-    type Value: AsRef<[u8]> + Clone + Send + Sync + 'static;
-
-    /// Commit to a vector of values
-    fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment;
-
-    /// Create a proof for a specific selector and value
-    fn create_proof(&self, selector: &Selector, value: &Self::Value)
-        -> Result<Self::Proof, String>;
-
-    /// Verify a proof against a commitment
-    fn verify(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        selector: &Selector,
-        value: &Self::Value,
-        context: &ProofContext,
-    ) -> bool;
-
-    /// Get scheme identifier
-    fn scheme_id() -> SchemeIdentifier;
-
-    /// Create a position-based proof (convenience method)
-    fn create_proof_at_position(
-        &self,
-        position: usize,
-        value: &Self::Value,
-    ) -> Result<Self::Proof, String> {
-        self.create_proof(&Selector::Position(position), value)
-    }
-
-    /// Create a key-based proof (convenience method)
-    fn create_proof_for_key(&self, key: &[u8], value: &Self::Value) -> Result<Self::Proof, String> {
-        self.create_proof(&Selector::Key(key.to_vec()), value)
-    }
-
-    /// Verify a position-based proof (convenience method)
-    fn verify_at_position(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        position: usize,
-        value: &Self::Value,
-    ) -> bool {
-        self.verify(
-            commitment,
-            proof,
-            &Selector::Position(position),
-            value,
-            &ProofContext::default(),
-        )
-    }
-
-    /// Verify a key-based proof (convenience method)
-    fn verify_for_key(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &Self::Value,
-    ) -> bool {
-        self.verify(
-            commitment,
-            proof,
-            &Selector::Key(key.to_vec()),
-            value,
-            &ProofContext::default(),
-        )
-    }
-}```
-
-###### Directory: core/src/component
-
-####### Directory: core/src/component/tests
-
-######## File: core/src/component/tests/mod.rs
-#####*Size: 4.0K, Lines: 58, Type: ASCII text*
-
-```rust
-//! Tests for the component classification system
-
-// Change module definition to avoid "tests::tests" inception
-#[cfg(test)]
-mod component_tests {
-    use crate::component::{
-        Adaptable, AdaptableComponent, ClassifiedComponent, ComponentClassification, Extensible,
-        ExtensibleComponent, Fixed, FixedComponent,
-    };
-
-    // Test struct implementing Fixed trait
-    struct TestFixedComponent;
-    impl Fixed for TestFixedComponent {}
-
-    // Test struct implementing Adaptable trait
-    struct TestAdaptableComponent;
-    impl Adaptable for TestAdaptableComponent {}
-
-    // Test struct implementing Extensible trait
-    struct TestExtensibleComponent;
-    impl Extensible for TestExtensibleComponent {}
-
-    #[test]
-    fn test_fixed_component() {
-        let component = FixedComponent;
-        assert_eq!(component.classification(), ComponentClassification::Fixed);
-        assert!(!component.can_modify());
-        assert!(!component.can_extend());
-    }
-
-    #[test]
-    fn test_adaptable_component() {
-        let component = AdaptableComponent;
-        assert_eq!(
-            component.classification(),
-            ComponentClassification::Adaptable
-        );
-        assert!(component.can_modify());
-        assert!(!component.can_extend());
-    }
-
-    #[test]
-    fn test_extensible_component() {
-        let component = ExtensibleComponent;
-        assert_eq!(
-            component.classification(),
-            ComponentClassification::Extensible
-        );
-        assert!(component.can_modify());
-        assert!(component.can_extend());
-    }
-
-    // TODO: Add more comprehensive tests covering:
-    // - Custom components with the classification system
-    // - Component compatibility checks
-    // - Classification inheritance
-    // - Component composition with mixed classifications
-}
-```
-
-####### File: core/src/component/classification.rs
-####*Size: 4.0K, Lines: 74, Type: ASCII text*
-
-```rust
-//! Fixed/Adaptable/Extensible classification definitions
-
-/// Component classification
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum ComponentClassification {
-    /// Fixed component - cannot be modified
-    Fixed,
-    
-    /// Adaptable component - can be parameterized within defined bounds
-    Adaptable,
-    
-    /// Extensible component - can be fully customized
-    Extensible,
-}
-
-/// Component with classification
-pub trait ClassifiedComponent {
-    /// Get the component classification
-    fn classification(&self) -> ComponentClassification;
-    
-    /// Check if the component can be modified
-    fn can_modify(&self) -> bool {
-        match self.classification() {
-            ComponentClassification::Fixed => false,
-            ComponentClassification::Adaptable | ComponentClassification::Extensible => true,
-        }
-    }
-    
-    /// Check if the component can be extended
-    fn can_extend(&self) -> bool {
-        match self.classification() {
-            ComponentClassification::Fixed | ComponentClassification::Adaptable => false,
-            ComponentClassification::Extensible => true,
-        }
-    }
-}
-
-/// Marker trait for fixed components
-pub trait Fixed {}
-
-/// Marker trait for adaptable components
-pub trait Adaptable {}
-
-/// Marker trait for extensible components
-pub trait Extensible {}
-
-// Instead of blanket implementations, we'll provide implementation helpers
-
-/// Helper struct for fixed components
-pub struct FixedComponent;
-
-impl ClassifiedComponent for FixedComponent {
-    fn classification(&self) -> ComponentClassification {
-        ComponentClassification::Fixed
-    }
-}
-
-/// Helper struct for adaptable components
-pub struct AdaptableComponent;
-
-impl ClassifiedComponent for AdaptableComponent {
-    fn classification(&self) -> ComponentClassification {
-        ComponentClassification::Adaptable
-    }
-}
-
-/// Helper struct for extensible components
-pub struct ExtensibleComponent;
-
-impl ClassifiedComponent for ExtensibleComponent {
-    fn classification(&self) -> ComponentClassification {
-        ComponentClassification::Extensible
-    }
-}
-```
-
-####### File: core/src/component/mod.rs
-####*Size: 4.0K, Lines: 8, Type: ASCII text*
-
-```rust
-//! Component classification system
-
-mod classification;
-
-#[cfg(test)]
-mod tests;
-
-pub use classification::*;
-```
-
-###### Directory: core/src/config
-
-####### File: core/src/config/mod.rs
-####*Size: 4.0K, Lines: 11, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/config/mod.rs
-
-//! Shared configuration structures for core DePIN SDK components.
-
-use serde::Deserialize;
-
-/// Configuration for the Workload container (`workload.toml`).
-/// This is defined in `core` because it's part of the public `WorkloadContainer` struct.
-#[derive(Debug, Deserialize, Clone)]
-pub struct WorkloadConfig {
-    pub enabled_vms: Vec<String>,
-}```
-
-###### Directory: core/src/crypto
-
-####### Directory: core/src/crypto/tests
-
-######## File: core/src/crypto/tests/mod.rs
-#####*Size: 12K, Lines: 308, Type: ASCII text*
-
-```rust
-//! Tests for cryptographic primitive interfaces
-
-use crate::crypto::{
-        DecapsulationKey, Encapsulated, EncapsulationKey, KemKeyPair, KeyEncapsulation,
-        SerializableKey, Signature, SigningKey, SigningKeyPair, VerifyingKey,
-    };
-    use std::vec::Vec;
-
-    // ============================================================================
-    // Mock implementations for signature algorithms
-    // ============================================================================
-    
-    struct MockSigningKeyPair;
-    struct MockVerifyingKey(Vec<u8>);
-    struct MockSigningKey(Vec<u8>);
-    struct MockSignature(Vec<u8>);
-
-    impl SigningKeyPair for MockSigningKeyPair {
-        type PublicKey = MockVerifyingKey;
-        type PrivateKey = MockSigningKey;
-        type Signature = MockSignature;
-
-        fn public_key(&self) -> Self::PublicKey {
-            MockVerifyingKey(vec![1, 2, 3])
-        }
-
-        fn private_key(&self) -> Self::PrivateKey {
-            MockSigningKey(vec![4, 5, 6])
-        }
-
-        fn sign(&self, message: &[u8]) -> Self::Signature {
-            MockSignature(message.to_vec())
-        }
-    }
-
-    impl SerializableKey for MockVerifyingKey {
-        fn to_bytes(&self) -> Vec<u8> {
-            self.0.clone()
-        }
-
-        fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-            Ok(MockVerifyingKey(bytes.to_vec()))
-        }
-    }
-
-    impl VerifyingKey for MockVerifyingKey {
-        type Signature = MockSignature;
-
-        fn verify(&self, message: &[u8], signature: &Self::Signature) -> bool {
-            message == signature.0
-        }
-    }
-
-    impl SerializableKey for MockSigningKey {
-        fn to_bytes(&self) -> Vec<u8> {
-            self.0.clone()
-        }
-
-        fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-            Ok(MockSigningKey(bytes.to_vec()))
-        }
-    }
-
-    impl SigningKey for MockSigningKey {
-        type Signature = MockSignature;
-
-        fn sign(&self, message: &[u8]) -> Self::Signature {
-            MockSignature(message.to_vec())
-        }
-    }
-
-    impl SerializableKey for MockSignature {
-        fn to_bytes(&self) -> Vec<u8> {
-            self.0.clone()
-        }
-
-        fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-            Ok(MockSignature(bytes.to_vec()))
-        }
-    }
-
-    impl Signature for MockSignature {}
-
-    // ============================================================================
-    // Mock implementations for KEM algorithms
-    // ============================================================================
-
-    struct MockKemKeyPair;
-    struct MockEncapsulationKey(Vec<u8>);
-    struct MockDecapsulationKey(Vec<u8>);
-    struct MockEncapsulated {
-        ciphertext: Vec<u8>,
-        shared_secret: Vec<u8>,
-    }
-
-    impl KemKeyPair for MockKemKeyPair {
-        type PublicKey = MockEncapsulationKey;
-        type PrivateKey = MockDecapsulationKey;
-
-        fn public_key(&self) -> Self::PublicKey {
-            MockEncapsulationKey(vec![7, 8, 9])
-        }
-
-        fn private_key(&self) -> Self::PrivateKey {
-            MockDecapsulationKey(vec![10, 11, 12])
-        }
-    }
-
-    impl SerializableKey for MockEncapsulationKey {
-        fn to_bytes(&self) -> Vec<u8> {
-            self.0.clone()
-        }
-
-        fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-            Ok(MockEncapsulationKey(bytes.to_vec()))
-        }
-    }
-
-    impl EncapsulationKey for MockEncapsulationKey {}
-
-    impl SerializableKey for MockDecapsulationKey {
-        fn to_bytes(&self) -> Vec<u8> {
-            self.0.clone()
-        }
-
-        fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-            Ok(MockDecapsulationKey(bytes.to_vec()))
-        }
-    }
-
-    impl DecapsulationKey for MockDecapsulationKey {}
-
-    impl SerializableKey for MockEncapsulated {
-        fn to_bytes(&self) -> Vec<u8> {
-            let mut bytes = Vec::new();
-            bytes.extend_from_slice(&self.ciphertext);
-            bytes
-        }
-
-        fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-            Ok(MockEncapsulated {
-                ciphertext: bytes.to_vec(),
-                shared_secret: vec![0; 32],
-            })
-        }
-    }
-
-    impl Encapsulated for MockEncapsulated {
-        fn ciphertext(&self) -> &[u8] {
-            &self.ciphertext
-        }
-
-        fn shared_secret(&self) -> &[u8] {
-            &self.shared_secret
-        }
-    }
-
-    struct MockKEM;
-
-    impl KeyEncapsulation for MockKEM {
-        type KeyPair = MockKemKeyPair;
-        type PublicKey = MockEncapsulationKey;
-        type PrivateKey = MockDecapsulationKey;
-        type Encapsulated = MockEncapsulated;
-
-        fn generate_keypair(&self) -> Self::KeyPair {
-            MockKemKeyPair
-        }
-
-        fn encapsulate(&self, _public_key: &Self::PublicKey) -> Self::Encapsulated {
-            MockEncapsulated {
-                ciphertext: vec![7, 8, 9],
-                shared_secret: vec![0; 32],
-            }
-        }
-
-        fn decapsulate(
-            &self,
-            _private_key: &Self::PrivateKey,
-            _encapsulated: &Self::Encapsulated,
-        ) -> Option<Vec<u8>> {
-            Some(vec![0; 32])
-        }
-    }
-
-    // ============================================================================
-    // Tests
-    // ============================================================================
-
-    #[test]
-    fn test_signing_operations() {
-        let keypair = MockSigningKeyPair;
-        let message = b"test message";
-
-        // Test signing
-        let signature = keypair.sign(message);
-        let public_key = keypair.public_key();
-
-        // Test verification
-        assert!(public_key.verify(message, &signature));
-
-        // Test verification with wrong message
-        let wrong_message = b"wrong message";
-        assert!(!public_key.verify(wrong_message, &signature));
-    }
-
-    #[test]
-    fn test_signing_key_serialization() {
-        let keypair = MockSigningKeyPair;
-        let public_key = keypair.public_key();
-        let private_key = keypair.private_key();
-
-        // Test public key serialization
-        let pk_bytes = public_key.to_bytes();
-        let pk_recovered = MockVerifyingKey::from_bytes(&pk_bytes).unwrap();
-        assert_eq!(pk_bytes, pk_recovered.to_bytes());
-
-        // Test private key serialization
-        let sk_bytes = private_key.to_bytes();
-        let sk_recovered = MockSigningKey::from_bytes(&sk_bytes).unwrap();
-        assert_eq!(sk_bytes, sk_recovered.to_bytes());
-    }
-
-    #[test]
-    fn test_signature_serialization() {
-        let keypair = MockSigningKeyPair;
-        let message = b"test message";
-        let signature = keypair.sign(message);
-
-        // Test signature serialization
-        let sig_bytes = signature.to_bytes();
-        let sig_recovered = MockSignature::from_bytes(&sig_bytes).unwrap();
-        assert_eq!(sig_bytes, sig_recovered.to_bytes());
-    }
-
-    #[test]
-    fn test_kem_operations() {
-        let kem = MockKEM;
-        let keypair = kem.generate_keypair();
-        let public_key = keypair.public_key();
-        let private_key = keypair.private_key();
-
-        // Test encapsulation
-        let encapsulated = kem.encapsulate(&public_key);
-        
-        // Test decapsulation
-        let shared_secret = kem.decapsulate(&private_key, &encapsulated);
-        assert!(shared_secret.is_some());
-        assert_eq!(shared_secret.unwrap().len(), 32);
-    }
-
-    #[test]
-    fn test_kem_key_serialization() {
-        let kem = MockKEM;
-        let keypair = kem.generate_keypair();
-        let public_key = keypair.public_key();
-        let private_key = keypair.private_key();
-
-        // Test public key serialization
-        let pk_bytes = public_key.to_bytes();
-        let pk_recovered = MockEncapsulationKey::from_bytes(&pk_bytes).unwrap();
-        assert_eq!(pk_bytes, pk_recovered.to_bytes());
-
-        // Test private key serialization
-        let sk_bytes = private_key.to_bytes();
-        let sk_recovered = MockDecapsulationKey::from_bytes(&sk_bytes).unwrap();
-        assert_eq!(sk_bytes, sk_recovered.to_bytes());
-    }
-
-    #[test]
-    fn test_encapsulated_serialization() {
-        let kem = MockKEM;
-        let keypair = kem.generate_keypair();
-        let public_key = keypair.public_key();
-        let encapsulated = kem.encapsulate(&public_key);
-
-        // Test encapsulated data serialization
-        let enc_bytes = encapsulated.to_bytes();
-        let enc_recovered = MockEncapsulated::from_bytes(&enc_bytes).unwrap();
-        assert_eq!(enc_bytes, enc_recovered.to_bytes());
-    }
-
-    #[test]
-    fn test_independent_signing() {
-        // Test that signing keys can be used independently
-        let signing_key = MockSigningKey(vec![1, 2, 3, 4]);
-        let message = b"test message";
-        
-        let signature = signing_key.sign(message);
-        assert_eq!(signature.0, message.to_vec());
-    }
-
-    #[test]
-    fn test_independent_verification() {
-        // Test that verifying keys can be used independently
-        let verifying_key = MockVerifyingKey(vec![5, 6, 7, 8]);
-        let message = b"test message";
-        let signature = MockSignature(message.to_vec());
-        
-        assert!(verifying_key.verify(message, &signature));
-        assert!(!verifying_key.verify(b"wrong message", &signature));
-    }
-
-    // TODO: Add more comprehensive tests covering:
-    // - Post-quantum algorithm interfaces
-    // - Mixed cryptographic operations
-    // - Security level assertions
-    // - Error cases in serialization/deserialization
-    // - Cross-compatibility between different implementations```
-
-####### File: core/src/crypto/mod.rs
-####*Size: 4.0K, Lines: 137, Type: ASCII text*
-
-```rust
-// core/src/crypto/mod.rs
-//! Cryptographic primitive interfaces
-//!
-//! This module provides trait definitions for both traditional and
-//! post-quantum cryptographic primitives, creating a unified interface
-//! for all cryptographic implementations.
-
-// ============================================================================
-// Common traits for all key types
-// ============================================================================
-
-/// Base trait for any key that can be serialized
-pub trait SerializableKey {
-    /// Convert to bytes
-    fn to_bytes(&self) -> Vec<u8>;
-
-    /// Create from bytes
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String>
-    where
-        Self: Sized;
-}
-
-// ============================================================================
-// Signature-specific traits
-// ============================================================================
-
-/// Key pair trait for signature algorithms
-pub trait SigningKeyPair {
-    /// Public key type for verification
-    type PublicKey: VerifyingKey<Signature = Self::Signature>;
-
-    /// Private key type for signing
-    type PrivateKey: SigningKey<Signature = Self::Signature>;
-
-    /// Signature type produced
-    type Signature: Signature;
-
-    /// Get the public key
-    fn public_key(&self) -> Self::PublicKey;
-
-    /// Get the private key
-    fn private_key(&self) -> Self::PrivateKey;
-
-    /// Sign a message
-    fn sign(&self, message: &[u8]) -> Self::Signature;
-}
-
-/// Public key trait for signature verification
-pub trait VerifyingKey: SerializableKey {
-    /// Signature type that this key can verify
-    type Signature: Signature;
-
-    /// Verify a signature
-    fn verify(&self, message: &[u8], signature: &Self::Signature) -> bool;
-}
-
-/// Private key trait for signing operations
-pub trait SigningKey: SerializableKey {
-    /// Signature type that this key produces
-    type Signature: Signature;
-
-    /// Sign a message
-    fn sign(&self, message: &[u8]) -> Self::Signature;
-}
-
-/// Signature trait
-pub trait Signature: SerializableKey {
-    // Signature-specific methods could go here
-}
-
-// ============================================================================
-// KEM-specific traits
-// ============================================================================
-
-/// Key pair trait for key encapsulation mechanisms
-pub trait KemKeyPair {
-    /// Public key type for encapsulation
-    type PublicKey: EncapsulationKey;
-
-    /// Private key type for decapsulation
-    type PrivateKey: DecapsulationKey;
-
-    /// Get the public key
-    fn public_key(&self) -> Self::PublicKey;
-
-    /// Get the private key
-    fn private_key(&self) -> Self::PrivateKey;
-}
-
-/// Public key trait for encapsulation
-pub trait EncapsulationKey: SerializableKey {
-    // Encapsulation-specific methods could go here
-}
-
-/// Private key trait for decapsulation
-pub trait DecapsulationKey: SerializableKey {
-    // Decapsulation-specific methods could go here
-}
-
-/// Key encapsulation mechanism trait
-pub trait KeyEncapsulation {
-    /// Key pair type
-    type KeyPair: KemKeyPair<PublicKey = Self::PublicKey, PrivateKey = Self::PrivateKey>;
-
-    /// Public key type
-    type PublicKey: EncapsulationKey;
-
-    /// Private key type
-    type PrivateKey: DecapsulationKey;
-
-    /// Encapsulated key type
-    type Encapsulated: Encapsulated;
-
-    /// Generate a new key pair
-    fn generate_keypair(&self) -> Self::KeyPair;
-
-    /// Encapsulate a shared secret using a public key
-    fn encapsulate(&self, public_key: &Self::PublicKey) -> Self::Encapsulated;
-
-    /// Decapsulate a shared secret using a private key
-    fn decapsulate(
-        &self,
-        private_key: &Self::PrivateKey,
-        encapsulated: &Self::Encapsulated,
-    ) -> Option<Vec<u8>>;
-}
-
-/// Encapsulated key trait
-pub trait Encapsulated: SerializableKey {
-    /// Get the ciphertext
-    fn ciphertext(&self) -> &[u8];
-
-    /// Get the shared secret
-    fn shared_secret(&self) -> &[u8];
-}
-
-#[cfg(test)]
-mod tests;```
-
-###### Directory: core/src/error
-
-####### File: core/src/error/mod.rs
-####*Size: 4.0K, Lines: 56, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/error/mod.rs
-
-use thiserror::Error;
-
-#[derive(Error, Debug)]
-pub enum StateError {
-    #[error("Key not found: {0}")]
-    KeyNotFound(String),
-    #[error("Validation failed: {0}")]
-    Validation(String),
-    #[error("Apply failed: {0}")]
-    Apply(String),
-    #[error("State backend error: {0}")]
-    Backend(String),
-    // FIX: Add variants for errors that occur in state tree implementations.
-    // The `WriteError` is used by `FileStateTree` when file I/O fails.
-    // The `InvalidValue` is used by `VerkleTree` when a value can't be converted.
-    #[error("State write error: {0}")]
-    WriteError(String),
-    #[error("Invalid value: {0}")]
-    InvalidValue(String),
-}
-
-#[derive(Error, Debug)]
-pub enum TransactionError {
-    #[error("Serialization error: {0}")]
-    Serialization(String),
-    #[error("Deserialization error: {0}")]
-    Deserialization(String),
-    #[error("Invalid transaction: {0}")]
-    Invalid(String),
-    // FIX: Add a variant to wrap StateErrors, which will allow `?` to work.
-    #[error("State error: {0}")]
-    State(#[from] StateError),
-}
-
-#[derive(Error, Debug)]
-pub enum ValidatorError {
-    #[error("Container '{0}' is already running")]
-    AlreadyRunning(String),
-    #[error("IO error: {0}")]
-    Io(#[from] std::io::Error),
-    #[error("Configuration error: {0}")]
-    Config(String),
-    #[error("Other error: {0}")]
-    Other(String),
-}
-
-#[derive(Debug, Error)]
-pub enum CoreError {
-    #[error("Service not found: {0}")]
-    ServiceNotFound(String),
-    #[error("Upgrade error: {0}")]
-    UpgradeError(String),
-    #[error("Custom error: {0}")]
-    Custom(String),
-}```
-
-###### Directory: core/src/homomorphic
-
-####### Directory: core/src/homomorphic/tests
-
-######## File: core/src/homomorphic/tests/homorphic_operation_interfaces_tests.rs
-#####*Size: 8.0K, Lines: 165, Type: ASCII text*
-
-```rust
-//! Tests for homomorphic operation interfaces
-
-#[cfg(test)]
-mod tests {
-    use crate::homomorphic::{CommitmentOperation, OperationResult};
-    use std::any::Any;
-    use std::sync::Arc;
-
-    // Simple mock structs for testing
-    #[derive(Clone)]
-    struct MockCommitment(Vec<u8>);
-
-    impl MockCommitment {
-        fn new(value: u8) -> Self {
-            Self(vec![value])
-        }
-
-        fn value(&self) -> u8 {
-            self.0[0]
-        }
-    }
-
-    // Mock implementation of an operation executor
-    struct MockOperationExecutor;
-
-    impl MockOperationExecutor {
-        fn execute(&self, operation: &CommitmentOperation) -> OperationResult {
-            match operation {
-                CommitmentOperation::Add { left, right } => {
-                    let left_commitment = match left.downcast_ref::<MockCommitment>() {
-                        Some(c) => c,
-                        None => {
-                            return OperationResult::Failure(
-                                "Left operand is not a MockCommitment".to_string(),
-                            )
-                        }
-                    };
-
-                    let right_commitment = match right.downcast_ref::<MockCommitment>() {
-                        Some(c) => c,
-                        None => {
-                            return OperationResult::Failure(
-                                "Right operand is not a MockCommitment".to_string(),
-                            )
-                        }
-                    };
-
-                    let result =
-                        MockCommitment::new(left_commitment.value() + right_commitment.value());
-                    OperationResult::Success(Arc::new(result))
-                }
-                CommitmentOperation::ScalarMultiply { commitment, scalar } => {
-                    let commitment = match commitment.downcast_ref::<MockCommitment>() {
-                        Some(c) => c,
-                        None => {
-                            return OperationResult::Failure(
-                                "Commitment is not a MockCommitment".to_string(),
-                            )
-                        }
-                    };
-
-                    if *scalar <= 0 {
-                        return OperationResult::Failure("Scalar must be positive".to_string());
-                    }
-
-                    let result = MockCommitment::new(commitment.value() * (*scalar as u8));
-                    OperationResult::Success(Arc::new(result))
-                }
-                CommitmentOperation::Custom {
-                    operation_id: _,
-                    inputs: _,
-                    parameters: _,
-                } => {
-                    // Just a placeholder for custom operations
-                    OperationResult::Unsupported
-                }
-            }
-        }
-    }
-
-    #[test]
-    fn test_add_operation() {
-        let executor = MockOperationExecutor;
-
-        let left = Arc::new(MockCommitment::new(5));
-        let right = Arc::new(MockCommitment::new(7));
-
-        let operation = CommitmentOperation::Add { left, right };
-        let result = executor.execute(&operation);
-
-        match result {
-            OperationResult::Success(result_arc) => {
-                let result_commitment = result_arc.downcast_ref::<MockCommitment>().unwrap();
-                assert_eq!(result_commitment.value(), 12);
-            }
-            _ => panic!("Operation failed or unsupported"),
-        }
-    }
-
-    #[test]
-    fn test_scalar_multiply_operation() {
-        let executor = MockOperationExecutor;
-
-        let commitment = Arc::new(MockCommitment::new(5));
-        let scalar = 3;
-
-        let operation = CommitmentOperation::ScalarMultiply { commitment, scalar };
-        let result = executor.execute(&operation);
-
-        match result {
-            OperationResult::Success(result_arc) => {
-                let result_commitment = result_arc.downcast_ref::<MockCommitment>().unwrap();
-                assert_eq!(result_commitment.value(), 15);
-            }
-            _ => panic!("Operation failed or unsupported"),
-        }
-    }
-
-    #[test]
-    fn test_custom_operation() {
-        let executor = MockOperationExecutor;
-
-        let inputs = vec![Arc::new(MockCommitment::new(5)) as Arc<dyn Any + Send + Sync>];
-        let parameters = vec![0, 1, 2];
-
-        let operation = CommitmentOperation::Custom {
-            operation_id: "test_op".to_string(),
-            inputs,
-            parameters,
-        };
-
-        let result = executor.execute(&operation);
-
-        match result {
-            OperationResult::Unsupported => {
-                // Expected behavior for this test
-            }
-            _ => panic!("Custom operation should return Unsupported in this test"),
-        }
-    }
-
-    #[test]
-    fn test_operation_failure() {
-        let executor = MockOperationExecutor;
-
-        let commitment = Arc::new(MockCommitment::new(5));
-        let scalar = -1; // Negative scalar should cause failure
-
-        let operation = CommitmentOperation::ScalarMultiply { commitment, scalar };
-        let result = executor.execute(&operation);
-
-        match result {
-            OperationResult::Failure(error) => {
-                assert_eq!(error, "Scalar must be positive");
-            }
-            _ => panic!("Operation should have failed"),
-        }
-    }
-
-    // TODO: Add more comprehensive tests covering:
-    // - Complex homomorphic operations
-    // - Chained operations
-    // - Operation result handling
-    // - Type safety checks
-}
-```
-
-######## File: core/src/homomorphic/tests/mod.rs
-#####*Size: 4.0K, Lines: 1, Type: ASCII text*
-
-```rust
-pub mod homorphic_operation_interfaces_tests;
-```
-
-####### File: core/src/homomorphic/mod.rs
-####*Size: 4.0K, Lines: 10, Type: ASCII text*
-
-```rust
-//! Homomorphic operation interfaces
-
-mod operations;
-mod result;
-
-#[cfg(test)]
-mod tests;
-
-pub use operations::*;
-pub use result::*;
-```
-
-####### File: core/src/homomorphic/operations.rs
-####*Size: 4.0K, Lines: 73, Type: ASCII text*
-
-```rust
-//! Definition of the CommitmentOperation enum
-
-use std::any::Any;
-use std::fmt;
-use std::sync::Arc;
-
-/// Type for operations on commitments
-pub enum CommitmentOperation {
-    /// Add two commitments
-    Add {
-        left: Arc<dyn Any + Send + Sync>,
-        right: Arc<dyn Any + Send + Sync>,
-    },
-
-    /// Multiply a commitment by a scalar
-    ScalarMultiply {
-        commitment: Arc<dyn Any + Send + Sync>,
-        scalar: i32,
-    },
-
-    /// Apply a custom operation
-    Custom {
-        operation_id: String,
-        inputs: Vec<Arc<dyn Any + Send + Sync>>,
-        parameters: Vec<u8>,
-    },
-}
-
-impl fmt::Debug for CommitmentOperation {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            Self::Add { .. } => write!(f, "CommitmentOperation::Add {{ .. }}"),
-            Self::ScalarMultiply { scalar, .. } => {
-                write!(
-                    f,
-                    "CommitmentOperation::ScalarMultiply {{ scalar: {}, .. }}",
-                    scalar
-                )
-            }
-            Self::Custom { operation_id, .. } => {
-                write!(
-                    f,
-                    "CommitmentOperation::Custom {{ operation_id: {}, .. }}",
-                    operation_id
-                )
-            }
-        }
-    }
-}
-
-impl Clone for CommitmentOperation {
-    fn clone(&self) -> Self {
-        match self {
-            Self::Add { left, right } => Self::Add {
-                left: Arc::clone(left),
-                right: Arc::clone(right),
-            },
-            Self::ScalarMultiply { commitment, scalar } => Self::ScalarMultiply {
-                commitment: Arc::clone(commitment),
-                scalar: *scalar,
-            },
-            Self::Custom {
-                operation_id,
-                inputs,
-                parameters,
-            } => Self::Custom {
-                operation_id: operation_id.clone(),
-                inputs: inputs.iter().map(Arc::clone).collect(),
-                parameters: parameters.clone(),
-            },
-        }
-    }
-}
-```
-
-####### File: core/src/homomorphic/result.rs
-####*Size: 4.0K, Lines: 37, Type: ASCII text*
-
-```rust
-//! Definition of the OperationResult enum
-
-use std::any::Any;
-use std::fmt;
-use std::sync::Arc;
-
-/// Result of a homomorphic operation
-pub enum OperationResult {
-    /// Successfully computed result
-    Success(Arc<dyn Any + Send + Sync>),
-
-    /// Operation failed
-    Failure(String),
-
-    /// Operation not supported
-    Unsupported,
-}
-
-impl fmt::Debug for OperationResult {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            Self::Success(_) => write!(f, "OperationResult::Success(..)"),
-            Self::Failure(msg) => write!(f, "OperationResult::Failure({})", msg),
-            Self::Unsupported => write!(f, "OperationResult::Unsupported"),
-        }
-    }
-}
-
-impl Clone for OperationResult {
-    fn clone(&self) -> Self {
-        match self {
-            Self::Success(value) => Self::Success(Arc::clone(value)),
-            Self::Failure(msg) => Self::Failure(msg.clone()),
-            Self::Unsupported => Self::Unsupported,
-        }
-    }
-}
-```
-
-###### Directory: core/src/ibc
-
-####### File: core/src/ibc/mod.rs
-####*Size: 4.0K, Lines: 23, Type: ASCII text*
-
-```rust
-// In core/src/ibc/mod.rs
-use crate::services::BlockchainService;
-use crate::error::CoreError as Error; // Or define a specific IBC error type
-
-// Define the missing types
-pub type ChainId = String; // Or use a more specific type
-pub type ProofType = String; // Define based on your requirements
-
-pub struct Packet {
-    pub data: Vec<u8>,
-    pub source: ChainId,
-    pub destination: ChainId,
-    // Add other fields as needed
-}
-
-pub trait CrossChainCommunication: BlockchainService {
-    fn verify_proof(&self, proof: &dyn CrossChainProof) -> Result<bool, Error>;
-    fn create_packet(&self, data: &[u8], destination: ChainId) -> Result<Packet, Error>;
-}
-
-pub trait CrossChainProof {
-    fn source_chain(&self) -> ChainId;
-    fn proof_type(&self) -> ProofType;
-}```
-
-###### Directory: core/src/services
-
-####### File: core/src/services/mod.rs
-####*Size: 4.0K, Lines: 59, Type: ASCII text*
-
-```rust
-use std::any::Any;
-
-// Define the missing error type
-#[derive(Debug, thiserror::Error)]
-pub enum UpgradeError {
-    #[error("Invalid upgrade: {0}")]
-    InvalidUpgrade(String),
-    #[error("State migration failed: {0}")]
-    MigrationFailed(String),
-    #[error("Service not found")]
-    ServiceNotFound,
-    #[error("Health check failed: {0}")]
-    HealthCheckFailed(String),
-    #[error("Service operation failed: {0}")]
-    OperationFailed(String),
-}
-
-/// An identifier for a swappable service.
-#[derive(Debug, Clone, PartialEq, Eq, Hash)]
-pub enum ServiceType {
-    Governance,
-    Semantic,
-    ExternalData,
-    // ... other standard services
-    Custom(String),
-}
-
-/// The base trait for any service managed by the chain.
-pub trait BlockchainService: Any + Send + Sync {
-    fn service_type(&self) -> ServiceType;
-    // Potentially add methods for health checks, metrics, etc.
-}
-
-/// A trait for services that support runtime upgrades and rollbacks.
-pub trait UpgradableService: BlockchainService {
-    /// Prepares the service for an upgrade by validating the new implementation
-    /// and providing a state snapshot for migration.
-    fn prepare_upgrade(&self, new_module_wasm: &[u8]) -> Result<Vec<u8>, UpgradeError>; // Returns state snapshot
-
-    /// Instantiates a new version of the service from a state snapshot.
-    fn complete_upgrade(&mut self, snapshot: &[u8]) -> Result<(), UpgradeError>;
-    
-    /// Start the service
-    fn start(&self) -> Result<(), UpgradeError> {
-        // Default implementation - services can override if needed
-        Ok(())
-    }
-    
-    /// Stop the service
-    fn stop(&self) -> Result<(), UpgradeError> {
-        // Default implementation - services can override if needed
-        Ok(())
-    }
-    
-    /// Check the health of the service
-    fn health_check(&self) -> Result<(), UpgradeError> {
-        // Default implementation - services can override if needed
-        Ok(())
-    }
-}```
-
-###### Directory: core/src/state
-
-####### Directory: core/src/state/tests
-
-######## File: core/src/state/tests/mod.rs
-#####*Size: 8.0K, Lines: 141, Type: ASCII text*
-
-```rust
-#[cfg(test)]
-mod basic_state_tests {
-    use crate::error::StateError;
-    use crate::state::StateManager;
-    use std::collections::HashMap;
-
-    // Mock commitment and proof types for testing
-    #[derive(Debug, Clone, PartialEq, Eq)]
-    struct MockCommitment(Vec<u8>);
-
-    #[derive(Debug, Clone, PartialEq, Eq)]
-    struct MockProof(Vec<u8>);
-
-    // Mock state manager implementation
-    struct MockStateManager {
-        data: HashMap<Vec<u8>, Vec<u8>>,
-    }
-
-    impl MockStateManager {
-        fn new() -> Self {
-            Self {
-                data: HashMap::new(),
-            }
-        }
-    }
-
-    impl StateManager for MockStateManager {
-        type Commitment = MockCommitment;
-        type Proof = MockProof;
-
-        fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
-            Ok(self.data.get(key).cloned())
-        }
-
-        fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
-            self.data.insert(key.to_vec(), value.to_vec());
-            Ok(())
-        }
-
-        fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
-            self.data.remove(key);
-            Ok(())
-        }
-        
-        fn root_commitment(&self) -> Self::Commitment {
-            // Simple mock implementation
-            let mut combined = Vec::new();
-            for (k, v) in &self.data {
-                combined.extend_from_slice(k);
-                combined.extend_from_slice(v);
-            }
-            MockCommitment(combined)
-        }
-        
-        fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-            // Simple mock implementation
-            self.get(key).ok().flatten().map(MockProof)
-        }
-        
-        fn verify_proof(
-            &self,
-            _commitment: &Self::Commitment,
-            proof: &Self::Proof,
-            _key: &[u8],
-            value: &[u8],
-        ) -> bool {
-            // Simple mock implementation
-            proof.0 == value
-        }
-    }
-
-    #[test]
-    fn test_basic_state_operations() {
-        let mut state = MockStateManager::new();
-        
-        // Test set and get
-        let key = b"test_key";
-        let value = b"test_value";
-        
-        state.set(key, value).unwrap();
-        assert_eq!(state.get(key).unwrap(), Some(value.to_vec()));
-        
-        // Test delete
-        state.delete(key).unwrap();
-        assert_eq!(state.get(key).unwrap(), None);
-    }
-
-    #[test]
-    fn test_batch_operations() {
-        let mut state = MockStateManager::new();
-        
-        // Test batch set
-        let updates = vec![
-            (b"key1".to_vec(), b"value1".to_vec()),
-            (b"key2".to_vec(), b"value2".to_vec()),
-            (b"key3".to_vec(), b"value3".to_vec()),
-        ];
-        
-        state.batch_set(&updates).unwrap();
-        
-        // Test batch get
-        let keys = vec![
-            b"key1".to_vec(),
-            b"key2".to_vec(),
-            b"key3".to_vec(),
-            b"nonexistent".to_vec(),
-        ];
-        
-        let values = state.batch_get(&keys).unwrap();
-        
-        assert_eq!(values.len(), 4);
-        assert_eq!(values[0], Some(b"value1".to_vec()));
-        assert_eq!(values[1], Some(b"value2".to_vec()));
-        assert_eq!(values[2], Some(b"value3".to_vec()));
-        assert_eq!(values[3], None);
-    }
-    
-    #[test]
-    fn test_commitment_and_proof() {
-        let mut state = MockStateManager::new();
-        
-        // Set up test data
-        let key = b"test_key";
-        let value = b"test_value";
-        state.set(key, value).unwrap();
-        
-        // Test commitment
-        let commitment = state.root_commitment();
-        assert!(!commitment.0.is_empty());
-        
-        // Test proof creation
-        let proof = state.create_proof(key).unwrap();
-        assert_eq!(proof.0, value);
-        
-        // Test proof verification
-        assert!(state.verify_proof(&commitment, &proof, key, value));
-        
-        // Test verification with wrong value
-        let wrong_value = b"wrong_value";
-        assert!(!state.verify_proof(&commitment, &proof, key, wrong_value));
-    }
-}```
-
-######## File: core/src/state/tests/state_tree_tests.rs
-#####*Size: 12K, Lines: 278, Type: ASCII text*
-
-```rust
-//! Tests for state tree interface definitions
-
-#[cfg(test)]
-mod tests {
-    use crate::commitment::{CommitmentScheme, ProofContext, Selector};
-    use crate::state::{StateManager, StateTree};
-    use crate::test_utils::mock_commitment::{
-        helpers, MockCommitment, MockCommitmentScheme, MockProof,
-    };
-    use std::any::Any;
-    use std::collections::HashMap;
-
-    // Mock state tree implementation for testing
-    struct MockStateTree {
-        data: HashMap<Vec<u8>, Vec<u8>>,
-        scheme: MockCommitmentScheme,
-    }
-
-    impl MockStateTree {
-        fn new() -> Self {
-            Self {
-                data: HashMap::new(),
-                scheme: MockCommitmentScheme,
-            }
-        }
-    }
-
-    impl StateTree for MockStateTree {
-        type Commitment = MockCommitment;
-        type Proof = MockProof;
-
-        fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), String> {
-            self.data.insert(key.to_vec(), value.to_vec());
-            Ok(())
-        }
-
-        fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
-            self.data.get(key).cloned()
-        }
-
-        fn delete(&mut self, key: &[u8]) -> Result<(), String> {
-            self.data.remove(key);
-            Ok(())
-        }
-
-        fn root_commitment(&self) -> Self::Commitment {
-            let values: Vec<Option<Vec<u8>>> =
-                self.data.values().map(|v| Some(v.clone())).collect();
-
-            self.scheme.commit(&values)
-        }
-
-        fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-            let value = self.get(key)?;
-            // Use key-based selector in proof creation
-            let selector = Selector::Key(key.to_vec());
-            self.scheme.create_proof(&selector, &value).ok()
-        }
-
-        fn verify_proof(
-            &self,
-            commitment: &Self::Commitment,
-            proof: &Self::Proof,
-            key: &[u8],
-            value: &[u8],
-        ) -> bool {
-            // Create a context for verification
-            let mut context = ProofContext::default();
-
-            // Regenerate the selector from the key - ensure keys actually match
-            let selector = Selector::Key(key.to_vec());
-
-            // Check if the proof was created with a matching key
-            if let Selector::Key(proof_key) = &proof.selector {
-                if proof_key != key {
-                    return false;
-                }
-            }
-
-            // Convert value to Vec<u8> to match the expected type
-            self.scheme
-                .verify(commitment, proof, &selector, &value.to_vec(), &context)
-        }
-
-        fn commitment_scheme(&self) -> &dyn Any {
-            &self.scheme
-        }
-    }
-
-    // Mock state manager implementation for testing
-    struct MockStateManager {
-        tree: MockStateTree,
-    }
-
-    impl MockStateManager {
-        fn new() -> Self {
-            Self {
-                tree: MockStateTree::new(),
-            }
-        }
-    }
-
-    impl StateManager<MockCommitmentScheme> for MockStateManager {
-        fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
-            self.tree.get(key)
-        }
-
-        fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), String> {
-            self.tree.insert(key, value)
-        }
-
-        fn delete(&mut self, key: &[u8]) -> Result<(), String> {
-            self.tree.delete(key)
-        }
-
-        fn root_commitment(&self) -> <MockCommitmentScheme as CommitmentScheme>::Commitment {
-            self.tree.root_commitment()
-        }
-
-        fn create_proof(
-            &self,
-            key: &[u8],
-        ) -> Option<<MockCommitmentScheme as CommitmentScheme>::Proof> {
-            self.tree.create_proof(key)
-        }
-
-        fn verify_proof(
-            &self,
-            commitment: &<MockCommitmentScheme as CommitmentScheme>::Commitment,
-            proof: &<MockCommitmentScheme as CommitmentScheme>::Proof,
-            key: &[u8],
-            value: &[u8],
-        ) -> bool {
-            // Delegate to tree's verify_proof method which now uses the key
-            self.tree.verify_proof(commitment, proof, key, value)
-        }
-    }
-
-    #[test]
-    fn test_state_tree_basic_operations() {
-        let mut tree = MockStateTree::new();
-
-        // Test insert and get
-        let key1 = b"key1";
-        let value1 = b"value1";
-
-        tree.insert(key1, value1).unwrap();
-        assert_eq!(tree.get(key1), Some(value1.to_vec()));
-
-        // Test delete
-        tree.delete(key1).unwrap();
-        assert_eq!(tree.get(key1), None);
-    }
-
-    #[test]
-    fn test_state_tree_commitments_and_proofs() {
-        let mut tree = MockStateTree::new();
-
-        let key1 = b"key1";
-        let value1 = b"value1";
-        let key2 = b"key2";
-        let value2 = b"value2";
-
-        tree.insert(key1, value1).unwrap();
-        tree.insert(key2, value2).unwrap();
-
-        // Test root commitment
-        let commitment = tree.root_commitment();
-
-        // Test proof creation
-        let proof = tree.create_proof(key1).unwrap();
-
-        // Test proof verification
-        assert!(tree.verify_proof(&commitment, &proof, key1, value1));
-
-        // Test invalid proof - wrong value
-        let wrong_value = b"wrong_value";
-        assert!(!tree.scheme.verify(
-            &commitment,
-            &proof,
-            &Selector::Key(key1.to_vec()),
-            &wrong_value.to_vec(), // Convert to Vec<u8>
-            &ProofContext::default()
-        ));
-
-        // Test wrong key
-        assert!(!tree.verify_proof(&commitment, &proof, key2, value1));
-    }
-
-    #[test]
-    fn test_proof_context_usage() {
-        let mut tree = MockStateTree::new();
-        let key1 = b"key1";
-        let value1 = b"value1";
-
-        tree.insert(key1, value1).unwrap();
-        let commitment = tree.root_commitment();
-
-        // Get a proof for key1
-        let proof = tree.create_proof(key1).unwrap();
-
-        // Create a context with strict verification enabled
-        let context = helpers::create_context(true);
-
-        // Verify with context - convert value to Vec<u8>
-        assert!(tree.scheme.verify(
-            &commitment,
-            &proof,
-            &Selector::Key(key1.to_vec()),
-            &value1.to_vec(), // Convert to Vec<u8>
-            &context
-        ));
-
-        // Try with wrong key but same value - should fail in strict mode
-        let wrong_key = b"wrong_key".to_vec();
-        assert!(!tree.scheme.verify(
-            &commitment,
-            &proof,
-            &Selector::Key(wrong_key),
-            &value1.to_vec(), // Convert to Vec<u8>
-            &context
-        ));
-    }
-
-    #[test]
-    fn test_state_manager() {
-        let mut manager = MockStateManager::new();
-
-        let key1 = b"key1";
-        let value1 = b"value1";
-
-        // Test set and get
-        manager.set(key1, value1).unwrap();
-        assert_eq!(manager.get(key1), Some(value1.to_vec()));
-
-        // Test root commitment
-        let commitment = manager.root_commitment();
-
-        // Test proof creation and verification
-        let proof = manager.create_proof(key1).unwrap();
-        assert!(manager.verify_proof(&commitment, &proof, key1, value1));
-
-        // Test delete
-        manager.delete(key1).unwrap();
-        assert_eq!(manager.get(key1), None);
-    }
-
-    #[test]
-    fn test_with_helper_functions() {
-        // Test the helper functions from the mock_commitment module
-        let value = b"test_value";
-        let key = b"test_key";
-
-        // Create a commitment
-        let commitment = helpers::create_commitment(value);
-
-        // Create a proof
-        let proof = helpers::create_key_proof(key, value).unwrap();
-
-        // Create a context
-        let context = helpers::create_context(true);
-
-        // Verify the proof - convert value to Vec<u8>
-        let scheme = MockCommitmentScheme;
-        assert!(scheme.verify(
-            &commitment,
-            &proof,
-            &Selector::Key(key.to_vec()),
-            &value.to_vec(), // Convert to Vec<u8>
-            &context
-        ));
-    }
-}
-// TODO: Add more comprehensive tests covering:
-// - Complex state tree operations with multiple keys
-// - Proof verification across different states
-// - State transition validations
-// - Edge cases like empty trees, large values, etc.
-```
-
-####### File: core/src/state/manager.rs
-####*Size: 4.0K, Lines: 21, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/state/manager.rs
-
-use crate::error::StateError;
-use crate::state::StateTree;
-
-/// State manager interface for the DePIN SDK.
-///
-/// `StateManager` is a higher-level abstraction that must also be a `StateTree`.
-/// It provides all the same core methods as `StateTree` (via inheritance) and
-/// adds batching capabilities.
-pub trait StateManager: StateTree {
-    // REMOVED: All redundant associated types and method signatures from StateTree are gone.
-    // They are inherited automatically.
-
-    /// Set multiple key-value pairs in a single batch operation.
-    /// This is now a required method for any implementor of StateManager.
-    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError>;
-
-    /// Get multiple values by keys in a single batch operation.
-    /// This is now a required method.
-    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError>;
-}```
-
-####### File: core/src/state/mod.rs
-####*Size: 4.0K, Lines: 25, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/state/mod.rs
-
-//! State management interfaces for the DePIN SDK Core.
-
-mod manager;
-mod tree;
-
-#[cfg(test)]
-mod tests;
-
-pub use manager::*;
-pub use tree::*;
-
-use crate::commitment::CommitmentScheme;
-
-/// Type alias for a StateManager trait object compatible with a specific CommitmentScheme.
-pub type StateManagerFor<CS> = dyn StateManager<
-    Commitment = <CS as CommitmentScheme>::Commitment,
-    Proof = <CS as CommitmentScheme>::Proof,
->;
-
-/// Type alias for a StateTree trait object compatible with a specific CommitmentScheme.
-pub type StateTreeFor<CS> = dyn StateTree<
-    Commitment = <CS as CommitmentScheme>::Commitment,
-    Proof = <CS as CommitmentScheme>::Proof,
->;```
-
-####### File: core/src/state/tree.rs
-####*Size: 4.0K, Lines: 65, Type: ASCII text*
-
-```rust
-// File: crates/core/src/state/tree.rs
-
-use std::any::Any;
-use crate::error::StateError;
-
-/// Generic state tree operations
-///
-/// A StateTree provides key-value storage with optional cryptographic
-/// commitment and proof capabilities. It's the lower-level interface
-/// intended for direct tree implementations (Merkle trees, sparse
-/// Merkle trees, Patricia tries, etc.).
-pub trait StateTree {
-    /// The commitment type this tree uses
-    type Commitment;
-    
-    /// The proof type this tree uses
-    type Proof;
-
-    /// Get a value by key
-    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError>;
-    
-    /// Insert a key-value pair
-    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError>;
-    
-    /// Delete a key-value pair
-    fn delete(&mut self, key: &[u8]) -> Result<(), StateError>;
-    
-    /// Get the root commitment of the tree
-    ///
-    /// # Returns
-    /// * The current root commitment
-    fn root_commitment(&self) -> Self::Commitment;
-    
-    /// Create a proof for a specific key
-    ///
-    /// # Arguments
-    /// * `key` - The key to create a proof for
-    ///
-    /// # Returns
-    /// * `Some(proof)` - If proof creation succeeded
-    /// * `None` - If the key doesn't exist or proof creation isn't supported
-    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof>;
-    
-    /// Verify a proof against the tree's root commitment
-    ///
-    /// # Arguments
-    /// * `commitment` - The commitment to verify against
-    /// * `proof` - The proof to verify
-    /// * `key` - The key the proof is for
-    /// * `value` - The value to verify
-    ///
-    /// # Returns
-    /// * `true` - If the proof is valid
-    /// * `false` - If the proof is invalid or verification isn't supported
-    fn verify_proof(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &[u8]
-    ) -> bool;
-
-    /// Provide access to the concrete type for downcasting.
-    fn as_any(&self) -> &dyn Any;
-    
-}```
-
-###### Directory: core/src/test_utils
-
-####### File: core/src/test_utils/mock_commitment.rs
-####*Size: 8.0K, Lines: 172, Type: ASCII text*
-
-```rust
-//! Mock commitment scheme for testing
-
-use crate::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
-
-/// Mock commitment scheme implementation for testing
-#[derive(Debug, Clone)]
-pub struct MockCommitmentScheme;
-
-/// Mock commitment for testing
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct MockCommitment(pub Vec<u8>);
-
-impl AsRef<[u8]> for MockCommitment {
-    fn as_ref(&self) -> &[u8] {
-        &self.0
-    }
-}
-
-/// Mock proof for testing
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub struct MockProof {
-    /// Selector used to create this proof
-    pub selector: Selector,
-    /// Value that this proof is for
-    pub value: Vec<u8>,
-}
-
-impl CommitmentScheme for MockCommitmentScheme {
-    type Commitment = MockCommitment;
-    type Proof = MockProof;
-    type Value = Vec<u8>;
-
-    fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-        // Implementation actually combines all values into a single commitment
-        let mut combined = Vec::new();
-        for v in values {
-            if let Some(data) = v {
-                combined.extend_from_slice(data.as_ref());
-            }
-        }
-        MockCommitment(combined)
-    }
-
-    fn create_proof(
-        &self,
-        selector: &Selector,
-        value: &Self::Value,
-    ) -> Result<Self::Proof, String> {
-        // Store both selector and value in the proof
-        Ok(MockProof {
-            selector: selector.clone(),
-            value: value.clone(),
-        })
-    }
-
-    fn verify(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        selector: &Selector,
-        value: &Self::Value,
-        context: &ProofContext,
-    ) -> bool {
-        // 1. Check that selector types match
-        if !matches!(&proof.selector, selector) {
-            return false;
-        }
-
-        // 2. Check value matches - comparing the raw bytes
-        let value_slice: &[u8] = value.as_ref();
-        if proof.value.as_slice() != value_slice {
-            return false;
-        }
-
-        // 3. Use commitment in verification - in real world this would be cryptographic
-        // For our mock, we'll check if the commitment contains the value
-        let commitment_slice: &[u8] = commitment.as_ref();
-        let contains_value = commitment_slice
-            .windows(value_slice.len())
-            .any(|window| window == value_slice);
-        if !contains_value {
-            return false;
-        }
-
-        // 4. Use context for additional verification parameters
-        // In this mock, we'll check if a special "strict_verify" flag is set
-        if let Some(strict_flag) = context.get_data("strict_verify") {
-            if !strict_flag.is_empty() && strict_flag[0] == 1 {
-                // In strict mode, we also check selector-specific rules
-                match selector {
-                    Selector::Position(pos) => {
-                        // Position-based verification
-                        if let Selector::Position(proof_pos) = &proof.selector {
-                            if pos != proof_pos {
-                                return false;
-                            }
-                        } else {
-                            return false;
-                        }
-                    }
-                    Selector::Key(key) => {
-                        // Key-based verification
-                        if let Selector::Key(proof_key) = &proof.selector {
-                            if key != proof_key {
-                                return false;
-                            }
-                        } else {
-                            return false;
-                        }
-                    }
-                    _ => {
-                        // For other selectors, just ensure they match exactly
-                        if proof.selector != *selector {
-                            return false;
-                        }
-                    }
-                }
-            }
-        }
-
-        // If we made it here, verification passed
-        true
-    }
-
-    fn scheme_id() -> SchemeIdentifier {
-        SchemeIdentifier::new("mock")
-    }
-}
-
-/// Helper functions for testing with mock commitment scheme
-pub mod helpers {
-    use super::*;
-
-    /// Create a mock commitment from a single value
-    pub fn create_commitment<T: AsRef<[u8]>>(value: T) -> MockCommitment {
-        let scheme = MockCommitmentScheme;
-        // Convert to Vec<u8> since the CommitmentScheme's Value type is Vec<u8>
-        scheme.commit(&[Some(value.as_ref().to_vec())])
-    }
-
-    /// Create a mock proof for a value with position selector
-    pub fn create_position_proof<T: AsRef<[u8]>>(
-        position: usize,
-        value: T,
-    ) -> Result<MockProof, String> {
-        let scheme = MockCommitmentScheme;
-        // Convert to Vec<u8> since the CommitmentScheme's Value type is Vec<u8>
-        scheme.create_proof(&Selector::Position(position), &value.as_ref().to_vec())
-    }
-
-    /// Create a mock proof for a value with key selector
-    pub fn create_key_proof<K: AsRef<[u8]>, V: AsRef<[u8]>>(
-        key: K,
-        value: V,
-    ) -> Result<MockProof, String> {
-        let scheme = MockCommitmentScheme;
-        // Convert to Vec<u8> since the CommitmentScheme's Value type is Vec<u8>
-        scheme.create_proof(
-            &Selector::Key(key.as_ref().to_vec()),
-            &value.as_ref().to_vec(),
-        )
-    }
-
-    /// Create a verification context for testing
-    pub fn create_context(strict: bool) -> ProofContext {
-        let mut context = ProofContext::default();
-        if strict {
-            context.add_data("strict_verify", vec![1]);
-        }
-        context
-    }
-}
-```
-
-####### File: core/src/test_utils/mod.rs
-####*Size: 4.0K, Lines: 3, Type: ASCII text*
-
-```rust
-//! Test utilities for the DePIN SDK Core
-
-pub mod mock_commitment;
-```
-
-###### Directory: core/src/transaction
-
-####### Directory: core/src/transaction/tests
-
-######## File: core/src/transaction/tests/mod.rs
-#####*Size: 4.0K, Lines: 1, Type: ASCII text*
-
-```rust
-mod transaction_model_tests;
-```
-
-######## File: core/src/transaction/tests/transaction_model_tests.rs
-#####*Size: 12K, Lines: 351, Type: ASCII text*
-
-```rust
-//! Tests for transaction model trait definitions
-
-#[cfg(test)]
-mod tests {
-    use crate::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
-    use crate::state::StateManager;
-    use crate::transaction::{Error, TransactionModel};
-    use std::collections::HashMap;
-
-    // Mock commitment scheme implementation for testing
-    #[derive(Debug, Clone)]
-    struct MockCommitmentScheme;
-
-    #[derive(Debug, Clone, PartialEq, Eq)]
-    struct MockCommitment(Vec<u8>);
-
-    impl AsRef<[u8]> for MockCommitment {
-        fn as_ref(&self) -> &[u8] {
-            &self.0
-        }
-    }
-
-    #[derive(Debug, Clone, PartialEq, Eq)]
-    struct MockProof {
-        position: usize,
-        value: Vec<u8>,
-    }
-
-    impl CommitmentScheme for MockCommitmentScheme {
-        type Commitment = MockCommitment;
-        type Proof = MockProof;
-        type Value = Vec<u8>; // Still using Vec<u8> but will access via as_ref()
-
-        fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-            // Simple implementation for testing
-            let mut combined = Vec::new();
-            for v in values {
-                if let Some(data) = v {
-                    combined.extend_from_slice(data.as_ref());
-                }
-            }
-            MockCommitment(combined)
-        }
-
-        fn create_proof(
-            &self,
-            selector: &Selector,
-            value: &Self::Value,
-        ) -> Result<Self::Proof, String> {
-            // Extract position from selector
-            let position = match selector {
-                Selector::Position(pos) => *pos,
-                _ => 0, // Default to position 0 for other selector types
-            };
-
-            Ok(MockProof {
-                position,
-                value: value.clone(),
-            })
-        }
-
-        fn verify(
-            &self,
-            _commitment: &Self::Commitment,
-            proof: &Self::Proof,
-            selector: &Selector,
-            value: &Self::Value,
-            _context: &ProofContext, // Added context parameter
-        ) -> bool {
-            // Extract position from selector if it's a position-based selector
-            match selector {
-                Selector::Position(pos) => proof.position == *pos && proof.value == *value,
-                Selector::Key(_) => proof.value == *value, // For key-based selectors, only check value
-                _ => false, // Other selector types not supported in this implementation
-            }
-        }
-
-        fn scheme_id() -> SchemeIdentifier {
-            SchemeIdentifier::new("mock")
-        }
-    }
-
-    // Mock state manager implementation for testing
-    struct MockStateManager {
-        state: HashMap<Vec<u8>, Vec<u8>>,
-        scheme: MockCommitmentScheme,
-    }
-
-    impl MockStateManager {
-        fn new() -> Self {
-            Self {
-                state: HashMap::new(),
-                scheme: MockCommitmentScheme,
-            }
-        }
-    }
-
-    impl StateManager<MockCommitmentScheme> for MockStateManager {
-        fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
-            self.state.get(key).cloned()
-        }
-
-        fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), String> {
-            self.state.insert(key.to_vec(), value.to_vec());
-            Ok(())
-        }
-
-        fn delete(&mut self, key: &[u8]) -> Result<(), String> {
-            self.state.remove(key);
-            Ok(())
-        }
-
-        fn root_commitment(&self) -> <MockCommitmentScheme as CommitmentScheme>::Commitment {
-            let values: Vec<Option<Vec<u8>>> =
-                self.state.values().map(|v| Some(v.clone())).collect();
-
-            self.scheme.commit(&values)
-        }
-
-        fn create_proof(
-            &self,
-            key: &[u8],
-        ) -> Option<<MockCommitmentScheme as CommitmentScheme>::Proof> {
-            let value = self.get(key)?;
-            self.scheme
-                .create_proof(&Selector::Position(0), &value)
-                .ok()
-        }
-
-        fn verify_proof(
-            &self,
-            _commitment: &<MockCommitmentScheme as CommitmentScheme>::Commitment,
-            proof: &<MockCommitmentScheme as CommitmentScheme>::Proof,
-            _key: &[u8],
-            value: &[u8],
-        ) -> bool {
-            // Updated to include context parameter and use Position selector
-            self.scheme.verify(
-                &self.root_commitment(),
-                proof,
-                &Selector::Position(proof.position),
-                &value.to_vec(), // Convert slice to Vec<u8> for Value type
-                &ProofContext::default(),
-            )
-        }
-    }
-
-    // Mock transaction model for testing
-
-    // Mock UTXO-style transaction model
-    #[derive(Debug, Clone)]
-    struct MockUTXOTransaction {
-        txid: Vec<u8>,
-        inputs: Vec<MockUTXOInput>,
-        outputs: Vec<MockUTXOOutput>,
-    }
-
-    #[derive(Debug, Clone)]
-    struct MockUTXOInput {
-        prev_txid: Vec<u8>,
-        prev_index: u32,
-        signature: Vec<u8>,
-    }
-
-    #[derive(Debug, Clone)]
-    struct MockUTXOOutput {
-        value: u64,
-        recipient: Vec<u8>,
-    }
-
-    #[derive(Debug, Clone)]
-    struct MockUTXOProof {
-        proof: MockProof,
-    }
-
-    // Mock transaction model implementation
-    struct MockTransactionModel {
-        scheme: MockCommitmentScheme,
-    }
-
-    impl MockTransactionModel {
-        fn new() -> Self {
-            Self {
-                scheme: MockCommitmentScheme,
-            }
-        }
-
-        // Helper method to create a unique UTXO key from txid and output index
-        fn create_utxo_key(txid: &[u8], output_index: u32) -> Vec<u8> {
-            let mut key = txid.to_vec();
-            key.extend_from_slice(&output_index.to_le_bytes());
-            key
-        }
-    }
-
-    impl TransactionModel<MockCommitmentScheme> for MockTransactionModel {
-        type Transaction = MockUTXOTransaction;
-        type Proof = MockUTXOProof;
-
-        fn validate(&self, tx: &Self::Transaction, _commitment: &MockCommitment) -> bool {
-            // Simple validation for testing
-            !tx.inputs.is_empty() && !tx.outputs.is_empty()
-        }
-
-        fn apply(
-            &self,
-            tx: &Self::Transaction,
-            state: &mut dyn StateManager<MockCommitmentScheme>,
-        ) -> Result<(), String> {
-            // Simple application logic for testing
-            for input in &tx.inputs {
-                // Create a key for the UTXO being spent using the helper method
-                let key = Self::create_utxo_key(&input.prev_txid, input.prev_index);
-                state.delete(&key)?;
-            }
-
-            for (i, output) in tx.outputs.iter().enumerate() {
-                // Create a unique key for each output using the helper method
-                let key = Self::create_utxo_key(&tx.txid, i as u32);
-
-                // Simple manual serialization instead of using bincode
-                let mut value = Vec::new();
-                // Serialize value
-                value.extend_from_slice(&output.value.to_le_bytes());
-                // Serialize recipient length
-                value.extend_from_slice(&(output.recipient.len() as u32).to_le_bytes());
-                // Serialize recipient
-                value.extend_from_slice(&output.recipient);
-
-                state.set(&key, &value)?;
-            }
-
-            Ok(())
-        }
-    }
-
-    #[test]
-    fn test_transaction_validation() {
-        let model = MockTransactionModel::new();
-        let commitment = MockCommitment(vec![0]);
-
-        // Valid transaction
-        let valid_tx = MockUTXOTransaction {
-            txid: vec![1, 2, 3],
-            inputs: vec![MockUTXOInput {
-                prev_txid: vec![4, 5, 6],
-                prev_index: 0,
-                signature: vec![7, 8, 9],
-            }],
-            outputs: vec![MockUTXOOutput {
-                value: 100,
-                recipient: vec![10, 11, 12],
-            }],
-        };
-
-        assert!(model.validate(&valid_tx, &commitment));
-
-        // Invalid transaction - no inputs
-        let invalid_tx = MockUTXOTransaction {
-            txid: vec![1, 2, 3],
-            inputs: vec![],
-            outputs: vec![MockUTXOOutput {
-                value: 100,
-                recipient: vec![10, 11, 12],
-            }],
-        };
-
-        assert!(!model.validate(&invalid_tx, &commitment));
-    }
-
-    #[test]
-    fn test_transaction_application() {
-        let model = MockTransactionModel::new();
-        let mut state = MockStateManager::new();
-
-        // Set up initial state
-        let prev_txid = vec![4, 5, 6];
-        let prev_index = 0;
-
-        // Create the UTXO key using the helper method
-        let prev_utxo_key = MockTransactionModel::create_utxo_key(&prev_txid, prev_index);
-
-        // Simple manual serialization instead of using bincode
-        let mut prev_output = Vec::new();
-        // Serialize value
-        prev_output.extend_from_slice(&100u64.to_le_bytes());
-        // Serialize recipient length
-        prev_output.extend_from_slice(&(3u32).to_le_bytes());
-        // Serialize recipient
-        prev_output.extend_from_slice(&[7, 8, 9]);
-
-        state.set(&prev_utxo_key, &prev_output).unwrap();
-
-        // Create and apply transaction
-        let tx = MockUTXOTransaction {
-            txid: vec![1, 2, 3],
-            inputs: vec![MockUTXOInput {
-                prev_txid: prev_txid.clone(),
-                prev_index,
-                signature: vec![10, 11, 12],
-            }],
-            outputs: vec![
-                MockUTXOOutput {
-                    value: 50,
-                    recipient: vec![13, 14, 15],
-                },
-                MockUTXOOutput {
-                    value: 50,
-                    recipient: vec![16, 17, 18],
-                },
-            ],
-        };
-
-        model.apply(&tx, &mut state).unwrap();
-
-        // Verify state changes
-        assert_eq!(state.get(&prev_utxo_key), None); // Input was spent
-
-        // Check that both outputs were created with their proper keys
-        let output0_key = MockTransactionModel::create_utxo_key(&tx.txid, 0);
-        let output1_key = MockTransactionModel::create_utxo_key(&tx.txid, 1);
-
-        assert!(state.get(&output0_key).is_some()); // First output was created
-        assert!(state.get(&output1_key).is_some()); // Second output was created
-    }
-
-    #[test]
-    fn test_error_handling() {
-        // Test the Error enum formatting
-        let invalid_error = Error::Invalid("test error".to_string());
-        let insufficient_error = Error::InsufficientFunds;
-        let nonce_error = Error::NonceMismatch;
-        let signature_error = Error::InvalidSignature;
-        let other_error = Error::Other("other error".to_string());
-
-        assert_eq!(
-            format!("{}", invalid_error),
-            "Invalid transaction: test error"
-        );
-        assert_eq!(format!("{}", insufficient_error), "Insufficient funds");
-        assert_eq!(format!("{}", nonce_error), "Nonce mismatch");
-        assert_eq!(format!("{}", signature_error), "Invalid signature");
-        assert_eq!(format!("{}", other_error), "Other error: other error");
-    }
-
-    // TODO: Add more comprehensive tests covering:
-    // - Different transaction models (UTXO, account-based)
-    // - Transaction validation rules
-    // - Error cases in transaction application
-    // - Complex state changes
-}
-```
-
-####### File: core/src/transaction/mod.rs
-####*Size: 8.0K, Lines: 153, Type: ASCII text*
-
-```rust
-// File: crates/core/src/transaction/mod.rs
-
-use crate::commitment::CommitmentScheme;
-use crate::error::TransactionError;
-use crate::state::StateManager;
-use std::any::Any;
-use std::fmt::Debug;
-
-/// Core transaction model trait that defines the interface for all transaction models.
-///
-/// This trait is intentionally model-agnostic, allowing for different implementations
-/// (UTXO, account-based, hybrid, etc.) while providing a consistent interface.
-pub trait TransactionModel {
-    /// The transaction type for this model.
-    type Transaction: Debug;
-
-    /// The proof type for this model.
-    type Proof;
-
-    /// The commitment scheme used by this model.
-    type CommitmentScheme: CommitmentScheme;
-
-    /// Creates a "coinbase" or block reward transaction.
-    ///
-    /// This provides a generic way for a block producer (like the OrchestrationContainer)
-    /// to create the first, special transaction in a block without needing to know the
-    /// specific details of the transaction model.
-    ///
-    /// # Arguments
-    /// * `block_height` - The height of the block this transaction will be in.
-    /// * `recipient` - The public key or address of the block producer who should receive the reward.
-    ///
-    /// # Returns
-    /// * `Ok(transaction)` - A valid coinbase transaction.
-    /// * `Err(TransactionError)` - If the coinbase transaction could not be created.
-    fn create_coinbase_transaction(
-        &self,
-        block_height: u64,
-        recipient: &[u8],
-    ) -> Result<Self::Transaction, TransactionError>;
-
-    /// Validate a transaction against the current state.
-    ///
-    /// # Arguments
-    /// * `tx` - The transaction to validate.
-    /// * `state` - The state to validate against.
-    ///
-    /// # Returns
-    /// * `Ok(true)` - If the transaction is valid.
-    /// * `Ok(false)` - If the transaction is invalid.
-    /// * `Err(TransactionError)` - If an error occurred during validation.
-    fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized;
-
-    /// Apply a transaction to the state.
-    ///
-    /// # Arguments
-    /// * `tx` - The transaction to apply.
-    /// * `state` - The state to modify.
-    ///
-    /// # Returns
-    /// * `Ok(())` - If the transaction was successfully applied.
-    /// * `Err(TransactionError)` - If an error occurred during application.
-    fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized;
-
-    /// Generate a proof for a transaction.
-    ///
-    /// # Arguments
-    /// * `tx` - The transaction to generate a proof for.
-    /// * `state` - The state to generate the proof against.
-    ///
-    /// # Returns
-    /// * `Ok(proof)` - If the proof was successfully generated.
-    /// * `Err(TransactionError)` - If an error occurred during proof generation.
-    fn generate_proof<S>(
-        &self,
-        tx: &Self::Transaction,
-        state: &S,
-    ) -> Result<Self::Proof, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized;
-
-    /// Verify a proof for a transaction.
-    ///
-    /// # Arguments
-    /// * `proof` - The proof to verify.
-    /// * `state` - The state to verify against.
-    ///
-    /// # Returns
-    /// * `Ok(true)` - If the proof is valid.
-    /// * `Ok(false)` - If the proof is invalid.
-    /// * `Err(TransactionError)` - If an error occurred during verification.
-    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized;
-
-    /// Serialize a transaction to bytes.
-    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError>;
-
-    /// Deserialize bytes to a transaction.
-    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError>;
-
-    /// Optional extension point for model-specific functionality.
-    fn get_model_extensions(&self) -> Option<&dyn Any> {
-        None
-    }
-}
-
-/// Registry for managing multiple transaction models at runtime.
-#[derive(Default)]
-pub struct TransactionModelRegistry {
-    models: std::collections::HashMap<String, Box<dyn Any>>,
-}
-
-impl TransactionModelRegistry {
-    /// Create a new empty registry.
-    pub fn new() -> Self {
-        Self {
-            models: std::collections::HashMap::new(),
-        }
-    }
-
-    /// Register a transaction model.
-    pub fn register<T: TransactionModel + 'static>(&mut self, name: &str, model: T) {
-        self.models.insert(name.to_string(), Box::new(model));
-    }
-
-    /// Get a registered transaction model.
-    pub fn get<T: 'static>(&self, name: &str) -> Option<&T> {
-        self.models
-            .get(name)
-            .and_then(|model| model.downcast_ref::<T>())
-    }
-
-    /// Check if a model is registered.
-    pub fn has_model(&self, name: &str) -> bool {
-        self.models.contains_key(name)
-    }
-}```
-
-###### Directory: core/src/types
-
-####### File: core/src/types/mod.rs
-####*Size: 4.0K, Lines: 50, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/types/mod.rs
-
-//! Type aliases and common types for the DePIN SDK
-
-use crate::commitment::CommitmentScheme;
-use crate::state::StateManager;
-use crate::transaction::TransactionModel;
-
-/// Type aliases for commitment schemes.
-pub mod commitment {
-    use super::*;
-
-    /// The commitment type for a given commitment scheme.
-    pub type CommitmentOf<CS> = <CS as CommitmentScheme>::Commitment;
-
-    /// The proof type for a given commitment scheme.
-    pub type ProofOf<CS> = <CS as CommitmentScheme>::Proof;
-
-    /// The value type for a given commitment scheme.
-    pub type ValueOf<CS> = <CS as CommitmentScheme>::Value;
-}
-
-/// Type aliases for state management.
-pub mod state {
-    use super::*;
-
-    /// Type alias for a `StateManager` trait object that is compatible with a
-    /// specific `CommitmentScheme`. This is now unambiguous because `StateManager`
-    /// inherits its associated types directly from its `StateTree` supertrait.
-    pub type StateManagerFor<CS>
-    where
-        CS: CommitmentScheme,
-    = dyn StateManager<
-        Commitment = <CS as CommitmentScheme>::Commitment,
-        Proof = <CS as CommitmentScheme>::Proof,
-    >;
-}
-
-/// Type aliases for transaction models.
-pub mod transaction {
-    use super::*;
-
-    /// The transaction type for a given transaction model.
-    pub type TransactionOf<TM> = <TM as TransactionModel>::Transaction;
-
-    /// The proof type for a given transaction model.
-    pub type ProofOf<TM> = <TM as TransactionModel>::Proof;
-
-    /// The commitment scheme type for a given transaction model.
-    pub type CommitmentSchemeOf<TM> = <TM as TransactionModel>::CommitmentScheme;
-}```
-
-###### Directory: core/src/validator
-
-####### Directory: core/src/validator/container
-
-######## File: core/src/validator/container/mod.rs
-#####*Size: 4.0K, Lines: 24, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/validator/container/mod.rs
-
-use crate::error::ValidatorError;
-use async_trait::async_trait;
-
-/// A trait for any component that can be started and stopped.
-#[async_trait]
-pub trait Container {
-    /// A unique identifier for the container.
-    fn id(&self) -> &'static str;
-    /// Returns true if the container is currently running.
-    fn is_running(&self) -> bool;
-    /// Starts the container's logic.
-    async fn start(&self) -> Result<(), ValidatorError>;
-    /// Stops the container's logic.
-    async fn stop(&self) -> Result<(), ValidatorError>;
-}
-
-/// A trait for the Guardian container, responsible for secure boot and attestation.
-pub trait GuardianContainer: Container {
-    /// Initiates the secure boot process.
-    fn start_boot(&self) -> Result<(), ValidatorError>;
-    /// Verifies the attestation of other containers.
-    fn verify_attestation(&self) -> Result<bool, ValidatorError>;
-}```
-
-####### Directory: core/src/validator/tests
-
-######## File: core/src/validator/tests/mod.rs
-#####*Size: 8.0K, Lines: 241, Type: ASCII text*
-
-```rust
-//! Tests for validator architecture trait definitions
-
-#[cfg(test)]
-mod tests {
-    use crate::validator::container::GuardianContainer;
-    use crate::validator::{Container, ValidatorModel, ValidatorType};
-
-    // Mock container implementation for testing
-    struct MockContainer {
-        id: String,
-        running: bool,
-    }
-
-    impl MockContainer {
-        fn new(id: &str) -> Self {
-            Self {
-                id: id.to_string(),
-                running: false,
-            }
-        }
-    }
-
-    impl Container for MockContainer {
-        fn start(&self) -> Result<(), String> {
-            // In a real implementation, this would start the container
-            Ok(())
-        }
-
-        fn stop(&self) -> Result<(), String> {
-            // In a real implementation, this would stop the container
-            Ok(())
-        }
-
-        fn is_running(&self) -> bool {
-            self.running
-        }
-
-        fn id(&self) -> &str {
-            &self.id
-        }
-    }
-
-    // Mock guardian container implementation for testing
-    struct MockGuardianContainer {
-        container: MockContainer,
-    }
-
-    impl MockGuardianContainer {
-        fn new(id: &str) -> Self {
-            Self {
-                container: MockContainer::new(id),
-            }
-        }
-    }
-
-    impl Container for MockGuardianContainer {
-        fn start(&self) -> Result<(), String> {
-            self.container.start()
-        }
-
-        fn stop(&self) -> Result<(), String> {
-            self.container.stop()
-        }
-
-        fn is_running(&self) -> bool {
-            self.container.is_running()
-        }
-
-        fn id(&self) -> &str {
-            self.container.id()
-        }
-    }
-
-    impl GuardianContainer for MockGuardianContainer {
-        fn start_boot(&self) -> Result<(), String> {
-            // In a real implementation, this would start the boot process
-            Ok(())
-        }
-
-        fn verify_attestation(&self) -> Result<bool, String> {
-            // In a real implementation, this would verify attestation
-            Ok(true)
-        }
-    }
-
-    // Mock validator model implementation for testing
-    struct MockStandardValidator {
-        guardian: MockGuardianContainer,
-        orchestration: MockContainer,
-        workload: MockContainer,
-        running: bool,
-    }
-
-    impl MockStandardValidator {
-        fn new() -> Self {
-            Self {
-                guardian: MockGuardianContainer::new("guardian"),
-                orchestration: MockContainer::new("orchestration"),
-                workload: MockContainer::new("workload"),
-                running: false,
-            }
-        }
-    }
-
-    impl ValidatorModel for MockStandardValidator {
-        fn start(&self) -> Result<(), String> {
-            // In a real implementation, this would start all containers in the correct order
-            self.guardian.start_boot()?;
-            self.orchestration.start()?;
-            self.workload.start()?;
-            Ok(())
-        }
-
-        fn stop(&self) -> Result<(), String> {
-            // In a real implementation, this would stop all containers in the correct order
-            self.workload.stop()?;
-            self.orchestration.stop()?;
-            Ok(())
-        }
-
-        fn is_running(&self) -> bool {
-            self.running
-        }
-
-        fn validator_type(&self) -> ValidatorType {
-            ValidatorType::Standard
-        }
-    }
-
-    // Mock hybrid validator implementation for testing
-    struct MockHybridValidator {
-        guardian: MockGuardianContainer,
-        orchestration: MockContainer,
-        workload: MockContainer,
-        interface: MockContainer,
-        api: MockContainer,
-        running: bool,
-    }
-
-    impl MockHybridValidator {
-        fn new() -> Self {
-            Self {
-                guardian: MockGuardianContainer::new("guardian"),
-                orchestration: MockContainer::new("orchestration"),
-                workload: MockContainer::new("workload"),
-                interface: MockContainer::new("interface"),
-                api: MockContainer::new("api"),
-                running: false,
-            }
-        }
-    }
-
-    impl ValidatorModel for MockHybridValidator {
-        fn start(&self) -> Result<(), String> {
-            // In a real implementation, this would start all containers in the correct order
-            self.guardian.start_boot()?;
-            self.orchestration.start()?;
-            self.workload.start()?;
-            self.interface.start()?;
-            self.api.start()?;
-            Ok(())
-        }
-
-        fn stop(&self) -> Result<(), String> {
-            // In a real implementation, this would stop all containers in the correct order
-            self.api.stop()?;
-            self.interface.stop()?;
-            self.workload.stop()?;
-            self.orchestration.stop()?;
-            Ok(())
-        }
-
-        fn is_running(&self) -> bool {
-            self.running
-        }
-
-        fn validator_type(&self) -> ValidatorType {
-            ValidatorType::Hybrid
-        }
-    }
-
-    #[test]
-    fn test_container() {
-        let container = MockContainer::new("test-container");
-
-        assert_eq!(container.id(), "test-container");
-        assert!(!container.is_running());
-
-        container.start().unwrap();
-        container.stop().unwrap();
-    }
-
-    #[test]
-    fn test_guardian_container() {
-        let guardian = MockGuardianContainer::new("guardian");
-
-        assert_eq!(guardian.id(), "guardian");
-        assert!(!guardian.is_running());
-
-        guardian.start().unwrap();
-        guardian.start_boot().unwrap();
-        assert!(guardian.verify_attestation().unwrap());
-        guardian.stop().unwrap();
-    }
-
-    #[test]
-    fn test_standard_validator() {
-        let validator = MockStandardValidator::new();
-
-        assert_eq!(validator.validator_type(), ValidatorType::Standard);
-        assert!(!validator.is_running());
-
-        validator.start().unwrap();
-        validator.stop().unwrap();
-    }
-
-    #[test]
-    fn test_hybrid_validator() {
-        let validator = MockHybridValidator::new();
-
-        assert_eq!(validator.validator_type(), ValidatorType::Hybrid);
-        assert!(!validator.is_running());
-
-        validator.start().unwrap();
-        validator.stop().unwrap();
-    }
-
-    #[test]
-    fn test_validator_type_comparison() {
-        assert_eq!(ValidatorType::Standard, ValidatorType::Standard);
-        assert_eq!(ValidatorType::Hybrid, ValidatorType::Hybrid);
-        assert_ne!(ValidatorType::Standard, ValidatorType::Hybrid);
-    }
-
-    // TODO: Add more comprehensive tests covering:
-    // - Container lifecycle management
-    // - Error handling in container operations
-    // - Security boundaries between containers
-    // - Container attestation verification
-    // - Complex validator configurations
-}
-```
-
-####### File: core/src/validator/mod.rs
-####*Size: 4.0K, Lines: 62, Type: ASCII text*
-
-```rust
-// Path: crates/core/src/validator/mod.rs
-
-use crate::{
-    config::WorkloadConfig,
-    error::ValidatorError,
-    state::{StateManager, StateTree},
-};
-use std::fmt::Debug;
-use std::sync::Arc;
-use tokio::sync::Mutex;
-
-// FIX: Declare the container module so it's part of the `validator` module.
-pub mod container;
-
-// FIX: Publicly re-export the traits using a relative path.
-pub use container::{Container, GuardianContainer};
-
-/// A container responsible for executing transactions and managing state.
-#[derive(Debug)]
-pub struct WorkloadContainer<ST: StateManager> {
-    _config: WorkloadConfig,
-    state_tree: Arc<Mutex<ST>>,
-}
-
-impl<ST> WorkloadContainer<ST>
-where
-    ST: StateManager,
-{
-    pub fn new(config: WorkloadConfig, state_tree: ST) -> Self {
-        Self {
-            _config: config,
-            state_tree: Arc::new(Mutex::new(state_tree)),
-        }
-    }
-
-    pub fn state_tree(&self) -> Arc<Mutex<ST>> {
-        self.state_tree.clone()
-    }
-}
-
-#[async_trait::async_trait]
-impl<ST> Container for WorkloadContainer<ST>
-where
-    ST: StateManager + StateTree + Send + Sync + 'static,
-{
-    async fn start(&self) -> Result<(), ValidatorError> {
-        log::info!("WorkloadContainer started.");
-        Ok(())
-    }
-
-    async fn stop(&self) -> Result<(), ValidatorError> {
-        log::info!("WorkloadContainer stopped.");
-        Ok(())
-    }
-
-    fn is_running(&self) -> bool {
-        true
-    }
-
-    fn id(&self) -> &'static str {
-        "workload_container"
-    }
-}```
-
-####### File: core/src/validator/types.rs
-####*Size: 4.0K, Lines: 32, Type: ASCII text*
-
-```rust
-//! Validator type definitions
-use crate::error::ValidatorError;
-
-/// Validator model trait
-pub trait ValidatorModel {
-    /// An associated type representing the specific WorkloadContainer implementation this validator uses.
-    /// This allows us to access it generically without knowing the validator's concrete type.
-    type WorkloadContainerType;
-
-    /// Start the validator
-    fn start(&self) -> Result<(), ValidatorError>;
-
-    /// Stop the validator
-    fn stop(&self) -> Result<(), ValidatorError>;
-
-    /// Check if the validator is running
-    fn is_running(&self) -> bool;
-
-    /// Get the validator type
-    fn validator_type(&self) -> ValidatorType;
-
-    /// Provides generic access to the validator's workload container.
-    fn workload_container(&self) -> &Self::WorkloadContainerType;
-}
-
-/// Validator types
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum ValidatorType {
-    /// Standard validator (3 containers)
-    Standard,
-    /// Hybrid validator (5 containers)
-    Hybrid,
-}```
-
-###### File: core/src/lib.rs
-###*Size: 4.0K, Lines: 36, Type: ASCII text*
-
-```rust
-//! # DePIN SDK Core
-//!
-//! Core traits and interfaces for the DePIN SDK.
-
-pub mod app;
-pub mod chain;
-pub mod commitment;
-pub mod component;
-// NEW: A module for shared configuration structs.
-pub mod config;
-pub mod crypto;
-pub mod error;
-pub mod homomorphic;
-pub mod ibc;
-pub mod services;
-pub mod state;
-pub mod transaction;
-pub mod types;
-pub mod validator;
-
-#[cfg(test)]
-pub mod test_utils;
-
-// Re-export key traits and types for convenience
-pub use app::*;
-pub use chain::*;
-pub use commitment::*;
-pub use component::*;
-pub use config::*;
-pub use crypto::*;
-pub use error::*;
-pub use homomorphic::*;
-pub use ibc::*;
-pub use services::*;
-pub use state::*;
-pub use transaction::*;
-pub use validator::*;```
-
-##### File: core/Cargo.toml
-##*Size: 4.0K, Lines: 23, Type: ASCII text*
-
-```toml
-# Path: crates/core/Cargo.toml
-
-[package]
-name = "depin-sdk-core"
-version = "0.1.0"
-edition = "2021"
-description = "Core types and traits for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-# FIX: Add async-trait as a dependency, which is now required by the Container trait.
-async-trait = { workspace = true }
-log = { workspace = true }
-serde = { workspace = true, features = ["derive"] }
-serde_json = { workspace = true }
-thiserror = { workspace = true }
-bytes = { workspace = true }
-tokio = { workspace = true, features = ["sync"] }
-
-[features]
-default = []
-homomorphic = []
-post-quantum = []
-```
-
-#### Directory: crypto
-
-##### Directory: crypto/src
-
-###### Directory: crypto/src/algorithms
-
-####### Directory: crypto/src/algorithms/hash
-
-######## File: crypto/src/algorithms/hash/mod.rs
-#####*Size: 4.0K, Lines: 104, Type: ASCII text*
-
-```rust
-// crates/crypto/src/algorithms/hash/mod.rs
-//! Cryptographic hash functions using dcrypt
-
-use dcrypt::algorithms::hash::sha2::{Sha256 as DcryptSha256, Sha512 as DcryptSha512};
-use dcrypt::algorithms::hash::{HashFunction as DcryptHashFunction};
-use dcrypt::algorithms::ByteSerializable;
-
-pub mod tests;
-
-/// Hash function trait
-pub trait HashFunction {
-    /// Hash a message and return the digest
-    fn hash(&self, message: &[u8]) -> Vec<u8>;
-    
-    /// Get the digest size in bytes
-    fn digest_size(&self) -> usize;
-    
-    /// Get the name of the hash function
-    fn name(&self) -> &str;
-}
-
-/// SHA-256 hash function implementation using dcrypt
-#[derive(Default, Clone)]
-pub struct Sha256Hash;
-
-impl HashFunction for Sha256Hash {
-    fn hash(&self, message: &[u8]) -> Vec<u8> {
-        // Use dcrypt's SHA-256 implementation
-        match DcryptSha256::digest(message) {
-            Ok(digest) => digest.to_bytes(),
-            Err(_) => panic!("SHA-256 hashing failed"),
-        }
-    }
-    
-    fn digest_size(&self) -> usize {
-        32 // 256 bits = 32 bytes
-    }
-    
-    fn name(&self) -> &str {
-        "SHA-256"
-    }
-}
-
-/// SHA-512 hash function implementation using dcrypt
-#[derive(Default, Clone)]
-pub struct Sha512Hash;
-
-impl HashFunction for Sha512Hash {
-    fn hash(&self, message: &[u8]) -> Vec<u8> {
-        // Use dcrypt's SHA-512 implementation
-        match DcryptSha512::digest(message) {
-            Ok(digest) => digest.to_bytes(),
-            Err(_) => panic!("SHA-512 hashing failed"),
-        }
-    }
-    
-    fn digest_size(&self) -> usize {
-        64 // 512 bits = 64 bytes
-    }
-    
-    fn name(&self) -> &str {
-        "SHA-512"
-    }
-}
-
-/// Generic hasher that can use any hash function
-pub struct GenericHasher<H: HashFunction> {
-    /// Hash function implementation
-    hash_function: H,
-}
-
-impl<H: HashFunction> GenericHasher<H> {
-    /// Create a new hasher with the given hash function
-    pub fn new(hash_function: H) -> Self {
-        Self { hash_function }
-    }
-    
-    /// Hash a message
-    pub fn hash(&self, message: &[u8]) -> Vec<u8> {
-        self.hash_function.hash(message)
-    }
-    
-    /// Get the digest size in bytes
-    pub fn digest_size(&self) -> usize {
-        self.hash_function.digest_size()
-    }
-    
-    /// Get the name of the hash function
-    pub fn name(&self) -> &str {
-        self.hash_function.name()
-    }
-}
-
-// Additional convenience functions
-/// Create a SHA-256 hash of any type that can be referenced as bytes
-pub fn sha256<T: AsRef<[u8]>>(data: T) -> Vec<u8> {
-    let hasher = Sha256Hash::default();
-    hasher.hash(data.as_ref())
-}
-
-/// Create a SHA-512 hash of any type that can be referenced as bytes
-pub fn sha512<T: AsRef<[u8]>>(data: T) -> Vec<u8> {
-    let hasher = Sha512Hash::default();
-    hasher.hash(data.as_ref())
-}```
-
-######## File: crypto/src/algorithms/hash/tests.rs
-#####*Size: 4.0K, Lines: 44, Type: ASCII text*
-
-```rust
-//! Tests for hash function implementations
-
-#[cfg(test)]
-mod tests {
-    use super::super::*;
-
-    #[test]
-    fn test_hash_functions() {
-        let message = b"test message";
-
-        let sha256 = Sha256Hash::default();
-        let sha512 = Sha512Hash::default();
-
-        let sha256_hash = sha256.hash(message);
-        let sha512_hash = sha512.hash(message);
-
-        assert_eq!(sha256_hash.len(), sha256.digest_size());
-        assert_eq!(sha512_hash.len(), sha512.digest_size());
-
-        assert_eq!(sha256.digest_size(), 32);
-        assert_eq!(sha512.digest_size(), 64);
-
-        // Verify deterministic behavior
-        assert_eq!(sha256.hash(message), sha256.hash(message));
-        assert_eq!(sha512.hash(message), sha512.hash(message));
-    }
-
-    #[test]
-    fn test_generic_hasher() {
-        let message = b"test message";
-
-        let sha256_hasher = GenericHasher::new(Sha256Hash::default());
-        let sha512_hasher = GenericHasher::new(Sha512Hash::default());
-
-        let sha256_hash = sha256_hasher.hash(message);
-        let sha512_hash = sha512_hasher.hash(message);
-
-        assert_eq!(sha256_hash.len(), sha256_hasher.digest_size());
-        assert_eq!(sha512_hash.len(), sha512_hasher.digest_size());
-
-        assert_eq!(sha256_hasher.digest_size(), 32);
-        assert_eq!(sha512_hasher.digest_size(), 64);
-    }
-}
-```
-
-####### File: crypto/src/algorithms/mod.rs
-####*Size: 4.0K, Lines: 0, Type: ASCII text, with no line terminators*
-
-```rust
-pub mod hash;```
-
-###### Directory: crypto/src/kem
-
-####### Directory: crypto/src/kem/ecdh
-
-######## Directory: crypto/src/kem/ecdh/tests
-
-######### File: crypto/src/kem/ecdh/tests/mod.rs
-######*Size: 8.0K, Lines: 157, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/ecdh/tests/mod.rs
-use super::*;
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{Encapsulated, KeyEncapsulation, KemKeyPair, DecapsulationKey, EncapsulationKey};
-
-#[test]
-fn test_ecdh_keypair_generation() {
-    // Test P256 curve (K256)
-    let curve = EcdhCurve::P256;
-    let kem = EcdhKEM::new(curve);
-    let keypair = kem.generate_keypair();
-
-    // Verify key sizes match the expected sizes for K256
-    assert_eq!(keypair.public_key.to_bytes().len(), 33); // Compressed K256 point
-    assert_eq!(keypair.private_key.to_bytes().len(), 32); // K256 scalar
-
-    // Ensure keys are different
-    assert_ne!(
-        keypair.public_key.to_bytes(),
-        keypair.private_key.to_bytes()
-    );
-}
-
-#[test]
-#[should_panic(expected = "P384 and P521 curves are not yet implemented")]
-fn test_ecdh_p384_not_implemented() {
-    let kem = EcdhKEM::new(EcdhCurve::P384);
-    kem.generate_keypair();
-}
-
-#[test]
-#[should_panic(expected = "P384 and P521 curves are not yet implemented")]
-fn test_ecdh_p521_not_implemented() {
-    let kem = EcdhKEM::new(EcdhCurve::P521);
-    kem.generate_keypair();
-}
-
-#[test]
-fn test_ecdh_encapsulation() {
-    let curve = EcdhCurve::P256;
-    let kem = EcdhKEM::new(curve);
-    let keypair = kem.generate_keypair();
-
-    // Encapsulate a key
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-
-    // Verify the encapsulated data sizes
-    assert_eq!(encapsulated.ciphertext().len(), 33); // Compressed K256 point
-    assert_eq!(encapsulated.shared_secret().len(), 32); // SHA-256 output
-
-    // Decapsulate and verify
-    let shared_secret = kem.decapsulate(&keypair.private_key, &encapsulated);
-
-    // We should get a valid shared secret
-    assert!(shared_secret.is_some());
-    let shared_secret = shared_secret.unwrap();
-
-    // The shared secret should match what's in the encapsulated key
-    assert_eq!(shared_secret, encapsulated.shared_secret());
-}
-
-#[test]
-fn test_ecdh_security_level_mapping() {
-    // Test Level1 -> P256
-    let kem = EcdhKEM::with_security_level(SecurityLevel::Level1);
-    assert_eq!(kem.curve, EcdhCurve::P256);
-
-    // Test Level3 -> P384
-    let kem = EcdhKEM::with_security_level(SecurityLevel::Level3);
-    assert_eq!(kem.curve, EcdhCurve::P384);
-
-    // Test Level5 -> P521
-    let kem = EcdhKEM::with_security_level(SecurityLevel::Level5);
-    assert_eq!(kem.curve, EcdhCurve::P521);
-}
-
-#[test]
-fn test_ecdh_serialization() {
-    let kem = EcdhKEM::new(EcdhCurve::P256);
-    let keypair = kem.generate_keypair();
-
-    // Serialize keys
-    let public_key_bytes = keypair.public_key.to_bytes();
-    let private_key_bytes = keypair.private_key.to_bytes();
-
-    // Deserialize keys
-    let restored_public_key = EcdhPublicKey::from_bytes(&public_key_bytes).unwrap();
-    let restored_private_key = EcdhPrivateKey::from_bytes(&private_key_bytes).unwrap();
-
-    // Encapsulate with original key
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-    let ciphertext_bytes = encapsulated.to_bytes();
-
-    // Deserialize ciphertext
-    let restored_encapsulated = EcdhEncapsulated::from_bytes(&ciphertext_bytes).unwrap();
-
-    // Decapsulate with restored key and restored ciphertext
-    let shared_secret = kem.decapsulate(&restored_private_key, &restored_encapsulated);
-
-    // We should still get a valid shared secret
-    assert!(shared_secret.is_some());
-
-    // Verify that different key pairs produce different shared secrets
-    let keypair2 = kem.generate_keypair();
-    let encapsulated2 = kem.encapsulate(&keypair2.public_key);
-
-    // Different key pairs should generate different shared secrets
-    assert_ne!(encapsulated.shared_secret(), encapsulated2.shared_secret());
-
-    // Different public keys should produce different ciphertexts
-    assert_ne!(encapsulated.ciphertext(), encapsulated2.ciphertext());
-
-    // Decapsulating with the wrong private key should produce a different result
-    let wrong_shared_secret = kem.decapsulate(&keypair2.private_key, &encapsulated);
-    assert!(wrong_shared_secret.is_some());
-    assert_ne!(wrong_shared_secret.unwrap(), encapsulated.shared_secret());
-}
-
-#[test]
-fn test_ecdh_dcrypt_compatibility() {
-    // Test that the dcrypt wrapper works correctly
-    let kem = EcdhKEM::new(EcdhCurve::P256);
-    let keypair1 = kem.generate_keypair();
-    let keypair2 = kem.generate_keypair();
-
-    // Test encapsulation/decapsulation cycle
-    let encapsulated = kem.encapsulate(&keypair1.public_key);
-    let shared_secret = kem.decapsulate(&keypair1.private_key, &encapsulated);
-    
-    assert!(shared_secret.is_some());
-    assert_eq!(shared_secret.unwrap().len(), 32); // K256 produces 32-byte shared secrets
-
-    // Test that using wrong keys produces different results
-    let wrong_secret = kem.decapsulate(&keypair2.private_key, &encapsulated);
-    assert!(wrong_secret.is_some());
-    assert_ne!(wrong_secret.unwrap(), encapsulated.shared_secret());
-}
-
-#[test]
-fn test_ecdh_independent_verification() {
-    // Test that keys can be used independently
-    let kem = EcdhKEM::new(EcdhCurve::P256);
-    let keypair = kem.generate_keypair();
-    
-    // Serialize and deserialize to ensure independence
-    let pk_bytes = keypair.public_key.to_bytes();
-    let sk_bytes = keypair.private_key.to_bytes();
-    
-    let pk = EcdhPublicKey::from_bytes(&pk_bytes).unwrap();
-    let sk = EcdhPrivateKey::from_bytes(&sk_bytes).unwrap();
-    
-    // Use the deserialized keys
-    let encapsulated = kem.encapsulate(&pk);
-    let shared_secret = kem.decapsulate(&sk, &encapsulated);
-    
-    assert!(shared_secret.is_some());
-    assert_eq!(shared_secret.unwrap(), encapsulated.shared_secret());
-}```
-
-######## File: crypto/src/kem/ecdh/mod.rs
-#####*Size: 12K, Lines: 276, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/ecdh/mod.rs
-//! ECDH key encapsulation mechanism using dcrypt
-
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{
-    DecapsulationKey, Encapsulated, EncapsulationKey, KemKeyPair, KeyEncapsulation,
-    SerializableKey,
-};
-use dcrypt::api::Kem;
-use dcrypt::kem::ecdh::{
-    EcdhK256,
-    EcdhK256Ciphertext,
-    EcdhK256PublicKey,
-    EcdhK256SecretKey,
-    EcdhK256SharedSecret,
-    // Note: dcrypt might not have P384/P521 implementations yet
-    // This is a simplified version using only K256
-};
-use rand::{CryptoRng, RngCore};
-
-/// ECDH curve type
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum EcdhCurve {
-    /// NIST P-256 curve (128-bit security) - using K256 (secp256k1) as substitute
-    P256,
-    /// NIST P-384 curve (192-bit security) - not available in dcrypt
-    P384,
-    /// NIST P-521 curve (256-bit security) - not available in dcrypt
-    P521,
-}
-
-impl EcdhCurve {
-    /// Get the appropriate curve for a security level
-    pub fn from_security_level(level: SecurityLevel) -> Self {
-        match level {
-            SecurityLevel::Level1 => EcdhCurve::P256,
-            SecurityLevel::Level3 => EcdhCurve::P384,
-            SecurityLevel::Level5 => EcdhCurve::P521,
-            _ => EcdhCurve::P256, // Default to P256
-        }
-    }
-}
-
-/// ECDH key encapsulation mechanism
-pub struct EcdhKEM {
-    /// The curve to use
-    pub(crate) curve: EcdhCurve,
-}
-
-/// ECDH key pair
-pub struct EcdhKeyPair {
-    /// Public key
-    pub public_key: EcdhPublicKey,
-    /// Private key
-    pub private_key: EcdhPrivateKey,
-    /// Curve type
-    curve: EcdhCurve,
-}
-
-/// ECDH public key wrapper
-#[derive(Clone)]
-pub enum EcdhPublicKey {
-    K256(EcdhK256PublicKey),
-    // P384 and P521 would need their own dcrypt implementations
-    P384(Vec<u8>), // Placeholder
-    P521(Vec<u8>), // Placeholder
-}
-
-/// ECDH private key wrapper
-#[derive(Clone)]
-pub enum EcdhPrivateKey {
-    K256(EcdhK256SecretKey),
-    // P384 and P521 would need their own dcrypt implementations
-    P384(Vec<u8>), // Placeholder
-    P521(Vec<u8>), // Placeholder
-}
-
-/// ECDH encapsulated key
-pub struct EcdhEncapsulated {
-    /// Ciphertext
-    ciphertext: Vec<u8>,
-    /// Shared secret
-    shared_secret: Vec<u8>,
-    /// Curve type
-    curve: EcdhCurve,
-}
-
-impl EcdhKEM {
-    /// Create a new ECDH KEM with the specified curve
-    pub fn new(curve: EcdhCurve) -> Self {
-        Self { curve }
-    }
-
-    /// Create a new ECDH KEM with the specified security level
-    pub fn with_security_level(level: SecurityLevel) -> Self {
-        Self {
-            curve: EcdhCurve::from_security_level(level),
-        }
-    }
-}
-
-impl KeyEncapsulation for EcdhKEM {
-    type KeyPair = EcdhKeyPair;
-    type PublicKey = EcdhPublicKey;
-    type PrivateKey = EcdhPrivateKey;
-    type Encapsulated = EcdhEncapsulated;
-
-    fn generate_keypair(&self) -> Self::KeyPair {
-        let mut rng = rand::thread_rng();
-        
-        match self.curve {
-            EcdhCurve::P256 => {
-                // Use K256 from dcrypt
-                let (pk, sk) = EcdhK256::keypair(&mut rng)
-                    .expect("Failed to generate K256 keypair");
-                EcdhKeyPair {
-                    public_key: EcdhPublicKey::K256(pk),
-                    private_key: EcdhPrivateKey::K256(sk),
-                    curve: self.curve,
-                }
-            }
-            EcdhCurve::P384 | EcdhCurve::P521 => {
-                // Not implemented in dcrypt yet
-                panic!("P384 and P521 curves are not yet implemented in dcrypt");
-            }
-        }
-    }
-
-    fn encapsulate(&self, public_key: &Self::PublicKey) -> Self::Encapsulated {
-        let mut rng = rand::thread_rng();
-        
-        match (self.curve, public_key) {
-            (EcdhCurve::P256, EcdhPublicKey::K256(pk)) => {
-                let (ct, ss) = EcdhK256::encapsulate(&mut rng, pk)
-                    .expect("Failed to encapsulate with K256");
-                
-                EcdhEncapsulated {
-                    ciphertext: ct.to_bytes(),
-                    shared_secret: ss.to_bytes(),
-                    curve: EcdhCurve::P256,
-                }
-            }
-            _ => panic!("Curve mismatch or unsupported curve in encapsulation"),
-        }
-    }
-
-    fn decapsulate(
-        &self,
-        private_key: &Self::PrivateKey,
-        encapsulated: &Self::Encapsulated,
-    ) -> Option<Vec<u8>> {
-        match (self.curve, private_key) {
-            (EcdhCurve::P256, EcdhPrivateKey::K256(sk)) => {
-                // Reconstruct the ciphertext from bytes
-                let ct = EcdhK256Ciphertext::from_bytes(&encapsulated.ciphertext)
-                    .ok()?;
-                
-                let ss = EcdhK256::decapsulate(sk, &ct)
-                    .ok()?;
-                
-                Some(ss.to_bytes())
-            }
-            _ => None,
-        }
-    }
-}
-
-impl KemKeyPair for EcdhKeyPair {
-    type PublicKey = EcdhPublicKey;
-    type PrivateKey = EcdhPrivateKey;
-
-    fn public_key(&self) -> Self::PublicKey {
-        self.public_key.clone()
-    }
-
-    fn private_key(&self) -> Self::PrivateKey {
-        self.private_key.clone()
-    }
-}
-
-// EcdhPublicKey implements the EncapsulationKey trait
-impl SerializableKey for EcdhPublicKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        match self {
-            EcdhPublicKey::K256(pk) => pk.to_bytes(),
-            EcdhPublicKey::P384(bytes) => bytes.clone(),
-            EcdhPublicKey::P521(bytes) => bytes.clone(),
-        }
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Try to determine the curve from the public key size
-        match bytes.len() {
-            33 => {
-                // K256 compressed point
-                let pk = EcdhK256PublicKey::from_bytes(bytes)
-                    .map_err(|e| format!("Failed to deserialize K256 public key: {:?}", e))?;
-                Ok(EcdhPublicKey::K256(pk))
-            }
-            49 => Ok(EcdhPublicKey::P384(bytes.to_vec())),
-            67 => Ok(EcdhPublicKey::P521(bytes.to_vec())),
-            _ => Err(format!("Invalid ECDH public key size: {}", bytes.len())),
-        }
-    }
-}
-
-impl EncapsulationKey for EcdhPublicKey {
-    // EncapsulationKey trait has no additional methods beyond SerializableKey
-}
-
-// EcdhPrivateKey implements the DecapsulationKey trait
-impl SerializableKey for EcdhPrivateKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        match self {
-            EcdhPrivateKey::K256(sk) => sk.to_bytes().to_vec(),
-            EcdhPrivateKey::P384(bytes) => bytes.clone(),
-            EcdhPrivateKey::P521(bytes) => bytes.clone(),
-        }
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Try to determine the curve from the private key size
-        match bytes.len() {
-            32 => {
-                // K256 scalar
-                let sk = EcdhK256SecretKey::from_bytes(bytes)
-                    .map_err(|e| format!("Failed to deserialize K256 private key: {:?}", e))?;
-                Ok(EcdhPrivateKey::K256(sk))
-            }
-            48 => Ok(EcdhPrivateKey::P384(bytes.to_vec())),
-            66 => Ok(EcdhPrivateKey::P521(bytes.to_vec())),
-            _ => Err(format!("Invalid ECDH private key size: {}", bytes.len())),
-        }
-    }
-}
-
-impl DecapsulationKey for EcdhPrivateKey {
-    // DecapsulationKey trait has no additional methods beyond SerializableKey
-}
-
-// EcdhEncapsulated implements the Encapsulated trait
-impl SerializableKey for EcdhEncapsulated {
-    fn to_bytes(&self) -> Vec<u8> {
-        self.ciphertext.clone()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Try to determine the curve from the ciphertext size
-        let curve = match bytes.len() {
-            33 => EcdhCurve::P256,
-            49 => EcdhCurve::P384,
-            67 => EcdhCurve::P521,
-            _ => return Err(format!("Invalid ECDH ciphertext size: {}", bytes.len())),
-        };
-
-        // We can't recover the shared secret from just the ciphertext
-        // This will need to be decapsulated using a private key to get the shared secret
-        Ok(EcdhEncapsulated {
-            ciphertext: bytes.to_vec(),
-            shared_secret: vec![0; 32], // Placeholder until decapsulated
-            curve,
-        })
-    }
-}
-
-impl Encapsulated for EcdhEncapsulated {
-    fn ciphertext(&self) -> &[u8] {
-        &self.ciphertext
-    }
-
-    fn shared_secret(&self) -> &[u8] {
-        &self.shared_secret
-    }
-}
-
-#[cfg(test)]
-mod tests;```
-
-####### Directory: crypto/src/kem/hybrid
-
-######## Directory: crypto/src/kem/hybrid/tests
-
-######### File: crypto/src/kem/hybrid/tests/mod.rs
-######*Size: 8.0K, Lines: 207, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/hybrid/tests/mod.rs
-use super::*;
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{Encapsulated, KeyEncapsulation, KemKeyPair, DecapsulationKey, EncapsulationKey};
-
-#[test]
-fn test_hybrid_keypair_generation() {
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-
-    // Verify key sizes match the expected sizes
-    // ECDH K256 (33) + Kyber768 (1184) = 1217
-    assert_eq!(keypair.public_key.to_bytes().len(), 1217);
-    // ECDH K256 (32) + Kyber768 (2400) = 2432
-    assert_eq!(keypair.private_key.to_bytes().len(), 2432);
-
-    // Ensure keys are different
-    assert_ne!(
-        keypair.public_key.to_bytes(),
-        keypair.private_key.to_bytes()
-    );
-}
-
-#[test]
-#[should_panic(expected = "Hybrid KEM currently only supports Level3 security")]
-fn test_hybrid_unsupported_security_levels() {
-    // Test Level1
-    let _ = HybridKEM::new(SecurityLevel::Level1);
-}
-
-#[test]
-#[should_panic(expected = "Hybrid KEM currently only supports Level3 security")]
-fn test_hybrid_unsupported_security_level5() {
-    // Test Level5
-    let _ = HybridKEM::new(SecurityLevel::Level5);
-}
-
-#[test]
-fn test_hybrid_encapsulation() {
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-
-    // Encapsulate a key
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-
-    // Verify the encapsulated data sizes
-    // ECDH K256 (33) + Kyber768 (1088) = 1121
-    assert_eq!(encapsulated.ciphertext().len(), 1121);
-    // Combined shared secret should be 32 bytes (HKDF output)
-    assert_eq!(encapsulated.shared_secret().len(), 32);
-
-    // Decapsulate and verify
-    let shared_secret = kem.decapsulate(&keypair.private_key, &encapsulated);
-
-    // We should get a valid shared secret
-    assert!(shared_secret.is_some());
-    let shared_secret = shared_secret.unwrap();
-
-    // The shared secret should match what's in the encapsulated key
-    assert_eq!(shared_secret, encapsulated.shared_secret());
-    assert_eq!(shared_secret.len(), 32);
-}
-
-#[test]
-fn test_hybrid_multiple_encapsulations() {
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-
-    // Multiple encapsulations with the same public key should produce different results
-    let encapsulated1 = kem.encapsulate(&keypair.public_key);
-    let encapsulated2 = kem.encapsulate(&keypair.public_key);
-
-    // Ciphertexts should be different due to randomness
-    assert_ne!(encapsulated1.ciphertext(), encapsulated2.ciphertext());
-    // Shared secrets should be different
-    assert_ne!(encapsulated1.shared_secret(), encapsulated2.shared_secret());
-
-    // But both should decapsulate correctly
-    let shared_secret1 = kem.decapsulate(&keypair.private_key, &encapsulated1).unwrap();
-    let shared_secret2 = kem.decapsulate(&keypair.private_key, &encapsulated2).unwrap();
-
-    assert_eq!(shared_secret1, encapsulated1.shared_secret());
-    assert_eq!(shared_secret2, encapsulated2.shared_secret());
-}
-
-#[test]
-fn test_hybrid_wrong_key_decapsulation() {
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair1 = kem.generate_keypair();
-    let keypair2 = kem.generate_keypair();
-
-    // Encapsulate with keypair1's public key
-    let encapsulated = kem.encapsulate(&keypair1.public_key);
-
-    // Try to decapsulate with keypair2's private key
-    let wrong_shared_secret = kem.decapsulate(&keypair2.private_key, &encapsulated);
-
-    // Should still produce a result (KEMs don't fail on wrong key)
-    assert!(wrong_shared_secret.is_some());
-    // But it should be different from the correct shared secret
-    assert_ne!(wrong_shared_secret.unwrap(), encapsulated.shared_secret());
-}
-
-#[test]
-fn test_hybrid_serialization() {
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-
-    // Serialize keys
-    let public_key_bytes = keypair.public_key.to_bytes();
-    let private_key_bytes = keypair.private_key.to_bytes();
-
-    // Deserialize keys
-    let restored_public_key = HybridPublicKey::from_bytes(&public_key_bytes).unwrap();
-    let restored_private_key = HybridPrivateKey::from_bytes(&private_key_bytes).unwrap();
-
-    // Encapsulate with original key
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-    let ciphertext_bytes = encapsulated.to_bytes();
-
-    // Deserialize ciphertext
-    let restored_encapsulated = HybridEncapsulated::from_bytes(&ciphertext_bytes).unwrap();
-
-    // Decapsulate with restored key and restored ciphertext
-    let shared_secret = kem.decapsulate(&restored_private_key, &restored_encapsulated);
-
-    // We should still get a valid shared secret
-    assert!(shared_secret.is_some());
-
-    // Verify the original encapsulated ciphertext matches the serialized version
-    assert_eq!(encapsulated.ciphertext(), restored_encapsulated.ciphertext());
-}
-
-#[test]
-fn test_hybrid_invalid_serialization() {
-    // Test invalid public key sizes
-    let too_short_pk = vec![0u8; 100];
-    assert!(HybridPublicKey::from_bytes(&too_short_pk).is_err());
-    
-    let too_long_pk = vec![0u8; 2000];
-    assert!(HybridPublicKey::from_bytes(&too_long_pk).is_err());
-
-    // Test invalid private key sizes
-    let too_short_sk = vec![0u8; 100];
-    assert!(HybridPrivateKey::from_bytes(&too_short_sk).is_err());
-    
-    let too_long_sk = vec![0u8; 3000];
-    assert!(HybridPrivateKey::from_bytes(&too_long_sk).is_err());
-
-    // Test invalid ciphertext sizes
-    let too_short_ct = vec![0u8; 100];
-    assert!(HybridEncapsulated::from_bytes(&too_short_ct).is_err());
-    
-    let too_long_ct = vec![0u8; 2000];
-    assert!(HybridEncapsulated::from_bytes(&too_long_ct).is_err());
-}
-
-#[test]
-fn test_hybrid_security_properties() {
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-
-    // Test that the shared secret is deterministic for a given ciphertext
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-    
-    // Multiple decapsulations of the same ciphertext should produce the same result
-    let shared_secret1 = kem.decapsulate(&keypair.private_key, &encapsulated).unwrap();
-    let shared_secret2 = kem.decapsulate(&keypair.private_key, &encapsulated).unwrap();
-    
-    assert_eq!(shared_secret1, shared_secret2);
-}
-
-#[test]
-fn test_hybrid_default_constructor() {
-    let kem = HybridKEM::default();
-    let keypair = kem.generate_keypair();
-    
-    // Should use Level3 by default
-    assert_eq!(keypair.level, SecurityLevel::Level3);
-    
-    // Should work normally
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-    let shared_secret = kem.decapsulate(&keypair.private_key, &encapsulated);
-    
-    assert!(shared_secret.is_some());
-    assert_eq!(shared_secret.unwrap(), encapsulated.shared_secret());
-}
-
-#[test]
-fn test_hybrid_independent_verification() {
-    // Test that keys can be used independently after serialization
-    let kem = HybridKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-    
-    // Serialize and deserialize to ensure independence
-    let pk_bytes = keypair.public_key.to_bytes();
-    let sk_bytes = keypair.private_key.to_bytes();
-    
-    let pk = HybridPublicKey::from_bytes(&pk_bytes).unwrap();
-    let sk = HybridPrivateKey::from_bytes(&sk_bytes).unwrap();
-    
-    // Use the deserialized keys
-    let encapsulated = kem.encapsulate(&pk);
-    let shared_secret = kem.decapsulate(&sk, &encapsulated);
-    
-    assert!(shared_secret.is_some());
-    assert_eq!(shared_secret.unwrap(), encapsulated.shared_secret());
-}```
-
-######## File: crypto/src/kem/hybrid/ecdh_kyber.rs
-#####*Size: 4.0K, Lines: 36, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/hybrid/ecdh_kyber.rs
-//! ECDH-Kyber hybrid key encapsulation mechanism
-//! 
-//! This module provides specific hybrid combinations of ECDH and Kyber KEMs.
-
-use super::{HybridKEM, HybridKeyPair, HybridPublicKey, HybridPrivateKey, HybridEncapsulated};
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{KeyEncapsulation, KemKeyPair, Encapsulated};
-
-/// ECDH-P256 + Kyber768 hybrid KEM
-/// 
-/// Provides Level3 security by combining:
-/// - ECDH on P-256 curve (128-bit classical security)
-/// - Kyber768 (192-bit post-quantum security)
-/// 
-/// This is a convenience type alias for HybridKEM configured with Level3 security.
-pub type EcdhP256Kyber768 = HybridKEM;
-
-/// ECDH-P256 + Kyber768 key pair
-pub type EcdhP256Kyber768KeyPair = HybridKeyPair;
-
-/// ECDH-P256 + Kyber768 public key
-pub type EcdhP256Kyber768PublicKey = HybridPublicKey;
-
-/// ECDH-P256 + Kyber768 private key
-pub type EcdhP256Kyber768PrivateKey = HybridPrivateKey;
-
-/// ECDH-P256 + Kyber768 encapsulated ciphertext
-pub type EcdhP256Kyber768Encapsulated = HybridEncapsulated;
-
-// Note: EcdhP256Kyber768 is a type alias for HybridKEM and inherits all its methods.
-// To create an instance, use: HybridKEM::new(SecurityLevel::Level3)
-// or HybridKEM::default() which defaults to Level3.
-
-// Future implementations could include:
-// - EcdhP256Kyber512 for Level1 security
-// - EcdhP521Kyber1024 for Level5 security```
-
-######## File: crypto/src/kem/hybrid/mod.rs
-#####*Size: 12K, Lines: 277, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/hybrid/mod.rs
-//! Hybrid key encapsulation mechanism using dcrypt's EcdhKyber768
-
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{
-    DecapsulationKey, Encapsulated, EncapsulationKey, KemKeyPair, KeyEncapsulation,
-    SerializableKey,
-};
-
-// Import from dcrypt - adjust these based on your actual dcrypt dependency structure
-// Option 1: If dcrypt re-exports everything from root
-use dcrypt::api::Kem;
-use dcrypt::kem::ecdh::p256::EcdhP256SecretKey;
-use dcrypt::kem::kyber::KyberSecretKey;
-
-// Option 2: If hybrid is a separate crate, use:
-// use dcrypt_hybrid::kem::ecdh_kyber::{...}
-// 
-// For now, assuming the hybrid module is under dcrypt with proper path:
-use dcrypt::hybrid::kem::ecdh_kyber::{
-    EcdhKyber768, 
-    HybridCiphertext, 
-    HybridPublicKey as DcryptHybridPublicKey,
-    HybridSecretKey as DcryptHybridSecretKey,
-};
-use rand::thread_rng;
-
-/// Hybrid key encapsulation mechanism
-pub struct HybridKEM {
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Hybrid key pair
-pub struct HybridKeyPair {
-    /// Public key
-    pub public_key: HybridPublicKey,
-    /// Private key
-    pub private_key: HybridPrivateKey,
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Hybrid public key wrapper
-#[derive(Clone)]
-pub struct HybridPublicKey {
-    /// The underlying dcrypt hybrid public key
-    inner: DcryptHybridPublicKey,
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Hybrid private key wrapper
-#[derive(Clone)]
-pub struct HybridPrivateKey {
-    /// The underlying dcrypt hybrid secret key
-    inner: DcryptHybridSecretKey,
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Hybrid encapsulated key
-pub struct HybridEncapsulated {
-    /// The ciphertext bytes
-    ciphertext: Vec<u8>,
-    /// The shared secret
-    shared_secret: Vec<u8>,
-    /// Security level
-    level: SecurityLevel,
-}
-
-impl HybridKEM {
-    /// Create a new hybrid KEM with the specified security level
-    /// 
-    /// Currently only supports Level3 (EcdhKyber768: ECDH P-256 + Kyber768)
-    pub fn new(level: SecurityLevel) -> Self {
-        match level {
-            SecurityLevel::Level3 => Self { level },
-            _ => panic!("Hybrid KEM currently only supports Level3 security"),
-        }
-    }
-
-    /// Create a new hybrid KEM with default security level (Level3)
-    pub fn default() -> Self {
-        Self::new(SecurityLevel::Level3)
-    }
-}
-
-impl KeyEncapsulation for HybridKEM {
-    type KeyPair = HybridKeyPair;
-    type PublicKey = HybridPublicKey;
-    type PrivateKey = HybridPrivateKey;
-    type Encapsulated = HybridEncapsulated;
-
-    fn generate_keypair(&self) -> Self::KeyPair {
-        let mut rng = thread_rng();
-        
-        // Use dcrypt's hybrid KEM to generate keypair
-        let (pk, sk) = EcdhKyber768::keypair(&mut rng)
-            .expect("Failed to generate hybrid keypair");
-
-        HybridKeyPair {
-            public_key: HybridPublicKey {
-                inner: pk,
-                level: self.level,
-            },
-            private_key: HybridPrivateKey {
-                inner: sk,
-                level: self.level,
-            },
-            level: self.level,
-        }
-    }
-
-    fn encapsulate(&self, public_key: &Self::PublicKey) -> Self::Encapsulated {
-        let mut rng = thread_rng();
-        
-        // Use dcrypt's hybrid KEM to encapsulate
-        let (ct, ss) = EcdhKyber768::encapsulate(&mut rng, &public_key.inner)
-            .expect("Failed to encapsulate with hybrid KEM");
-
-        HybridEncapsulated {
-            ciphertext: ct.to_bytes(),
-            shared_secret: ss.to_bytes_zeroizing().to_vec(),
-            level: public_key.level,
-        }
-    }
-
-    fn decapsulate(
-        &self,
-        private_key: &Self::PrivateKey,
-        encapsulated: &Self::Encapsulated,
-    ) -> Option<Vec<u8>> {
-        // Reconstruct the ciphertext from bytes
-        let ct = HybridCiphertext::from_bytes(&encapsulated.ciphertext).ok()?;
-        
-        // Use dcrypt's hybrid KEM to decapsulate
-        let ss = EcdhKyber768::decapsulate(&private_key.inner, &ct)
-            .ok()?;
-
-        Some(ss.to_bytes_zeroizing().to_vec())
-    }
-}
-
-impl KemKeyPair for HybridKeyPair {
-    type PublicKey = HybridPublicKey;
-    type PrivateKey = HybridPrivateKey;
-
-    fn public_key(&self) -> Self::PublicKey {
-        self.public_key.clone()
-    }
-
-    fn private_key(&self) -> Self::PrivateKey {
-        self.private_key.clone()
-    }
-}
-
-// HybridPublicKey implements the EncapsulationKey trait
-impl SerializableKey for HybridPublicKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Use dcrypt's built-in to_bytes method
-        self.inner.to_bytes()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Use dcrypt's built-in from_bytes method
-        let inner = DcryptHybridPublicKey::from_bytes(bytes)
-            .map_err(|e| format!("Failed to deserialize hybrid public key: {:?}", e))?;
-        
-        // For now, we only support Level3
-        Ok(HybridPublicKey { 
-            inner, 
-            level: SecurityLevel::Level3 
-        })
-    }
-}
-
-impl EncapsulationKey for HybridPublicKey {
-    // EncapsulationKey trait has no additional methods beyond SerializableKey
-}
-
-// HybridPrivateKey implements the DecapsulationKey trait
-impl SerializableKey for HybridPrivateKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Note: dcrypt's HybridSecretKey doesn't have a direct to_bytes method
-        // We need to serialize the components
-        [
-            self.inner.ecdh_sk.to_bytes().to_vec(),
-            self.inner.kyber_sk.to_bytes_zeroizing().to_vec()
-        ].concat()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Expected sizes from dcrypt's implementation
-        const ECDH_SK_LEN: usize = 32;  // P-256 scalar
-        const KYBER_SK_LEN: usize = 2400; // Kyber768
-        const TOTAL_LEN: usize = ECDH_SK_LEN + KYBER_SK_LEN;
-
-        if bytes.len() != TOTAL_LEN {
-            return Err(format!(
-                "Invalid hybrid private key size: expected {}, got {}",
-                TOTAL_LEN,
-                bytes.len()
-            ));
-        }
-
-        let (ecdh_bytes, kyber_bytes) = bytes.split_at(ECDH_SK_LEN);
-        
-        let ecdh_sk = EcdhP256SecretKey::from_bytes(ecdh_bytes)
-            .map_err(|e| format!("Failed to deserialize ECDH private key: {:?}", e))?;
-        
-        let kyber_sk = KyberSecretKey::from_bytes(kyber_bytes)
-            .map_err(|e| format!("Failed to deserialize Kyber private key: {:?}", e))?;
-
-        Ok(HybridPrivateKey {
-            inner: DcryptHybridSecretKey { ecdh_sk, kyber_sk },
-            level: SecurityLevel::Level3,
-        })
-    }
-}
-
-impl DecapsulationKey for HybridPrivateKey {
-    // DecapsulationKey trait has no additional methods beyond SerializableKey
-}
-
-// HybridEncapsulated implements the Encapsulated trait
-impl SerializableKey for HybridEncapsulated {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Return the ciphertext bytes
-        self.ciphertext.clone()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Try to verify this is a valid hybrid ciphertext size
-        // ECDH P-256 (33) + Kyber768 (1088) = 1121
-        const EXPECTED_LEN: usize = 1121;
-        
-        if bytes.len() != EXPECTED_LEN {
-            return Err(format!(
-                "Invalid hybrid ciphertext size: expected {}, got {}",
-                EXPECTED_LEN,
-                bytes.len()
-            ));
-        }
-
-        // We can't recover the shared secret from just the ciphertext
-        // This will need to be decapsulated using a private key to get the shared secret
-        Ok(HybridEncapsulated {
-            ciphertext: bytes.to_vec(),
-            shared_secret: vec![0; 32], // Placeholder until decapsulated
-            level: SecurityLevel::Level3,
-        })
-    }
-}
-
-impl Encapsulated for HybridEncapsulated {
-    fn ciphertext(&self) -> &[u8] {
-        &self.ciphertext
-    }
-
-    fn shared_secret(&self) -> &[u8] {
-        &self.shared_secret
-    }
-}
-
-pub mod ecdh_kyber;
-
-// Re-export commonly used types
-pub use ecdh_kyber::{
-    EcdhP256Kyber768,
-    EcdhP256Kyber768KeyPair,
-    EcdhP256Kyber768PublicKey,
-    EcdhP256Kyber768PrivateKey,
-    EcdhP256Kyber768Encapsulated,
-};
-
-#[cfg(test)]
-mod tests;```
-
-####### Directory: crypto/src/kem/kyber
-
-######## Directory: crypto/src/kem/kyber/tests
-
-######### File: crypto/src/kem/kyber/tests/mod.rs
-######*Size: 8.0K, Lines: 175, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/kyber/tests/mod.rs
-use super::*;
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{Encapsulated, KeyEncapsulation, KemKeyPair, DecapsulationKey, EncapsulationKey};
-
-#[test]
-fn test_kyber_keypair_generation() {
-    // Test all security levels
-    let levels = vec![
-        SecurityLevel::Level1,
-        SecurityLevel::Level3,
-        SecurityLevel::Level5,
-    ];
-
-    for level in levels {
-        let kem = KyberKEM::new(level);
-        let keypair = kem.generate_keypair();
-
-        // Verify key sizes match the expected sizes for the security level
-        match level {
-            SecurityLevel::Level1 => {
-                assert_eq!(keypair.public_key.to_bytes().len(), 800); // Kyber512
-                assert_eq!(keypair.private_key.to_bytes().len(), 1632); // Kyber512
-            }
-            SecurityLevel::Level3 => {
-                assert_eq!(keypair.public_key.to_bytes().len(), 1184); // Kyber768
-                assert_eq!(keypair.private_key.to_bytes().len(), 2400); // Kyber768
-            }
-            SecurityLevel::Level5 => {
-                assert_eq!(keypair.public_key.to_bytes().len(), 1568); // Kyber1024
-                assert_eq!(keypair.private_key.to_bytes().len(), 3168); // Kyber1024
-            }
-            _ => panic!("Unexpected security level"),
-        }
-
-        // Ensure keys are different
-        assert_ne!(
-            keypair.public_key.to_bytes(),
-            keypair.private_key.to_bytes()
-        );
-    }
-}
-
-#[test]
-fn test_kyber_encapsulation() {
-    let levels = vec![
-        SecurityLevel::Level1,
-        SecurityLevel::Level3,
-        SecurityLevel::Level5,
-    ];
-
-    for level in levels {
-        let kem = KyberKEM::new(level);
-        let keypair = kem.generate_keypair();
-
-        // Encapsulate a key
-        let encapsulated = kem.encapsulate(&keypair.public_key);
-
-        // Verify the encapsulated data sizes
-        match level {
-            SecurityLevel::Level1 => {
-                assert_eq!(encapsulated.ciphertext().len(), 768); // Kyber512
-            }
-            SecurityLevel::Level3 => {
-                assert_eq!(encapsulated.ciphertext().len(), 1088); // Kyber768
-            }
-            SecurityLevel::Level5 => {
-                assert_eq!(encapsulated.ciphertext().len(), 1568); // Kyber1024
-            }
-            _ => panic!("Unexpected security level"),
-        }
-
-        // Shared secret should always be 32 bytes for all Kyber variants
-        assert_eq!(encapsulated.shared_secret().len(), 32);
-
-        // Decapsulate and verify
-        let shared_secret = kem.decapsulate(&keypair.private_key, &encapsulated);
-
-        // We should get a valid shared secret
-        assert!(shared_secret.is_some());
-        let shared_secret = shared_secret.unwrap();
-
-        // The shared secret should match what's in the encapsulated key
-        assert_eq!(shared_secret, encapsulated.shared_secret());
-
-        // The shared secret should be 32 bytes for all Kyber variants
-        assert_eq!(shared_secret.len(), 32);
-    }
-}
-
-#[test]
-fn test_kyber_serialization() {
-    let kem = KyberKEM::new(SecurityLevel::Level3);
-    let keypair = kem.generate_keypair();
-
-    // Serialize keys
-    let public_key_bytes = keypair.public_key.to_bytes();
-    let private_key_bytes = keypair.private_key.to_bytes();
-
-    // Deserialize keys
-    let restored_public_key = KyberPublicKey::from_bytes(&public_key_bytes).unwrap();
-    let restored_private_key = KyberPrivateKey::from_bytes(&private_key_bytes).unwrap();
-
-    // Encapsulate with original key
-    let encapsulated = kem.encapsulate(&keypair.public_key);
-    let ciphertext_bytes = encapsulated.to_bytes();
-
-    // Deserialize ciphertext
-    let restored_encapsulated = KyberEncapsulated::from_bytes(&ciphertext_bytes).unwrap();
-
-    // Decapsulate with restored key and restored ciphertext
-    let shared_secret = kem.decapsulate(&restored_private_key, &restored_encapsulated);
-
-    // We should still get a valid shared secret
-    assert!(shared_secret.is_some());
-
-    // Verify that different key pairs produce different shared secrets
-    let keypair2 = kem.generate_keypair();
-    let encapsulated2 = kem.encapsulate(&keypair2.public_key);
-
-    // Different key pairs should generate different shared secrets
-    assert_ne!(encapsulated.shared_secret(), encapsulated2.shared_secret());
-
-    // Different public keys should produce different ciphertexts
-    assert_ne!(encapsulated.ciphertext(), encapsulated2.ciphertext());
-
-    // Decapsulating with the wrong private key should still produce a result,
-    // but it won't match the original shared secret
-    let wrong_shared_secret = kem.decapsulate(&keypair2.private_key, &encapsulated);
-    assert!(wrong_shared_secret.is_some());
-    assert_ne!(wrong_shared_secret.unwrap(), encapsulated.shared_secret());
-}
-
-#[test]
-fn test_cross_level_compatibility() {
-    // Test that keys from different security levels can't be mixed
-
-    let kem512 = KyberKEM::new(SecurityLevel::Level1);
-    let kem768 = KyberKEM::new(SecurityLevel::Level3);
-
-    let keypair512 = kem512.generate_keypair();
-    let keypair768 = kem768.generate_keypair();
-
-    // Encapsulate with Level1 public key
-    let encapsulated512 = kem512.encapsulate(&keypair512.public_key);
-
-    // Try to decapsulate Level1 ciphertext with Level3 private key
-    // This should still return a result but it won't be correct
-    let _result = kem768.decapsulate(&keypair768.private_key, &encapsulated512);
-
-    // The correct way is to match security levels
-    let encapsulated768 = kem768.encapsulate(&keypair768.public_key);
-    let shared_secret = kem768.decapsulate(&keypair768.private_key, &encapsulated768);
-    assert!(shared_secret.is_some());
-    assert_eq!(shared_secret.unwrap(), encapsulated768.shared_secret());
-}
-
-#[test]
-fn test_dcrypt_compatibility() {
-    // Test that the dcrypt wrapper works correctly
-    let kem = KyberKEM::new(SecurityLevel::Level3);
-    let keypair1 = kem.generate_keypair();
-    let keypair2 = kem.generate_keypair();
-
-    // Test encapsulation/decapsulation cycle
-    let encapsulated = kem.encapsulate(&keypair1.public_key);
-    let shared_secret = kem.decapsulate(&keypair1.private_key, &encapsulated);
-    
-    assert!(shared_secret.is_some());
-    assert_eq!(shared_secret.unwrap().len(), 32);
-
-    // Test that using wrong keys produces different results
-    let wrong_secret = kem.decapsulate(&keypair2.private_key, &encapsulated);
-    assert!(wrong_secret.is_some());
-    assert_ne!(wrong_secret.unwrap(), encapsulated.shared_secret());
-}```
-
-######## File: crypto/src/kem/kyber/mod.rs
-#####*Size: 12K, Lines: 313, Type: ASCII text*
-
-```rust
-// crates/crypto/src/kem/kyber/mod.rs
-//! Kyber key encapsulation mechanism using dcrypt
-
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{
-    DecapsulationKey, Encapsulated, EncapsulationKey, KemKeyPair, KeyEncapsulation,
-    SerializableKey,
-};
-use dcrypt::api::Kem;
-use dcrypt::kem::kyber::{
-    Kyber512, Kyber768, Kyber1024,
-    KyberCiphertext, KyberPublicKey as DcryptPublicKey, 
-    KyberSecretKey as DcryptSecretKey,
-    KyberSharedSecret,
-};
-use rand::{CryptoRng, RngCore};
-
-/// Kyber key encapsulation mechanism
-pub struct KyberKEM {
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Kyber key pair
-pub struct KyberKeyPair {
-    /// Public key
-    pub public_key: KyberPublicKey,
-    /// Private key
-    pub private_key: KyberPrivateKey,
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Kyber public key wrapper
-#[derive(Clone)]
-pub struct KyberPublicKey {
-    /// The underlying dcrypt public key
-    inner: DcryptPublicKey,
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Kyber private key wrapper
-#[derive(Clone)]
-pub struct KyberPrivateKey {
-    /// The underlying dcrypt secret key
-    inner: DcryptSecretKey,
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Kyber encapsulated key
-pub struct KyberEncapsulated {
-    /// The ciphertext bytes
-    ciphertext: Vec<u8>,
-    /// The shared secret
-    shared_secret: Vec<u8>,
-    /// Security level
-    level: SecurityLevel,
-}
-
-impl KyberKEM {
-    /// Create a new Kyber KEM with the specified security level
-    pub fn new(level: SecurityLevel) -> Self {
-        Self { level }
-    }
-}
-
-impl KeyEncapsulation for KyberKEM {
-    type KeyPair = KyberKeyPair;
-    type PublicKey = KyberPublicKey;
-    type PrivateKey = KyberPrivateKey;
-    type Encapsulated = KyberEncapsulated;
-
-    fn generate_keypair(&self) -> Self::KeyPair {
-        let mut rng = rand::thread_rng();
-        
-        // Use dcrypt's KEM trait to generate keypair based on security level
-        let (pk, sk) = match self.level {
-            SecurityLevel::Level1 => {
-                let (pk, sk) = Kyber512::keypair(&mut rng)
-                    .expect("Failed to generate Kyber512 keypair");
-                (
-                    KyberPublicKey {
-                        inner: pk,
-                        level: self.level,
-                    },
-                    KyberPrivateKey {
-                        inner: sk,
-                        level: self.level,
-                    },
-                )
-            }
-            SecurityLevel::Level3 => {
-                let (pk, sk) = Kyber768::keypair(&mut rng)
-                    .expect("Failed to generate Kyber768 keypair");
-                (
-                    KyberPublicKey {
-                        inner: pk,
-                        level: self.level,
-                    },
-                    KyberPrivateKey {
-                        inner: sk,
-                        level: self.level,
-                    },
-                )
-            }
-            SecurityLevel::Level5 => {
-                let (pk, sk) = Kyber1024::keypair(&mut rng)
-                    .expect("Failed to generate Kyber1024 keypair");
-                (
-                    KyberPublicKey {
-                        inner: pk,
-                        level: self.level,
-                    },
-                    KyberPrivateKey {
-                        inner: sk,
-                        level: self.level,
-                    },
-                )
-            }
-            _ => {
-                // Default to Level1
-                let (pk, sk) = Kyber512::keypair(&mut rng)
-                    .expect("Failed to generate Kyber512 keypair");
-                (
-                    KyberPublicKey {
-                        inner: pk,
-                        level: SecurityLevel::Level1,
-                    },
-                    KyberPrivateKey {
-                        inner: sk,
-                        level: SecurityLevel::Level1,
-                    },
-                )
-            }
-        };
-
-        KyberKeyPair {
-            public_key: pk,
-            private_key: sk,
-            level: self.level,
-        }
-    }
-
-    fn encapsulate(&self, public_key: &Self::PublicKey) -> Self::Encapsulated {
-        let mut rng = rand::thread_rng();
-        
-        // Use dcrypt's KEM trait to encapsulate based on security level
-        let (ct, ss) = match public_key.level {
-            SecurityLevel::Level1 => {
-                Kyber512::encapsulate(&mut rng, &public_key.inner)
-                    .expect("Failed to encapsulate with Kyber512")
-            }
-            SecurityLevel::Level3 => {
-                Kyber768::encapsulate(&mut rng, &public_key.inner)
-                    .expect("Failed to encapsulate with Kyber768")
-            }
-            SecurityLevel::Level5 => {
-                Kyber1024::encapsulate(&mut rng, &public_key.inner)
-                    .expect("Failed to encapsulate with Kyber1024")
-            }
-            _ => {
-                Kyber512::encapsulate(&mut rng, &public_key.inner)
-                    .expect("Failed to encapsulate with Kyber512")
-            }
-        };
-
-        KyberEncapsulated {
-            ciphertext: ct.to_bytes(),
-            shared_secret: ss.to_bytes_zeroizing().to_vec(),
-            level: public_key.level,
-        }
-    }
-
-    fn decapsulate(
-        &self,
-        private_key: &Self::PrivateKey,
-        encapsulated: &Self::Encapsulated,
-    ) -> Option<Vec<u8>> {
-        // Reconstruct the ciphertext from bytes
-        let ct = KyberCiphertext::from_bytes(&encapsulated.ciphertext).ok()?;
-        
-        // Use dcrypt's KEM trait to decapsulate based on security level
-        let ss = match private_key.level {
-            SecurityLevel::Level1 => {
-                Kyber512::decapsulate(&private_key.inner, &ct)
-                    .ok()?
-            }
-            SecurityLevel::Level3 => {
-                Kyber768::decapsulate(&private_key.inner, &ct)
-                    .ok()?
-            }
-            SecurityLevel::Level5 => {
-                Kyber1024::decapsulate(&private_key.inner, &ct)
-                    .ok()?
-            }
-            _ => {
-                Kyber512::decapsulate(&private_key.inner, &ct)
-                    .ok()?
-            }
-        };
-
-        Some(ss.to_bytes_zeroizing().to_vec())
-    }
-}
-
-impl KemKeyPair for KyberKeyPair {
-    type PublicKey = KyberPublicKey;
-    type PrivateKey = KyberPrivateKey;
-
-    fn public_key(&self) -> Self::PublicKey {
-        self.public_key.clone()
-    }
-
-    fn private_key(&self) -> Self::PrivateKey {
-        self.private_key.clone()
-    }
-}
-
-// KyberPublicKey implements the EncapsulationKey trait
-impl SerializableKey for KyberPublicKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Use dcrypt's built-in to_bytes method
-        self.inner.to_bytes()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Use dcrypt's built-in from_bytes method
-        let inner = DcryptPublicKey::from_bytes(bytes)
-            .map_err(|e| format!("Failed to deserialize Kyber public key: {:?}", e))?;
-        
-        // Try to determine the security level from the public key size
-        let level = match bytes.len() {
-            800 => SecurityLevel::Level1,  // Kyber512
-            1184 => SecurityLevel::Level3, // Kyber768
-            1568 => SecurityLevel::Level5, // Kyber1024
-            _ => return Err(format!("Invalid Kyber public key size: {}", bytes.len())),
-        };
-
-        Ok(KyberPublicKey { inner, level })
-    }
-}
-
-impl EncapsulationKey for KyberPublicKey {
-    // EncapsulationKey trait has no additional methods beyond SerializableKey
-}
-
-// KyberPrivateKey implements the DecapsulationKey trait
-impl SerializableKey for KyberPrivateKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Use dcrypt's built-in to_bytes_zeroizing method
-        self.inner.to_bytes_zeroizing().to_vec()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Use dcrypt's built-in from_bytes method
-        let inner = DcryptSecretKey::from_bytes(bytes)
-            .map_err(|e| format!("Failed to deserialize Kyber private key: {:?}", e))?;
-        
-        // Try to determine the security level from the private key size
-        let level = match bytes.len() {
-            1632 => SecurityLevel::Level1, // Kyber512
-            2400 => SecurityLevel::Level3, // Kyber768
-            3168 => SecurityLevel::Level5, // Kyber1024
-            _ => return Err(format!("Invalid Kyber private key size: {}", bytes.len())),
-        };
-
-        Ok(KyberPrivateKey { inner, level })
-    }
-}
-
-impl DecapsulationKey for KyberPrivateKey {
-    // DecapsulationKey trait has no additional methods beyond SerializableKey
-}
-
-// KyberEncapsulated implements the Encapsulated trait
-impl SerializableKey for KyberEncapsulated {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Return the ciphertext bytes
-        self.ciphertext.clone()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Try to determine the security level from the ciphertext size
-        let level = match bytes.len() {
-            768 => SecurityLevel::Level1,  // Kyber512
-            1088 => SecurityLevel::Level3, // Kyber768
-            1568 => SecurityLevel::Level5, // Kyber1024
-            _ => return Err(format!("Invalid Kyber ciphertext size: {}", bytes.len())),
-        };
-
-        // We can't recover the shared secret from just the ciphertext
-        // This will need to be decapsulated using a private key to get the shared secret
-        Ok(KyberEncapsulated {
-            ciphertext: bytes.to_vec(),
-            shared_secret: vec![0; 32], // Placeholder until decapsulated
-            level,
-        })
-    }
-}
-
-impl Encapsulated for KyberEncapsulated {
-    fn ciphertext(&self) -> &[u8] {
-        &self.ciphertext
-    }
-
-    fn shared_secret(&self) -> &[u8] {
-        &self.shared_secret
-    }
-}
-
-#[cfg(test)]
-mod tests;```
-
-####### File: crypto/src/kem/mod.rs
-####*Size: 4.0K, Lines: 2, Type: ASCII text*
-
-```rust
-pub mod kyber;
-pub mod ecdh;
-pub mod hybrid;```
-
-###### Directory: crypto/src/sign
-
-####### Directory: crypto/src/sign/dilithium
-
-######## Directory: crypto/src/sign/dilithium/tests
-
-######### File: crypto/src/sign/dilithium/tests/mod.rs
-######*Size: 4.0K, Lines: 104, Type: ASCII text*
-
-```rust
-use super::*;
-
-#[test]
-fn test_dilithium_level2_sign_verify() {
-    let scheme = DilithiumScheme::new(SecurityLevel::Level2);
-    let keypair = scheme.generate_keypair();
-    
-    let message = b"Test message for Dilithium";
-    let signature = keypair.sign(message);
-    
-    assert!(keypair.public_key().verify(message, &signature));
-    
-    // Test with wrong message
-    let wrong_message = b"Wrong message";
-    assert!(!keypair.public_key().verify(wrong_message, &signature));
-}
-
-#[test]
-fn test_dilithium_level3_sign_verify() {
-    let scheme = DilithiumScheme::new(SecurityLevel::Level3);
-    let keypair = scheme.generate_keypair();
-    
-    let message = b"Test message for Dilithium Level 3";
-    let signature = keypair.sign(message);
-    
-    assert!(keypair.public_key().verify(message, &signature));
-}
-
-#[test]
-fn test_dilithium_level5_sign_verify() {
-    let scheme = DilithiumScheme::new(SecurityLevel::Level5);
-    let keypair = scheme.generate_keypair();
-    
-    let message = b"Test message for Dilithium Level 5";
-    let signature = keypair.sign(message);
-    
-    assert!(keypair.public_key().verify(message, &signature));
-}
-
-#[test]
-fn test_key_serialization() {
-    let scheme = DilithiumScheme::new(SecurityLevel::Level2);
-    let keypair = scheme.generate_keypair();
-    
-    // Test public key serialization
-    let pk_bytes = keypair.public_key().to_bytes();
-    let pk_restored = DilithiumPublicKey::from_bytes(&pk_bytes).unwrap();
-    assert_eq!(pk_bytes, pk_restored.to_bytes());
-    
-    // Test private key serialization
-    let sk_bytes = keypair.private_key().to_bytes();
-    let sk_restored = DilithiumPrivateKey::from_bytes(&sk_bytes).unwrap();
-    assert_eq!(sk_bytes, sk_restored.to_bytes());
-    
-    // Test signature with restored keys
-    let message = b"Test serialization";
-    let signature = scheme.sign(&sk_restored, message);
-    assert!(scheme.verify(&pk_restored, message, &signature));
-}
-
-#[test]
-fn test_signature_serialization() {
-    let scheme = DilithiumScheme::new(SecurityLevel::Level2);
-    let keypair = scheme.generate_keypair();
-    
-    let message = b"Test signature serialization";
-    let signature = keypair.sign(message);
-    
-    // Serialize and deserialize signature
-    let sig_bytes = signature.to_bytes();
-    let sig_restored = DilithiumSignature::from_bytes(&sig_bytes).unwrap();
-    
-    // Verify with restored signature
-    assert!(keypair.public_key().verify(message, &sig_restored));
-}
-
-#[test]
-fn test_wrong_key_size_detection() {
-    // Test with invalid key sizes
-    let invalid_pk = vec![0u8; 1000]; // Invalid size
-    let pk = DilithiumPublicKey::from_bytes(&invalid_pk).unwrap();
-    
-    let message = b"Test";
-    let signature = DilithiumSignature(vec![0u8; 2420]); // Dilithium2 signature size
-    
-    // Should return false for invalid key size
-    assert!(!pk.verify(message, &signature));
-}
-
-#[test]
-fn test_cross_level_verification() {
-    // Generate keys at different levels
-    let scheme2 = DilithiumScheme::new(SecurityLevel::Level2);
-    let keypair2 = scheme2.generate_keypair();
-    
-    let scheme3 = DilithiumScheme::new(SecurityLevel::Level3);
-    let keypair3 = scheme3.generate_keypair();
-    
-    let message = b"Cross level test";
-    let signature2 = keypair2.sign(message);
-    
-    // Level 3 public key should not verify Level 2 signature
-    // (will fail due to key size mismatch detection)
-    assert!(!keypair3.public_key().verify(message, &signature2));
-}```
-
-######## File: crypto/src/sign/dilithium/mod.rs
-#####*Size: 12K, Lines: 316, Type: ASCII text*
-
-```rust
-//! Dilithium signature algorithm (using dcrypt implementation)
-//!
-use crate::security::SecurityLevel;
-use depin_sdk_core::crypto::{
-    SerializableKey, Signature, SigningKey, SigningKeyPair, VerifyingKey
-};
-// Import the trait needed for the signature operations
-use dcrypt::api::Signature as SignatureTrait;
-// Import the Dilithium implementations and types from the correct module path
-use dcrypt::sign::pq::dilithium::{
-    Dilithium2, Dilithium3, Dilithium5, 
-    DilithiumPublicKey as DcryptPublicKey, 
-    DilithiumSecretKey as DcryptSecretKey, 
-    DilithiumSignatureData as DcryptSignatureData
-};
-
-/// Dilithium signature scheme
-pub struct DilithiumScheme {
-    /// Security level
-    level: SecurityLevel,
-}
-
-/// Dilithium key pair
-pub struct DilithiumKeyPair {
-    /// Public key
-    public_key: DilithiumPublicKey,
-    /// Private key
-    private_key: DilithiumPrivateKey,
-    /// Security level (needed for signing)
-    level: SecurityLevel,
-}
-
-/// Dilithium public key
-pub struct DilithiumPublicKey(Vec<u8>);
-
-/// Dilithium private key
-pub struct DilithiumPrivateKey {
-    data: Vec<u8>,
-    level: SecurityLevel,
-}
-
-/// Dilithium signature
-pub struct DilithiumSignature(Vec<u8>);
-
-impl DilithiumScheme {
-    /// Create a new Dilithium scheme with the specified security level
-    pub fn new(level: SecurityLevel) -> Self {
-        Self { level }
-    }
-
-    /// Generate a new key pair
-    pub fn generate_keypair(&self) -> DilithiumKeyPair {
-        let mut rng = rand::rngs::OsRng;
-        
-        match self.level {
-            SecurityLevel::Level2 => {
-                let (pk, sk) = Dilithium2::keypair(&mut rng).unwrap();
-                DilithiumKeyPair {
-                    public_key: DilithiumPublicKey(pk.to_bytes().to_vec()),
-                    private_key: DilithiumPrivateKey {
-                        data: sk.to_bytes().to_vec(),
-                        level: self.level,
-                    },
-                    level: self.level,
-                }
-            }
-            SecurityLevel::Level3 => {
-                let (pk, sk) = Dilithium3::keypair(&mut rng).unwrap();
-                DilithiumKeyPair {
-                    public_key: DilithiumPublicKey(pk.to_bytes().to_vec()),
-                    private_key: DilithiumPrivateKey {
-                        data: sk.to_bytes().to_vec(),
-                        level: self.level,
-                    },
-                    level: self.level,
-                }
-            }
-            SecurityLevel::Level5 => {
-                let (pk, sk) = Dilithium5::keypair(&mut rng).unwrap();
-                DilithiumKeyPair {
-                    public_key: DilithiumPublicKey(pk.to_bytes().to_vec()),
-                    private_key: DilithiumPrivateKey {
-                        data: sk.to_bytes().to_vec(),
-                        level: self.level,
-                    },
-                    level: self.level,
-                }
-            }
-            _ => {
-                // Default to Level2 for any other security level
-                let (pk, sk) = Dilithium2::keypair(&mut rng).unwrap();
-                DilithiumKeyPair {
-                    public_key: DilithiumPublicKey(pk.to_bytes().to_vec()),
-                    private_key: DilithiumPrivateKey {
-                        data: sk.to_bytes().to_vec(),
-                        level: SecurityLevel::Level2,
-                    },
-                    level: SecurityLevel::Level2,
-                }
-            }
-        }
-    }
-
-    /// Sign a message
-    pub fn sign(&self, private_key: &DilithiumPrivateKey, message: &[u8]) -> DilithiumSignature {
-        match private_key.level {
-            SecurityLevel::Level2 => {
-                let sk = DcryptSecretKey::from_bytes(&private_key.data).unwrap();
-                let signature = Dilithium2::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            SecurityLevel::Level3 => {
-                let sk = DcryptSecretKey::from_bytes(&private_key.data).unwrap();
-                let signature = Dilithium3::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            SecurityLevel::Level5 => {
-                let sk = DcryptSecretKey::from_bytes(&private_key.data).unwrap();
-                let signature = Dilithium5::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            _ => {
-                // Default to Level2
-                let sk = DcryptSecretKey::from_bytes(&private_key.data).unwrap();
-                let signature = Dilithium2::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-        }
-    }
-
-    /// Verify a signature
-    pub fn verify(
-        &self,
-        public_key: &DilithiumPublicKey,
-        message: &[u8],
-        signature: &DilithiumSignature,
-    ) -> bool {
-        // Determine security level from key size
-        let level = match public_key.0.len() {
-            1312 => SecurityLevel::Level2,  // Dilithium2
-            1952 => SecurityLevel::Level3,  // Dilithium3
-            2592 => SecurityLevel::Level5,  // Dilithium5
-            _ => return false,
-        };
-
-        match level {
-            SecurityLevel::Level2 => {
-                let pk = DcryptPublicKey::from_bytes(&public_key.0).unwrap();
-                let sig = DcryptSignatureData::from_bytes(&signature.0).unwrap();
-                Dilithium2::verify(message, &sig, &pk).is_ok()
-            }
-            SecurityLevel::Level3 => {
-                let pk = DcryptPublicKey::from_bytes(&public_key.0).unwrap();
-                let sig = DcryptSignatureData::from_bytes(&signature.0).unwrap();
-                Dilithium3::verify(message, &sig, &pk).is_ok()
-            }
-            SecurityLevel::Level5 => {
-                let pk = DcryptPublicKey::from_bytes(&public_key.0).unwrap();
-                let sig = DcryptSignatureData::from_bytes(&signature.0).unwrap();
-                Dilithium5::verify(message, &sig, &pk).is_ok()
-            }
-            _ => false,
-        }
-    }
-}
-
-impl SigningKeyPair for DilithiumKeyPair {
-    type PublicKey = DilithiumPublicKey;
-    type PrivateKey = DilithiumPrivateKey;
-    type Signature = DilithiumSignature;
-
-    fn public_key(&self) -> Self::PublicKey {
-        DilithiumPublicKey(self.public_key.0.clone())
-    }
-
-    fn private_key(&self) -> Self::PrivateKey {
-        DilithiumPrivateKey {
-            data: self.private_key.data.clone(),
-            level: self.private_key.level,
-        }
-    }
-
-    fn sign(&self, message: &[u8]) -> Self::Signature {
-        match self.level {
-            SecurityLevel::Level2 => {
-                let sk = DcryptSecretKey::from_bytes(&self.private_key.data).unwrap();
-                let signature = Dilithium2::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            SecurityLevel::Level3 => {
-                let sk = DcryptSecretKey::from_bytes(&self.private_key.data).unwrap();
-                let signature = Dilithium3::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            SecurityLevel::Level5 => {
-                let sk = DcryptSecretKey::from_bytes(&self.private_key.data).unwrap();
-                let signature = Dilithium5::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            _ => {
-                // Default to Level2
-                let sk = DcryptSecretKey::from_bytes(&self.private_key.data).unwrap();
-                let signature = Dilithium2::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-        }
-    }
-}
-
-impl VerifyingKey for DilithiumPublicKey {
-    type Signature = DilithiumSignature;
-
-    fn verify(&self, message: &[u8], signature: &Self::Signature) -> bool {
-        // Determine security level from key size
-        let level = match self.0.len() {
-            1312 => SecurityLevel::Level2,  // Dilithium2
-            1952 => SecurityLevel::Level3,  // Dilithium3
-            2592 => SecurityLevel::Level5,  // Dilithium5
-            _ => return false,
-        };
-
-        match level {
-            SecurityLevel::Level2 => {
-                let pk = DcryptPublicKey::from_bytes(&self.0).unwrap();
-                let sig = DcryptSignatureData::from_bytes(&signature.0).unwrap();
-                Dilithium2::verify(message, &sig, &pk).is_ok()
-            }
-            SecurityLevel::Level3 => {
-                let pk = DcryptPublicKey::from_bytes(&self.0).unwrap();
-                let sig = DcryptSignatureData::from_bytes(&signature.0).unwrap();
-                Dilithium3::verify(message, &sig, &pk).is_ok()
-            }
-            SecurityLevel::Level5 => {
-                let pk = DcryptPublicKey::from_bytes(&self.0).unwrap();
-                let sig = DcryptSignatureData::from_bytes(&signature.0).unwrap();
-                Dilithium5::verify(message, &sig, &pk).is_ok()
-            }
-            _ => false,
-        }
-    }
-}
-
-impl SerializableKey for DilithiumPublicKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        self.0.clone()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        Ok(DilithiumPublicKey(bytes.to_vec()))
-    }
-}
-
-impl SigningKey for DilithiumPrivateKey {
-    type Signature = DilithiumSignature;
-
-    fn sign(&self, message: &[u8]) -> Self::Signature {
-        match self.level {
-            SecurityLevel::Level2 => {
-                let sk = DcryptSecretKey::from_bytes(&self.data).unwrap();
-                let signature = Dilithium2::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            SecurityLevel::Level3 => {
-                let sk = DcryptSecretKey::from_bytes(&self.data).unwrap();
-                let signature = Dilithium3::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            SecurityLevel::Level5 => {
-                let sk = DcryptSecretKey::from_bytes(&self.data).unwrap();
-                let signature = Dilithium5::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-            _ => {
-                // Default to Level2
-                let sk = DcryptSecretKey::from_bytes(&self.data).unwrap();
-                let signature = Dilithium2::sign(message, &sk).unwrap();
-                DilithiumSignature(signature.to_bytes().to_vec())
-            }
-        }
-    }
-}
-
-impl SerializableKey for DilithiumPrivateKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        self.data.clone()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        // Determine security level from key size
-        let level = match bytes.len() {
-            2560 => SecurityLevel::Level2,  // Dilithium2
-            4032 => SecurityLevel::Level3,  // Dilithium3
-            4896 => SecurityLevel::Level5,  // Dilithium5
-            _ => return Err("Invalid Dilithium private key size".to_string()),
-        };
-        
-        Ok(DilithiumPrivateKey {
-            data: bytes.to_vec(),
-            level,
-        })
-    }
-}
-
-impl SerializableKey for DilithiumSignature {
-    fn to_bytes(&self) -> Vec<u8> {
-        self.0.clone()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        Ok(DilithiumSignature(bytes.to_vec()))
-    }
-}
-
-impl Signature for DilithiumSignature {}
-
-#[cfg(test)]
-mod tests;```
-
-####### Directory: crypto/src/sign/eddsa
-
-######## Directory: crypto/src/sign/eddsa/tests
-
-######### File: crypto/src/sign/eddsa/tests/mod.rs
-######*Size: 4.0K, Lines: 98, Type: ASCII text*
-
-```rust
-use super::*;
-
-#[test]
-fn test_keypair_generation() {
-    let keypair = Ed25519KeyPair::generate();
-    let message = b"Test message";
-    
-    // Sign
-    let signature = keypair.sign(message);
-    
-    // Verify
-    let public_key = keypair.public_key();
-    assert!(public_key.verify(message, &signature));
-}
-
-#[test]
-fn test_serialization_roundtrip() {
-    let keypair = Ed25519KeyPair::generate();
-    
-    // Serialize keys
-    let public_bytes = keypair.public_key().to_bytes();
-    let private_bytes = keypair.private_key().to_bytes();
-    
-    // Verify lengths
-    assert_eq!(public_bytes.len(), 32);
-    assert_eq!(private_bytes.len(), 32); // Just the seed
-    
-    // Deserialize
-    let public_key = Ed25519PublicKey::from_bytes(&public_bytes).unwrap();
-    let private_key = Ed25519PrivateKey::from_bytes(&private_bytes).unwrap();
-    
-    // Verify we can derive the same public key from the loaded private key
-    let derived_public = private_key.public_key().unwrap();
-    assert_eq!(public_key.to_bytes(), derived_public.to_bytes());
-}
-
-#[test]
-fn test_sign_verify_with_loaded_keys() {
-    // Generate original keypair
-    let original_keypair = Ed25519KeyPair::generate();
-    let message = b"Test message for persistence";
-    
-    // Sign with original
-    let original_sig = original_keypair.sign(message);
-    
-    // Serialize private key
-    let private_bytes = original_keypair.private_key().to_bytes();
-    
-    // Load private key from bytes
-    let loaded_private = Ed25519PrivateKey::from_bytes(&private_bytes).unwrap();
-    
-    // Reconstruct keypair from loaded private key
-    let reconstructed_keypair = Ed25519KeyPair::from_private_key(&loaded_private);
-    
-    // Sign with reconstructed keypair
-    let new_sig = reconstructed_keypair.sign(message);
-    
-    // Signatures should be deterministic and identical
-    assert_eq!(original_sig.to_bytes(), new_sig.to_bytes());
-    
-    // Verify with both public keys
-    let original_public = original_keypair.public_key();
-    let reconstructed_public = reconstructed_keypair.public_key();
-    
-    assert!(original_public.verify(message, &original_sig));
-    assert!(reconstructed_public.verify(message, &new_sig));
-    assert!(original_public.verify(message, &new_sig));
-    assert!(reconstructed_public.verify(message, &original_sig));
-}
-
-#[test]
-fn test_wrong_signature_fails() {
-    let keypair1 = Ed25519KeyPair::generate();
-    let keypair2 = Ed25519KeyPair::generate();
-    
-    let message = b"Test message";
-    
-    // Sign with keypair1
-    let signature = keypair1.sign(message);
-    
-    // Verify with keypair2's public key should fail
-    let public_key2 = keypair2.public_key();
-    assert!(!public_key2.verify(message, &signature));
-}
-
-#[test]
-fn test_tampered_message_fails() {
-    let keypair = Ed25519KeyPair::generate();
-    let message = b"Original message";
-    let tampered = b"Tampered message";
-    
-    // Sign original
-    let signature = keypair.sign(message);
-    
-    // Verify tampered message with same signature should fail
-    let public_key = keypair.public_key();
-    assert!(public_key.verify(message, &signature));
-    assert!(!public_key.verify(tampered, &signature));
-}```
-
-######## File: crypto/src/sign/eddsa/mod.rs
-#####*Size: 8.0K, Lines: 184, Type: ASCII text*
-
-```rust
-// crates/crypto/src/traditional/eddsa/mod.rs
-//! Implementation of elliptic curve cryptography using dcrypt
-
-use depin_sdk_core::crypto::{
-    SerializableKey, Signature, SigningKey, SigningKeyPair, VerifyingKey
-};
-use dcrypt::api::Signature as SignatureTrait;
-use rand::rngs::OsRng;
-
-// Import dcrypt Ed25519 module with module qualification
-use dcrypt::sign::traditional::eddsa;
-
-/// Ed25519 key pair implementation
-pub struct Ed25519KeyPair {
-    /// Public verification key
-    public_key: eddsa::Ed25519PublicKey,
-    /// Private signing key
-    secret_key: eddsa::Ed25519SecretKey,
-}
-
-/// Ed25519 signature implementation
-pub struct Ed25519Signature(eddsa::Ed25519Signature);
-
-/// Ed25519 public key implementation
-pub struct Ed25519PublicKey(eddsa::Ed25519PublicKey);
-
-/// Ed25519 private key implementation
-pub struct Ed25519PrivateKey(eddsa::Ed25519SecretKey);
-
-impl Ed25519KeyPair {
-    /// Generate a new Ed25519 key pair
-    pub fn generate() -> Self {
-        let mut rng = OsRng;
-        
-        // Generate key pair using dcrypt
-        let (public_key, secret_key) = eddsa::Ed25519::keypair(&mut rng)
-            .expect("Failed to generate Ed25519 key pair");
-
-        Self {
-            public_key,
-            secret_key,
-        }
-    }
-
-    /// Create from an existing private key
-    pub fn from_private_key(private_key: &Ed25519PrivateKey) -> Self {
-        let secret_key = private_key.0.clone();
-        
-        // Use the helper method to derive public key
-        let public_key = secret_key.public_key()
-            .expect("Failed to derive public key from secret key");
-
-        Self {
-            public_key,
-            secret_key,
-        }
-    }
-}
-
-impl SigningKeyPair for Ed25519KeyPair {
-    type PublicKey = Ed25519PublicKey;
-    type PrivateKey = Ed25519PrivateKey;
-    type Signature = Ed25519Signature;
-
-    fn public_key(&self) -> Self::PublicKey {
-        Ed25519PublicKey(self.public_key.clone())
-    }
-
-    fn private_key(&self) -> Self::PrivateKey {
-        Ed25519PrivateKey(self.secret_key.clone())
-    }
-
-    fn sign(&self, message: &[u8]) -> Self::Signature {
-        let signature = eddsa::Ed25519::sign(message, &self.secret_key)
-            .expect("Failed to sign message");
-        Ed25519Signature(signature)
-    }
-}
-
-impl VerifyingKey for Ed25519PublicKey {
-    type Signature = Ed25519Signature;
-
-    fn verify(&self, message: &[u8], signature: &Self::Signature) -> bool {
-        eddsa::Ed25519::verify(message, &signature.0, &self.0).is_ok()
-    }
-}
-
-impl SerializableKey for Ed25519PublicKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        self.0.to_bytes().to_vec()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        eddsa::Ed25519PublicKey::from_bytes(bytes)
-            .map(Ed25519PublicKey)
-            .map_err(|e| format!("Failed to parse public key: {:?}", e))
-    }
-}
-
-impl SigningKey for Ed25519PrivateKey {
-    type Signature = Ed25519Signature;
-
-    fn sign(&self, message: &[u8]) -> Self::Signature {
-        let signature = eddsa::Ed25519::sign(message, &self.0)
-            .expect("Failed to sign message");
-        Ed25519Signature(signature)
-    }
-}
-
-impl SerializableKey for Ed25519PrivateKey {
-    fn to_bytes(&self) -> Vec<u8> {
-        // Export just the seed (32 bytes)
-        self.0.seed().to_vec()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        if bytes.len() != 32 {
-            return Err("Invalid private key length: expected 32 bytes".to_string());
-        }
-        
-        let mut seed = [0u8; 32];
-        seed.copy_from_slice(bytes);
-        
-        // Use the from_seed method
-        eddsa::Ed25519SecretKey::from_seed(&seed)
-            .map(Ed25519PrivateKey)
-            .map_err(|e| format!("Failed to create secret key from seed: {:?}", e))
-    }
-}
-
-impl SerializableKey for Ed25519Signature {
-    fn to_bytes(&self) -> Vec<u8> {
-        self.0.to_bytes().to_vec()
-    }
-
-    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
-        eddsa::Ed25519Signature::from_bytes(bytes)
-            .map(Ed25519Signature)
-            .map_err(|e| format!("Failed to parse signature: {:?}", e))
-    }
-}
-
-impl Signature for Ed25519Signature {}
-
-// Additional Ed25519-specific functionality
-impl Ed25519Signature {
-    /// Get the raw signature bytes
-    pub fn as_bytes(&self) -> &[u8] {
-        &self.0.0  // Access the inner array through the public field
-    }
-}
-
-impl Ed25519PublicKey {
-    /// Get the raw public key bytes
-    pub fn as_bytes(&self) -> &[u8] {
-        &self.0.0  // Access the inner array through the public field
-    }
-
-    /// Construct from dcrypt public key
-    pub fn from_dcrypt_key(key: eddsa::Ed25519PublicKey) -> Self {
-        Self(key)
-    }
-}
-
-impl Ed25519PrivateKey {
-    /// Get the raw private key seed bytes (32 bytes)
-    pub fn as_bytes(&self) -> &[u8] {
-        self.0.seed()
-    }
-
-    /// Construct from dcrypt secret key
-    pub fn from_dcrypt_key(key: eddsa::Ed25519SecretKey) -> Self {
-        Self(key)
-    }
-    
-    /// Get the public key corresponding to this private key
-    pub fn public_key(&self) -> Result<Ed25519PublicKey, String> {
-        self.0.public_key()
-            .map(Ed25519PublicKey)
-            .map_err(|e| format!("Failed to derive public key: {:?}", e))
-    }
-}
-
-#[cfg(test)]
-mod tests;```
-
-####### File: crypto/src/sign/mod.rs
-####*Size: 4.0K, Lines: 1, Type: ASCII text*
-
-```rust
-pub mod dilithium;
-pub mod eddsa;```
-
-###### File: crypto/src/lib.rs
-###*Size: 4.0K, Lines: 18, Type: ASCII text*
-
-```rust
-//! # DePIN SDK Cryptography
-//!
-//! Cryptographic implementations for the DePIN SDK including post-quantum algorithms.
-
-pub mod algorithms;
-pub mod sign;
-pub mod kem;
-pub mod security;
-
-// Simpler test module structure - don't re-export test modules
-#[cfg(test)]
-mod tests {
-    // Simple canary test to verify test discovery is working
-    #[test]
-    fn test_crypto_canary() {
-        assert!(true, "Basic test discovery is working");
-    }
-}
-```
-
-###### File: crypto/src/security.rs
-###*Size: 4.0K, Lines: 34, Type: ASCII text*
-
-```rust
-/// Post-quantum security level
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum SecurityLevel {
-    /// NIST Level 1 (approximately 128-bit classical security)
-    Level1,
-    /// NIST Level 2
-    Level2,
-    /// NIST Level 3 (approximately 192-bit classical security)
-    Level3,
-    /// NIST Level 5 (approximately 256-bit classical security)
-    Level5,
-}
-
-impl SecurityLevel {
-    /// Get the equivalent classical security bits
-    pub fn classical_bits(&self) -> usize {
-        match self {
-            SecurityLevel::Level1 => 128,
-            SecurityLevel::Level2 => 160,
-            SecurityLevel::Level3 => 192,
-            SecurityLevel::Level5 => 256,
-        }
-    }
-
-    /// Get the equivalent quantum security bits
-    pub fn quantum_bits(&self) -> usize {
-        match self {
-            SecurityLevel::Level1 => 64,
-            SecurityLevel::Level2 => 80,
-            SecurityLevel::Level3 => 96,
-            SecurityLevel::Level5 => 128,
-        }
-    }
-}
-```
-
-##### File: crypto/Cargo.toml
-##*Size: 4.0K, Lines: 18, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-crypto"
-version = "0.1.0"
-edition = "2021"
-description = "Cryptographic implementations for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-rand = { workspace = true }
-bytes = { workspace = true }
-dcrypt = { version = "0.12.0-beta.1", features = ["full"] }
-
-[features]
-default = []
-```
-
-#### Directory: homomorphic
-
-##### Directory: homomorphic/src
-
-###### Directory: homomorphic/src/computation
-
-####### Directory: homomorphic/src/computation/tests
-
-######## File: homomorphic/src/computation/tests/mod.rs
-#####*Size: 8.0K, Lines: 146, Type: ASCII text*
-
-```rust
-use super::*;
-use depin_sdk_commitment_schemes::elliptical_curve::{
-    EllipticalCurveCommitment, EllipticalCurveCommitmentScheme,
-};
-use depin_sdk_core::commitment::CommitmentScheme;
-use std::any::Any;
-
-#[test]
-fn test_computation_engine() {
-    // Create a computation engine with EllipticalCurve commitment scheme
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-    let computation = HomomorphicComputation::new(scheme.clone());
-
-    // Test add operation
-    let value_a = b"value a";
-    let value_b = b"value b";
-    let commitment_a = scheme.commit(&[Some(value_a.to_vec())]);
-    let commitment_b = scheme.commit(&[Some(value_b.to_vec())]);
-
-    let left: Arc<dyn Any + Send + Sync> = Arc::new(commitment_a.clone());
-    let right: Arc<dyn Any + Send + Sync> = Arc::new(commitment_b.clone());
-
-    let add_op = CommitmentOperation::Add { left, right };
-    let result = computation.execute(&add_op);
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let sum = result_arc
-                .downcast_ref::<EllipticalCurveCommitment>()
-                .unwrap();
-
-            // Compute expected result directly
-            let expected = scheme.add(&commitment_a, &commitment_b).unwrap();
-            assert_eq!(sum.as_ref(), expected.as_ref());
-
-            // Create a proof for the operation with a selector
-            let selector = Selector::Position(0);
-            let proof = computation
-                .create_proof_with_selector(&add_op, sum, &selector)
-                .unwrap();
-
-            // Verify the proof with context
-            let context = ProofContext::default();
-            let verified = computation
-                .verify_proof_with_context(&proof, &context)
-                .unwrap();
-            assert!(verified);
-        }
-        _ => panic!("Add operation failed or unsupported"),
-    }
-
-    // Test scalar multiply operation
-    let commitment_arc: Arc<dyn Any + Send + Sync> = Arc::new(commitment_a.clone());
-    let scalar = 3;
-
-    let scalar_op = CommitmentOperation::ScalarMultiply {
-        commitment: commitment_arc,
-        scalar,
-    };
-    let result = computation.execute(&scalar_op);
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let product = result_arc
-                .downcast_ref::<EllipticalCurveCommitment>()
-                .unwrap();
-
-            // Compute expected result directly
-            let expected = scheme.scalar_multiply(&commitment_a, scalar).unwrap();
-            assert_eq!(product.as_ref(), expected.as_ref());
-
-            // Create a proof for the operation with a key selector
-            let key = b"test_key".to_vec();
-            let selector = Selector::Key(key);
-            let proof = computation
-                .create_proof_with_selector(&scalar_op, product, &selector)
-                .unwrap();
-
-            // Create a context with some data
-            let mut context = ProofContext::default();
-            context.add_data("test", vec![1, 2, 3]);
-
-            // Verify the proof with context
-            let verified = computation
-                .verify_proof_with_context(&proof, &context)
-                .unwrap();
-            assert!(verified);
-        }
-        _ => panic!("Scalar multiply operation failed or unsupported"),
-    }
-
-    // Test combined operation and proof generation
-    let key = b"combined_op_key".to_vec();
-    let selector = Selector::Key(key);
-    let (result, proof) = computation.apply_and_prove(&add_op, &selector).unwrap();
-
-    // Verify the result and proof
-    let verified = computation.verify_proof(&proof).unwrap();
-    assert!(verified);
-
-    // The result should match direct computation
-    let expected = scheme.add(&commitment_a, &commitment_b).unwrap();
-    assert_eq!(result.as_ref(), expected.as_ref());
-}
-
-#[test]
-fn test_batch_operations() {
-    // Create a computation engine with Elliptical Curve commitment scheme
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-    let computation = HomomorphicComputation::new(scheme.clone());
-
-    // Create test commitments
-    let value_a = b"value a";
-    let value_b = b"value b";
-    let commitment_a = scheme.commit(&[Some(value_a.to_vec())]);
-    let commitment_b = scheme.commit(&[Some(value_b.to_vec())]);
-
-    // Create a batch of operations with selectors
-    let operations = vec![
-        (
-            CommitmentOperation::Add {
-                left: Arc::new(commitment_a.clone()),
-                right: Arc::new(commitment_b.clone()),
-            },
-            Selector::Position(0),
-        ),
-        (
-            CommitmentOperation::ScalarMultiply {
-                commitment: Arc::new(commitment_a.clone()),
-                scalar: 3,
-            },
-            Selector::Key(b"test_key".to_vec()),
-        ),
-    ];
-
-    // Apply batch and generate proofs
-    let batch_results = computation.apply_batch_and_prove(&operations).unwrap();
-
-    // Check the batch results
-    assert_eq!(batch_results.len(), 2);
-
-    // Verify all proofs
-    for (_, proof) in &batch_results {
-        let verified = computation.verify_proof(proof).unwrap();
-        assert!(verified);
-    }
-}```
-
-####### File: homomorphic/src/computation/mod.rs
-####*Size: 8.0K, Lines: 175, Type: ASCII text*
-
-```rust
-use crate::error::HomomorphicResult;
-use crate::operations::{
-    execute_add, execute_custom, execute_scalar_multiply, CustomOperationRegistry,
-};
-use crate::operations::{execute_batch, execute_composite, BatchResult, CompositeOperation};
-use crate::proof::{HomomorphicProof, ProofGenerator};
-use depin_sdk_core::commitment::{HomomorphicCommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-use std::sync::Arc;
-
-/// Computation engine for homomorphic operations
-pub struct HomomorphicComputation<CS: HomomorphicCommitmentScheme> {
-    /// Commitment scheme
-    scheme: CS,
-    /// Custom operation registry
-    registry: Arc<CustomOperationRegistry>,
-    /// Proof generator
-    proof_generator: ProofGenerator<CS>,
-}
-
-impl<CS: HomomorphicCommitmentScheme + Clone> HomomorphicComputation<CS> {
-    /// Create a new computation engine with the given scheme
-    pub fn new(scheme: CS) -> Self {
-        let registry = Arc::new(CustomOperationRegistry::new());
-        let proof_generator = ProofGenerator::new(scheme.clone());
-
-        Self {
-            scheme,
-            registry,
-            proof_generator,
-        }
-    }
-
-    /// Execute an operation
-    pub fn execute(&self, operation: &CommitmentOperation) -> OperationResult {
-        match operation {
-            CommitmentOperation::Add { .. } => execute_add(&self.scheme, operation),
-            CommitmentOperation::ScalarMultiply { .. } => {
-                execute_scalar_multiply(&self.scheme, operation)
-            }
-            CommitmentOperation::Custom { .. } => execute_custom(&self.registry, operation),
-        }
-    }
-
-    /// Execute a batch of operations
-    pub fn execute_batch(&self, operations: &[CommitmentOperation]) -> BatchResult {
-        execute_batch(operations, |op| self.execute(op))
-    }
-
-    /// Execute a composite operation
-    pub fn execute_composite(
-        &self,
-        operation: &CompositeOperation,
-    ) -> HomomorphicResult<OperationResult> {
-        execute_composite(operation, |op| self.execute(op))
-    }
-
-    /// Get the custom operation registry
-    pub fn registry(&self) -> Arc<CustomOperationRegistry> {
-        self.registry.clone()
-    }
-
-    /// Get the underlying commitment scheme
-    pub fn scheme(&self) -> &CS {
-        &self.scheme
-    }
-
-    /// Create a proof for an operation
-    pub fn create_proof(
-        &self,
-        operation: &CommitmentOperation,
-        result: &CS::Commitment,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        // Default to None selector for simple proofs
-        self.create_proof_with_selector(operation, result, &Selector::None)
-    }
-
-    /// Create a proof for an operation with a specific selector
-    pub fn create_proof_with_selector(
-        &self,
-        operation: &CommitmentOperation,
-        result: &CS::Commitment,
-        selector: &Selector,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        self.proof_generator
-            .prove_operation_with_selector(operation, result, selector)
-    }
-
-    /// Create a proof for an operation with a position selector
-    pub fn create_proof_at_position(
-        &self,
-        operation: &CommitmentOperation,
-        result: &CS::Commitment,
-        position: usize,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        self.create_proof_with_selector(operation, result, &Selector::Position(position))
-    }
-
-    /// Create a proof for an operation with a key selector
-    pub fn create_proof_for_key(
-        &self,
-        operation: &CommitmentOperation,
-        result: &CS::Commitment,
-        key: &[u8],
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        self.create_proof_with_selector(operation, result, &Selector::Key(key.to_vec()))
-    }
-
-    /// Verify a homomorphic proof
-    pub fn verify_proof(&self, proof: &HomomorphicProof<CS>) -> HomomorphicResult<bool> {
-        // Use default empty context for simple verification
-        self.verify_proof_with_context(proof, &ProofContext::default())
-    }
-
-    /// Verify a homomorphic proof with context
-    pub fn verify_proof_with_context(
-        &self,
-        proof: &HomomorphicProof<CS>,
-        context: &ProofContext,
-    ) -> HomomorphicResult<bool> {
-        self.proof_generator
-            .verify_proof_with_context(proof, context)
-    }
-
-    /// Apply an operation and create a proof with a specific selector
-    pub fn apply_and_prove(
-        &self,
-        operation: &CommitmentOperation,
-        selector: &Selector,
-    ) -> HomomorphicResult<(CS::Commitment, HomomorphicProof<CS>)> {
-        // Execute the operation
-        let result = match self.execute(operation) {
-            OperationResult::Success(result_arc) => {
-                match result_arc.downcast_ref::<CS::Commitment>() {
-                    Some(commitment) => commitment.clone(),
-                    None => {
-                        return Err(crate::error::HomomorphicError::InvalidInput(
-                            "Operation result is not the correct commitment type".into(),
-                        ))
-                    }
-                }
-            }
-            OperationResult::Failure(err) => {
-                return Err(crate::error::HomomorphicError::Custom(err))
-            }
-            OperationResult::Unsupported => {
-                return Err(crate::error::HomomorphicError::UnsupportedOperation(
-                    depin_sdk_core::commitment::HomomorphicOperation::Custom(0),
-                ))
-            }
-        };
-
-        // Create proof for the operation
-        let proof = self.create_proof_with_selector(operation, &result, selector)?;
-
-        Ok((result, proof))
-    }
-
-    /// Apply a batch of operations and create proofs with specified selectors
-    pub fn apply_batch_and_prove(
-        &self,
-        operations: &[(CommitmentOperation, Selector)],
-    ) -> HomomorphicResult<Vec<(CS::Commitment, HomomorphicProof<CS>)>> {
-        let mut results = Vec::with_capacity(operations.len());
-
-        for (operation, selector) in operations {
-            let (commitment, proof) = self.apply_and_prove(operation, selector)?;
-            results.push((commitment, proof));
-        }
-
-        Ok(results)
-    }
-}
-
-#[cfg(test)]
-mod tests;```
-
-###### Directory: homomorphic/src/operations
-
-####### Directory: homomorphic/src/operations/add
-
-######## Directory: homomorphic/src/operations/add/tests
-
-######### File: homomorphic/src/operations/add/tests/mod.rs
-######*Size: 4.0K, Lines: 68, Type: ASCII text*
-
-```rust
-use super::*;
-use depin_sdk_commitment_schemes::elliptical_curve::{
-    EllipticalCurveCommitment, EllipticalCurveCommitmentScheme,
-};
-use crate::operations::{add, execute_add};
-
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::homomorphic::CommitmentOperation;
-use std::any::Any;
-use std::sync::Arc;
-
-
-#[test]
-fn test_add_operation() {
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-
-    // Create two commitments
-    let value_a = b"value a";
-    let value_b = b"value b";
-    let commitment_a = scheme.commit(&[Some(value_a.to_vec())]);
-    let commitment_b = scheme.commit(&[Some(value_b.to_vec())]);
-
-    // Test direct add function
-    let sum_result = add(&scheme, &commitment_a, &commitment_b);
-    assert!(sum_result.is_ok());
-
-    // Test execute_add with CommitmentOperation
-    let left: Arc<dyn Any + Send + Sync> = Arc::new(commitment_a.clone());
-    let right: Arc<dyn Any + Send + Sync> = Arc::new(commitment_b.clone());
-
-    let operation = CommitmentOperation::Add { left, right };
-    let result = execute_add(&scheme, &operation);
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let sum = result_arc
-                .downcast_ref::<EllipticalCurveCommitment>()
-                .unwrap();
-            assert_ne!(sum.as_ref(), commitment_a.as_ref());
-            assert_ne!(sum.as_ref(), commitment_b.as_ref());
-        }
-        _ => panic!("Operation failed or unsupported"),
-    }
-}
-
-#[test]
-fn test_add_invalid_input() {
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-
-    // Create a valid commitment
-    let value = b"test value";
-    let commitment = scheme.commit(&[Some(value.to_vec())]);
-
-    // Create an invalid right operand
-    let left: Arc<dyn Any + Send + Sync> = Arc::new(commitment);
-    let right: Arc<dyn Any + Send + Sync> = Arc::new("not a commitment");
-
-    let operation = CommitmentOperation::Add { left, right };
-    let result = execute_add(&scheme, &operation);
-
-    match result {
-        OperationResult::Failure(error) => {
-            assert!(error.contains("Right operand is not the correct commitment type"));
-        }
-        _ => panic!("Expected failure for invalid input"),
-    }
-}
-
-```
-
-######## File: homomorphic/src/operations/add/mod.rs
-#####*Size: 4.0K, Lines: 58, Type: ASCII text*
-
-```rust
-use crate::error::{HomomorphicError, HomomorphicResult};
-use depin_sdk_core::commitment::HomomorphicCommitmentScheme;
-use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-use std::sync::Arc;
-
-/// Add two commitments
-pub fn add<C: HomomorphicCommitmentScheme>(
-    scheme: &C,
-    left: &C::Commitment,
-    right: &C::Commitment,
-) -> HomomorphicResult<C::Commitment> {
-    scheme.add(left, right).map_err(HomomorphicError::from)
-}
-
-/// Execute an add operation
-pub fn execute_add<C: HomomorphicCommitmentScheme>(
-    scheme: &C,
-    operation: &CommitmentOperation,
-) -> OperationResult {
-    match operation {
-        CommitmentOperation::Add { left, right } => {
-            // Try to downcast the Arc<dyn Any> to the correct commitment type
-            let left_commitment = match left.downcast_ref::<C::Commitment>() {
-                Some(c) => c,
-                None => {
-                    return OperationResult::Failure(
-                        HomomorphicError::InvalidInput(
-                            "Left operand is not the correct commitment type".into(),
-                        )
-                        .to_string(),
-                    )
-                }
-            };
-
-            let right_commitment = match right.downcast_ref::<C::Commitment>() {
-                Some(c) => c,
-                None => {
-                    return OperationResult::Failure(
-                        HomomorphicError::InvalidInput(
-                            "Right operand is not the correct commitment type".into(),
-                        )
-                        .to_string(),
-                    )
-                }
-            };
-
-            // Perform the addition
-            match add(scheme, left_commitment, right_commitment) {
-                Ok(result) => OperationResult::Success(Arc::new(result)),
-                Err(e) => OperationResult::Failure(e.to_string()),
-            }
-        }
-        _ => OperationResult::Unsupported,
-    }
-}
-
-#[cfg(test)]
-mod tests;
-```
-
-####### Directory: homomorphic/src/operations/batch
-
-######## Directory: homomorphic/src/operations/batch/tests
-
-######### File: homomorphic/src/operations/batch/tests/mod.rs
-######*Size: 8.0K, Lines: 197, Type: ASCII text*
-
-```rust
-use super::*;
-use depin_sdk_core::homomorphic::OperationResult;
-use std::any::Any;
-
-#[test]
-fn test_batch_execution() {
-    // Create a mock executor
-    let executor = |op: &CommitmentOperation| match op {
-        CommitmentOperation::Custom { operation_id, .. } => {
-            if operation_id == "succeed" {
-                OperationResult::Success(Arc::new(true))
-            } else if operation_id == "fail" {
-                OperationResult::Failure("Operation failed".into())
-            } else {
-                OperationResult::Unsupported
-            }
-        }
-        _ => OperationResult::Unsupported,
-    };
-
-    // Create a batch of operations
-    let operations = vec![
-        CommitmentOperation::Custom {
-            operation_id: "succeed".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-        CommitmentOperation::Custom {
-            operation_id: "succeed".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-        CommitmentOperation::Custom {
-            operation_id: "fail".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-        CommitmentOperation::Custom {
-            operation_id: "unknown".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-    ];
-
-    // Execute the batch
-    let batch_result = execute_batch(&operations[..], executor);
-
-    // Check the results
-    assert_eq!(batch_result.results.len(), 4);
-    assert_eq!(batch_result.success_count, 2);
-    assert_eq!(batch_result.failure_count, 1);
-    assert_eq!(batch_result.unsupported_count, 1);
-    assert!(!batch_result.all_successful());
-    assert_eq!(batch_result.success_rate(), 50.0);
-}
-
-#[test]
-fn test_composite_sequence() {
-    // Create a mock executor
-    let executor = |op: &CommitmentOperation| match op {
-        CommitmentOperation::Custom { operation_id, .. } => {
-            if operation_id == "succeed" {
-                OperationResult::Success(Arc::new(true))
-            } else {
-                OperationResult::Failure("Operation failed".into())
-            }
-        }
-        _ => OperationResult::Unsupported,
-    };
-
-    // Create a sequence of operations
-    let sequence = CompositeOperation::Sequence(vec![
-        CommitmentOperation::Custom {
-            operation_id: "succeed".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-        CommitmentOperation::Custom {
-            operation_id: "succeed".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-    ]);
-
-    // Execute the sequence
-    let result = execute_composite(&sequence, executor).unwrap();
-
-    match result {
-        OperationResult::Success(_) => {} // Expected
-        _ => panic!("Expected successful sequence execution"),
-    }
-
-    // Create a sequence with a failure
-    let sequence_with_failure = CompositeOperation::Sequence(vec![
-        CommitmentOperation::Custom {
-            operation_id: "succeed".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-        CommitmentOperation::Custom {
-            operation_id: "fail".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        },
-    ]);
-
-    // Execute the sequence with failure
-    let result = execute_composite(&sequence_with_failure, executor).unwrap();
-
-    match result {
-        OperationResult::Failure(error) => {
-            assert_eq!(error, "Operation failed");
-        }
-        _ => panic!("Expected failure in sequence execution"),
-    }
-}
-
-#[test]
-fn test_composite_conditional() {
-    // Create a mock executor
-    let executor = |op: &CommitmentOperation| match op {
-        CommitmentOperation::Custom { operation_id, .. } => {
-            if operation_id == "condition_true" {
-                OperationResult::Success(Arc::new(true) as Arc<dyn Any + Send + Sync>)
-            } else if operation_id == "condition_false" {
-                OperationResult::Success(Arc::new(false) as Arc<dyn Any + Send + Sync>)
-            } else if operation_id == "true_path" {
-                OperationResult::Success(Arc::new("true_path_result") as Arc<dyn Any + Send + Sync>)
-            } else if operation_id == "false_path" {
-                OperationResult::Success(Arc::new("false_path_result") as Arc<dyn Any + Send + Sync>)
-            } else {
-                OperationResult::Unsupported
-            }
-        }
-        _ => OperationResult::Unsupported,
-    };
-
-    // Create a conditional operation (true condition)
-    let conditional_true = CompositeOperation::Conditional {
-        condition: Box::new(CommitmentOperation::Custom {
-            operation_id: "condition_true".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        }),
-        if_true: Box::new(CompositeOperation::Single(CommitmentOperation::Custom {
-            operation_id: "true_path".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        })),
-        if_false: Box::new(CompositeOperation::Single(CommitmentOperation::Custom {
-            operation_id: "false_path".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        })),
-    };
-
-    // Execute the conditional (true path)
-    let result = execute_composite(&conditional_true, executor).unwrap();
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let result = result_arc.downcast_ref::<&str>().unwrap();
-            assert_eq!(*result, "true_path_result");
-        }
-        _ => panic!("Expected successful conditional execution (true path)"),
-    }
-
-    // Create a conditional operation (false condition)
-    let conditional_false = CompositeOperation::Conditional {
-        condition: Box::new(CommitmentOperation::Custom {
-            operation_id: "condition_false".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        }),
-        if_true: Box::new(CompositeOperation::Single(CommitmentOperation::Custom {
-            operation_id: "true_path".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        })),
-        if_false: Box::new(CompositeOperation::Single(CommitmentOperation::Custom {
-            operation_id: "false_path".to_string(),
-            inputs: vec![],
-            parameters: vec![],
-        })),
-    };
-
-    // Execute the conditional (false path)
-    let result = execute_composite(&conditional_false, executor).unwrap();
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let result = result_arc.downcast_ref::<&str>().unwrap();
-            assert_eq!(*result, "false_path_result");
-        }
-        _ => panic!("Expected successful conditional execution (false path)"),
-    }
-}
-```
-
-######## File: homomorphic/src/operations/batch/mod.rs
-#####*Size: 12K, Lines: 249, Type: ASCII text*
-
-```rust
-use crate::error::{HomomorphicError, HomomorphicResult};
-use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-use std::sync::Arc;
-
-/// Composite operation for complex computations
-#[derive(Debug, Clone)]
-pub enum CompositeOperation {
-    /// Execute operations in sequence
-    Sequence(Vec<CommitmentOperation>),
-
-    /// Execute operations in parallel
-    Parallel(Vec<CommitmentOperation>),
-
-    /// Conditional operation based on a boolean condition
-    Conditional {
-        /// Condition operation (expected to return a boolean)
-        condition: Box<CommitmentOperation>,
-        /// Operation to execute if condition is true
-        if_true: Box<CompositeOperation>,
-        /// Operation to execute if condition is false
-        if_false: Box<CompositeOperation>,
-    },
-
-    /// Loop until a condition is met
-    Loop {
-        /// Maximum number of iterations
-        max_iterations: usize,
-        /// Condition operation (expected to return a boolean)
-        condition: Box<CommitmentOperation>,
-        /// Operation to execute in each iteration
-        body: Box<CompositeOperation>,
-    },
-
-    /// Single operation
-    Single(CommitmentOperation),
-}
-
-/// Result of a batch operation
-#[derive(Debug, Clone)]
-pub struct BatchResult {
-    /// Results of individual operations
-    pub results: Vec<OperationResult>,
-    /// Number of successful operations
-    pub success_count: usize,
-    /// Number of failed operations
-    pub failure_count: usize,
-    /// Number of unsupported operations
-    pub unsupported_count: usize,
-}
-
-impl BatchResult {
-    /// Create a new empty batch result
-    pub fn new() -> Self {
-        Self {
-            results: Vec::new(),
-            success_count: 0,
-            failure_count: 0,
-            unsupported_count: 0,
-        }
-    }
-
-    /// Add a result to the batch
-    pub fn add_result(&mut self, result: OperationResult) {
-        match &result {
-            OperationResult::Success(_) => self.success_count += 1,
-            OperationResult::Failure(_) => self.failure_count += 1,
-            OperationResult::Unsupported => self.unsupported_count += 1,
-        }
-
-        self.results.push(result);
-    }
-
-    /// Check if all operations were successful
-    pub fn all_successful(&self) -> bool {
-        self.failure_count == 0 && self.unsupported_count == 0
-    }
-
-    /// Get the success rate as a percentage
-    pub fn success_rate(&self) -> f64 {
-        if self.results.is_empty() {
-            0.0
-        } else {
-            (self.success_count as f64) / (self.results.len() as f64) * 100.0
-        }
-    }
-}
-
-// Add Default implementation for BatchResult
-impl Default for BatchResult {
-    fn default() -> Self {
-        Self::new()
-    }
-}
-
-/// Execute batch operations
-pub fn execute_batch<F>(operations: &[CommitmentOperation], executor: F) -> BatchResult
-where
-    F: Fn(&CommitmentOperation) -> OperationResult,
-{
-    let mut result = BatchResult::new();
-
-    for op in operations {
-        let op_result = executor(op);
-        result.add_result(op_result);
-    }
-
-    result
-}
-
-/// Execute a composite operation
-pub fn execute_composite<F>(
-    operation: &CompositeOperation,
-    executor: F,
-) -> HomomorphicResult<OperationResult>
-where
-    F: Fn(&CommitmentOperation) -> OperationResult + Copy,
-{
-    match operation {
-        CompositeOperation::Sequence(ops) => {
-            let mut last_result = OperationResult::Success(Arc::new(()));
-
-            for op in ops {
-                last_result = executor(op);
-
-                // If any operation fails, return immediately
-                if let OperationResult::Failure(_) = &last_result {
-                    return Ok(last_result);
-                }
-            }
-
-            Ok(last_result)
-        }
-
-        CompositeOperation::Parallel(ops) => {
-            let batch = execute_batch(ops, executor);
-
-            // If all operations are successful, return the last result
-            if batch.all_successful() && !batch.results.is_empty() {
-                if let Some(last) = batch.results.last() {
-                    return Ok(last.clone());
-                }
-            } else if !batch.all_successful() {
-                // Return the first failure
-                for result in &batch.results {
-                    if let OperationResult::Failure(_) = result {
-                        return Ok(result.clone());
-                    }
-                }
-
-                // If no failures but some unsupported, return unsupported
-                return Ok(OperationResult::Unsupported);
-            }
-
-            // Empty batch
-            Ok(OperationResult::Success(Arc::new(())))
-        }
-
-        CompositeOperation::Conditional {
-            condition,
-            if_true,
-            if_false,
-        } => {
-            // Execute the condition
-            let condition_result = executor(condition);
-
-            match condition_result {
-                OperationResult::Success(result) => {
-                    // Try to downcast to bool
-                    match result.downcast_ref::<bool>() {
-                        Some(&true) => execute_composite(if_true, executor),
-                        Some(&false) => execute_composite(if_false, executor),
-                        None => Err(HomomorphicError::InvalidInput(
-                            "Condition did not return a boolean value".into(),
-                        )),
-                    }
-                }
-                OperationResult::Failure(error) => Ok(OperationResult::Failure(format!(
-                    "Condition failed: {}",
-                    error
-                ))),
-                OperationResult::Unsupported => Ok(OperationResult::Failure(
-                    "Condition operation is unsupported".into(),
-                )),
-            }
-        }
-
-        CompositeOperation::Loop {
-            max_iterations,
-            condition,
-            body,
-        } => {
-            let mut iterations = 0;
-
-            loop {
-                // Check maximum iterations
-                if iterations >= *max_iterations {
-                    return Ok(OperationResult::Success(Arc::new(iterations)));
-                }
-
-                // Evaluate condition
-                let condition_result = executor(condition);
-
-                match condition_result {
-                    OperationResult::Success(result) => {
-                        // Try to downcast to bool
-                        match result.downcast_ref::<bool>() {
-                            Some(&true) => {
-                                // Continue loop, execute body
-                                let body_result = execute_composite(body, executor)?;
-
-                                // If body execution fails, propagate the error
-                                if let OperationResult::Failure(_) = body_result {
-                                    return Ok(body_result);
-                                }
-
-                                // Increment iteration count
-                                iterations += 1;
-                            }
-                            Some(&false) => {
-                                // Exit loop
-                                return Ok(OperationResult::Success(Arc::new(iterations)));
-                            }
-                            None => {
-                                return Err(HomomorphicError::InvalidInput(
-                                    "Loop condition did not return a boolean value".into(),
-                                ));
-                            }
-                        }
-                    }
-                    OperationResult::Failure(error) => {
-                        return Ok(OperationResult::Failure(format!(
-                            "Loop condition failed after {} iterations: {}",
-                            iterations, error
-                        )));
-                    }
-                    OperationResult::Unsupported => {
-                        return Ok(OperationResult::Failure(
-                            "Loop condition operation is unsupported".into(),
-                        ));
-                    }
-                }
-            }
-        }
-
-        CompositeOperation::Single(op) => Ok(executor(op)),
-    }
-}
-
-#[cfg(test)]
-mod tests;```
-
-####### Directory: homomorphic/src/operations/custom
-
-######## Directory: homomorphic/src/operations/custom/tests
-
-######### File: homomorphic/src/operations/custom/tests/mod.rs
-######*Size: 4.0K, Lines: 128, Type: C source, ASCII text*
-
-```rust
-use super::*;
-
-// Mock commitment for testing
-#[derive(Debug, Clone)]
-struct MockCommitment(i32);
-
-#[test]
-fn test_custom_operation_registry() {
-    let registry = CustomOperationRegistry::new();
-
-    // Register a custom operation
-    registry
-        .register("test_op", |inputs, _params| {
-            if inputs.is_empty() {
-                return Err(HomomorphicError::InvalidInput("No inputs provided".into()));
-            }
-
-            // Try to downcast the first input to MockCommitment
-            let input = match inputs[0].downcast_ref::<MockCommitment>() {
-                Some(c) => c,
-                None => return Err(HomomorphicError::InvalidInput("Invalid input type".into())),
-            };
-
-            // Double the value
-            let result = MockCommitment(input.0 * 2);
-
-            Ok(Arc::new(result) as Arc<dyn Any + Send + Sync>)
-        })
-        .unwrap();
-
-    // Check that the operation is registered
-    assert!(registry.has_operation("test_op"));
-    assert_eq!(registry.operation_count(), 1);
-    assert_eq!(registry.list_operations(), vec!["test_op".to_string()]);
-
-    // Test the custom operation
-    let mock_commitment = MockCommitment(5);
-    let inputs = vec![Arc::new(mock_commitment) as Arc<dyn Any + Send + Sync>];
-    let parameters = vec![];
-
-    let operation = CommitmentOperation::Custom {
-        operation_id: "test_op".to_string(),
-        inputs,
-        parameters,
-    };
-
-    let result = execute_custom(&registry, &operation);
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let result = result_arc.downcast_ref::<MockCommitment>().unwrap();
-            assert_eq!(result.0, 10); // Should be doubled
-        }
-        _ => panic!("Operation failed or unsupported"),
-    }
-
-    // Test an unregistered operation
-    let inputs = vec![Arc::new(MockCommitment(5)) as Arc<dyn Any + Send + Sync>];
-    let parameters = vec![];
-
-    let operation = CommitmentOperation::Custom {
-        operation_id: "unknown_op".to_string(),
-        inputs,
-        parameters,
-    };
-
-    let result = execute_custom(&registry, &operation);
-
-    match result {
-        OperationResult::Unsupported => {} // This is expected
-        _ => panic!("Expected unsupported for unknown operation"),
-    }
-
-    // Unregister the operation
-    let unregistered = registry.unregister("test_op").unwrap();
-    assert!(unregistered);
-    assert_eq!(registry.operation_count(), 0);
-}
-
-#[test]
-fn test_invalid_input_to_custom_operation() {
-    let registry = CustomOperationRegistry::new();
-
-    // Register a custom operation that expects a specific type
-    registry
-        .register("type_check", |inputs, _params| {
-            if inputs.is_empty() {
-                return Err(HomomorphicError::InvalidInput("No inputs provided".into()));
-            }
-
-            // Expect a MockCommitment
-            if inputs[0].downcast_ref::<MockCommitment>().is_none() {
-                return Err(HomomorphicError::InvalidInput(
-                    "Expected MockCommitment".into(),
-                ));
-            }
-
-            Ok(Arc::new(true) as Arc<dyn Any + Send + Sync>)
-        })
-        .unwrap();
-
-    // Test with wrong input type
-    let inputs = vec![Arc::new("not a commitment") as Arc<dyn Any + Send + Sync>];
-    let parameters = vec![];
-
-    let operation = CommitmentOperation::Custom {
-        operation_id: "type_check".to_string(),
-        inputs,
-        parameters,
-    };
-
-    let result = execute_custom(&registry, &operation);
-
-    match result {
-        OperationResult::Failure(error) => {
-            assert!(error.contains("Expected MockCommitment"));
-        }
-        _ => panic!("Expected failure for invalid input type"),
-    }
-}
-
-#[test]
-fn test_default_implementation() {
-    // Test that Default creates a new empty registry
-    let registry = CustomOperationRegistry::default();
-    assert_eq!(registry.operation_count(), 0);
-    assert!(registry.list_operations().is_empty());
-}
-```
-
-######## File: homomorphic/src/operations/custom/mod.rs
-#####*Size: 4.0K, Lines: 133, Type: ASCII text*
-
-```rust
-use crate::error::{HomomorphicError, HomomorphicResult};
-use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-use std::any::Any;
-use std::collections::HashMap;
-use std::sync::{Arc, RwLock};
-
-/// Type for custom operation handler
-pub type CustomOperationHandler = Arc<
-    dyn Fn(&[Arc<dyn Any + Send + Sync>], &[u8]) -> HomomorphicResult<Arc<dyn Any + Send + Sync>>
-        + Send
-        + Sync,
->;
-
-/// Registry for custom operations
-pub struct CustomOperationRegistry {
-    /// Map of operation IDs to handlers
-    pub(crate) handlers: RwLock<HashMap<String, CustomOperationHandler>>,
-}
-
-impl CustomOperationRegistry {
-    /// Create a new custom operation registry
-    pub fn new() -> Self {
-        Self {
-            handlers: RwLock::new(HashMap::new()),
-        }
-    }
-
-    /// Register a custom operation handler
-    pub fn register<F>(&self, operation_id: &str, handler: F) -> HomomorphicResult<()>
-    where
-        F: Fn(
-                &[Arc<dyn Any + Send + Sync>],
-                &[u8],
-            ) -> HomomorphicResult<Arc<dyn Any + Send + Sync>>
-            + Send
-            + Sync
-            + 'static,
-    {
-        let mut handlers = self
-            .handlers
-            .write()
-            .map_err(|_| HomomorphicError::InternalError("Failed to acquire write lock".into()))?;
-
-        handlers.insert(operation_id.to_string(), Arc::new(handler));
-        Ok(())
-    }
-
-    /// Unregister a custom operation handler
-    pub fn unregister(&self, operation_id: &str) -> HomomorphicResult<bool> {
-        let mut handlers = self
-            .handlers
-            .write()
-            .map_err(|_| HomomorphicError::InternalError("Failed to acquire write lock".into()))?;
-
-        Ok(handlers.remove(operation_id).is_some())
-    }
-
-    /// Check if a custom operation is registered
-    pub fn has_operation(&self, operation_id: &str) -> bool {
-        if let Ok(handlers) = self.handlers.read() {
-            handlers.contains_key(operation_id)
-        } else {
-            false
-        }
-    }
-
-    /// Get the number of registered operations
-    pub fn operation_count(&self) -> usize {
-        if let Ok(handlers) = self.handlers.read() {
-            handlers.len()
-        } else {
-            0
-        }
-    }
-
-    /// List all registered operation IDs
-    pub fn list_operations(&self) -> Vec<String> {
-        if let Ok(handlers) = self.handlers.read() {
-            handlers.keys().cloned().collect()
-        } else {
-            Vec::new()
-        }
-    }
-}
-
-impl Default for CustomOperationRegistry {
-    fn default() -> Self {
-        Self::new()
-    }
-}
-
-/// Execute a custom operation
-pub fn execute_custom(
-    registry: &CustomOperationRegistry,
-    operation: &CommitmentOperation,
-) -> OperationResult {
-    match operation {
-        CommitmentOperation::Custom {
-            operation_id,
-            inputs,
-            parameters,
-        } => {
-            // Check if the operation is registered
-            if !registry.has_operation(operation_id) {
-                return OperationResult::Unsupported;
-            }
-
-            // Get the handler
-            let handler = match registry.handlers.read() {
-                Ok(handlers) => match handlers.get(operation_id) {
-                    Some(h) => h.clone(),
-                    None => return OperationResult::Unsupported,
-                },
-                Err(_) => {
-                    return OperationResult::Failure(
-                        HomomorphicError::InternalError("Failed to acquire read lock".into())
-                            .to_string(),
-                    )
-                }
-            };
-
-            // Execute the handler - inputs are already Arc<dyn Any + Send + Sync>
-            match handler(inputs, parameters) {
-                Ok(result) => OperationResult::Success(result),
-                Err(e) => OperationResult::Failure(e.to_string()),
-            }
-        }
-        _ => OperationResult::Unsupported,
-    }
-}
-
-#[cfg(test)]
-mod tests;
-```
-
-####### Directory: homomorphic/src/operations/scalar_multiply
-
-######## Directory: homomorphic/src/operations/scalar_multiply/tests
-
-######### File: homomorphic/src/operations/scalar_multiply/tests/mod.rs
-######*Size: 4.0K, Lines: 108, Type: ASCII text*
-
-```rust
-use super::*;
-use depin_sdk_commitment_schemes::elliptical_curve::{
-    EllipticalCurveCommitment, EllipticalCurveCommitmentScheme,
-};
-use depin_sdk_core::commitment::CommitmentScheme;
-use std::any::Any;
-
-#[test]
-fn test_scalar_multiply() {
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-
-    // Create a commitment
-    let value = b"test value";
-    let commitment = scheme.commit(&[Some(value.to_vec())]);
-
-    // Test direct scalar_multiply function with valid scalar
-    let scalar = 3;
-    let product_result = scalar_multiply(&scheme, &commitment, scalar);
-    assert!(product_result.is_ok());
-
-    // Test with negative scalar
-    let negative_result = scalar_multiply(&scheme, &commitment, -1);
-    assert!(negative_result.is_err());
-    assert!(matches!(
-        negative_result.unwrap_err(),
-        HomomorphicError::NegativeScalar
-    ));
-}
-
-#[test]
-fn test_execute_scalar_multiply() {
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-
-    // Create a commitment
-    let value = b"test value";
-    let commitment = scheme.commit(&[Some(value.to_vec())]);
-
-    // Test execute_scalar_multiply with CommitmentOperation
-    let commitment_arc: Arc<dyn Any + Send + Sync> = Arc::new(commitment.clone());
-    let scalar = 3;
-
-    let operation = CommitmentOperation::ScalarMultiply {
-        commitment: commitment_arc,
-        scalar,
-    };
-
-    let result = execute_scalar_multiply(&scheme, &operation);
-
-    match result {
-        OperationResult::Success(result_arc) => {
-            let product = result_arc
-                .downcast_ref::<EllipticalCurveCommitment>()
-                .unwrap();
-            assert_ne!(product.as_ref(), commitment.as_ref());
-        }
-        _ => panic!("Operation failed or unsupported"),
-    }
-}
-
-#[test]
-fn test_scalar_multiply_invalid_input() {
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-
-    // Create an invalid commitment
-    let commitment_arc: Arc<dyn Any + Send + Sync> = Arc::new("not a commitment");
-    let scalar = 3;
-
-    let operation = CommitmentOperation::ScalarMultiply {
-        commitment: commitment_arc,
-        scalar,
-    };
-
-    let result = execute_scalar_multiply(&scheme, &operation);
-
-    match result {
-        OperationResult::Failure(error) => {
-            assert!(error.contains("Commitment is not the correct type"));
-        }
-        _ => panic!("Expected failure for invalid input"),
-    }
-}
-
-#[test]
-fn test_scalar_multiply_negative_scalar() {
-    let scheme = EllipticalCurveCommitmentScheme::new(5);
-
-    // Create a valid commitment
-    let value = b"test value";
-    let commitment = scheme.commit(&[Some(value.to_vec())]);
-    let commitment_arc: Arc<dyn Any + Send + Sync> = Arc::new(commitment);
-
-    // Use a negative scalar
-    let scalar = -1;
-
-    let operation = CommitmentOperation::ScalarMultiply {
-        commitment: commitment_arc,
-        scalar,
-    };
-
-    let result = execute_scalar_multiply(&scheme, &operation);
-
-    match result {
-        OperationResult::Failure(error) => {
-            assert!(error.contains("Scalar must be positive"));
-        }
-        _ => panic!("Expected failure for negative scalar"),
-    }
-}
-```
-
-######## File: homomorphic/src/operations/scalar_multiply/mod.rs
-#####*Size: 4.0K, Lines: 50, Type: ASCII text*
-
-```rust
-use crate::error::{HomomorphicError, HomomorphicResult};
-use depin_sdk_core::commitment::HomomorphicCommitmentScheme;
-use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-use std::sync::Arc;
-
-/// Multiply a commitment by a scalar
-pub fn scalar_multiply<C: HomomorphicCommitmentScheme>(
-    scheme: &C,
-    commitment: &C::Commitment,
-    scalar: i32,
-) -> HomomorphicResult<C::Commitment> {
-    if scalar <= 0 {
-        return Err(HomomorphicError::NegativeScalar);
-    }
-
-    scheme
-        .scalar_multiply(commitment, scalar)
-        .map_err(HomomorphicError::from)
-}
-
-/// Execute a scalar multiply operation
-pub fn execute_scalar_multiply<C: HomomorphicCommitmentScheme>(
-    scheme: &C,
-    operation: &CommitmentOperation,
-) -> OperationResult {
-    match operation {
-        CommitmentOperation::ScalarMultiply { commitment, scalar } => {
-            // Try to downcast the Arc<dyn Any> to the correct commitment type
-            let commitment = match commitment.downcast_ref::<C::Commitment>() {
-                Some(c) => c,
-                None => {
-                    return OperationResult::Failure(
-                        HomomorphicError::InvalidInput("Commitment is not the correct type".into())
-                            .to_string(),
-                    )
-                }
-            };
-
-            // Perform the scalar multiplication
-            match scalar_multiply(scheme, commitment, *scalar) {
-                Ok(result) => OperationResult::Success(Arc::new(result)),
-                Err(e) => OperationResult::Failure(e.to_string()),
-            }
-        }
-        _ => OperationResult::Unsupported,
-    }
-}
-
-#[cfg(test)]
-mod tests;
-```
-
-####### Directory: homomorphic/src/operations/tests
-
-######## File: homomorphic/src/operations/tests/mod.rs
-#####*Size: 4.0K, Lines: 1, Type: very short file (no magic)*
-
-#####*File content not included (exceeds threshold or non-text file)*
-
-####### File: homomorphic/src/operations/execute.rs
-####*Size: 4.0K, Lines: 55, Type: ASCII text*
-
-```rust
-use crate::error::{HomomorphicError, HomomorphicResult};
-use depin_sdk_core::commitment::HomomorphicCommitmentScheme;
-use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-use std::sync::Arc;
-
-/// Add two commitments
-pub fn add<C: HomomorphicCommitmentScheme>(
-    scheme: &C,
-    left: &C::Commitment,
-    right: &C::Commitment,
-) -> HomomorphicResult<C::Commitment> {
-    scheme.add(left, right).map_err(HomomorphicError::from)
-}
-
-/// Execute an add operation
-pub fn execute_add<C: HomomorphicCommitmentScheme>(
-    scheme: &C,
-    operation: &CommitmentOperation,
-) -> OperationResult {
-    match operation {
-        CommitmentOperation::Add { left, right } => {
-            // Try to downcast the Arc<dyn Any> to the correct commitment type
-            let left_commitment = match left.downcast_ref::<C::Commitment>() {
-                Some(c) => c,
-                None => {
-                    return OperationResult::Failure(
-                        HomomorphicError::InvalidInput(
-                            "Left operand is not the correct commitment type".into(),
-                        )
-                        .to_string(),
-                    )
-                }
-            };
-
-            let right_commitment = match right.downcast_ref::<C::Commitment>() {
-                Some(c) => c,
-                None => {
-                    return OperationResult::Failure(
-                        HomomorphicError::InvalidInput(
-                            "Right operand is not the correct commitment type".into(),
-                        )
-                        .to_string(),
-                    )
-                }
-            };
-
-            // Perform the addition
-            match add(scheme, left_commitment, right_commitment) {
-                Ok(result) => OperationResult::Success(Arc::new(result)),
-                Err(e) => OperationResult::Failure(e.to_string()),
-            }
-        }
-        _ => OperationResult::Unsupported,
-    }
-}
-```
-
-####### File: homomorphic/src/operations/mod.rs
-####*Size: 4.0K, Lines: 14, Type: ASCII text*
-
-```rust
-//! Operation implementations on commitments
-
-mod add;
-mod batch;
-mod custom;
-mod scalar_multiply;
-
-#[cfg(test)]
-mod tests;
-
-// Use explicit imports instead of glob imports to avoid ambiguity
-pub use add::{add, execute_add};
-pub use batch::{execute_batch, execute_composite, BatchResult, CompositeOperation};
-pub use custom::{execute_custom, CustomOperationHandler, CustomOperationRegistry};
-pub use scalar_multiply::{execute_scalar_multiply, scalar_multiply};```
-
-###### File: homomorphic/src/error.rs
-###*Size: 4.0K, Lines: 69, Type: ASCII text*
-
-```rust
-use depin_sdk_core::commitment::HomomorphicOperation;
-use std::error::Error;
-use std::fmt;
-
-/// Errors that can occur during homomorphic operations
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum HomomorphicError {
-    /// Invalid point in a commitment
-    InvalidPoint(String),
-    /// Negative or zero scalar in scalar multiplication
-    NegativeScalar,
-    /// Position is out of bounds
-    OutOfBounds(usize, usize),
-    /// Operation not supported by the commitment scheme
-    UnsupportedOperation(HomomorphicOperation),
-    /// Proof verification failed
-    VerificationFailure,
-    /// Internal operation error
-    InternalError(String),
-    /// Invalid input for an operation
-    InvalidInput(String),
-    /// Custom error with message
-    Custom(String),
-}
-
-impl fmt::Display for HomomorphicError {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        match self {
-            HomomorphicError::InvalidPoint(details) => {
-                write!(f, "Invalid point in commitment: {}", details)
-            }
-            HomomorphicError::NegativeScalar => {
-                write!(f, "Scalar must be positive in scalar multiplication")
-            }
-            HomomorphicError::OutOfBounds(pos, max) => {
-                write!(f, "Position {} out of bounds (max: {})", pos, max)
-            }
-            HomomorphicError::UnsupportedOperation(op) => {
-                write!(f, "Operation not supported: {:?}", op)
-            }
-            HomomorphicError::VerificationFailure => write!(f, "Proof verification failed"),
-            HomomorphicError::InternalError(details) => {
-                write!(f, "Internal operation error: {}", details)
-            }
-            HomomorphicError::InvalidInput(details) => {
-                write!(f, "Invalid input for operation: {}", details)
-            }
-            HomomorphicError::Custom(msg) => write!(f, "{}", msg),
-        }
-    }
-}
-
-impl Error for HomomorphicError {}
-
-/// Convenience type for operation results
-pub type HomomorphicResult<T> = Result<T, HomomorphicError>;
-
-/// Convert string errors to HomomorphicError
-impl From<String> for HomomorphicError {
-    fn from(s: String) -> Self {
-        HomomorphicError::Custom(s)
-    }
-}
-
-/// Convert &str errors to HomomorphicError
-impl From<&str> for HomomorphicError {
-    fn from(s: &str) -> Self {
-        HomomorphicError::Custom(s.to_string())
-    }
-}```
-
-###### File: homomorphic/src/lib.rs
-###*Size: 4.0K, Lines: 23, Type: ASCII text*
-
-```rust
-// homomorphic/src/lib.rs
-//! # DePIN SDK Homomorphic Operations
-//!
-//! Implementation of homomorphic operations on commitments for the DePIN SDK.
-
-pub mod computation;
-pub mod error;
-pub mod operations;
-pub mod proof;
-
-pub use depin_sdk_core::commitment::{
-    CommitmentScheme, HomomorphicCommitmentScheme, HomomorphicOperation,
-};
-pub use depin_sdk_core::homomorphic::{CommitmentOperation, OperationResult};
-
-// Re-export key components for easier access
-pub use computation::HomomorphicComputation;
-pub use error::{HomomorphicError, HomomorphicResult};
-pub use operations::{
-    add, execute_add, execute_batch, execute_composite, execute_custom, execute_scalar_multiply,
-    scalar_multiply, BatchResult, CompositeOperation, CustomOperationRegistry,
-};
-pub use proof::{HomomorphicProof, ProofGenerator};
-```
-
-###### File: homomorphic/src/proof.rs
-###*Size: 16K, Lines: 356, Type: ASCII text*
-
-```rust
-use crate::error::{HomomorphicError, HomomorphicResult};
-use depin_sdk_core::commitment::HomomorphicCommitmentScheme;
-use depin_sdk_core::commitment::HomomorphicOperation;
-// FIX: Remove unused imports.
-use depin_sdk_core::commitment::{ProofContext, Selector};
-use depin_sdk_core::homomorphic::CommitmentOperation;
-use std::fmt::Debug;
-use std::marker::PhantomData;
-
-/// Proof that a commitment is the result of a homomorphic operation
-#[derive(Debug, Clone)]
-pub struct HomomorphicProof<CS: HomomorphicCommitmentScheme> {
-    /// Type of operation
-    operation_type: HomomorphicOperation,
-    /// Input commitments
-    inputs: Vec<CS::Commitment>,
-    /// Result commitment
-    result: CS::Commitment,
-    /// Selector used for this proof
-    selector: Selector,
-    /// Additional data for verification
-    auxiliary_data: Vec<u8>,
-    /// Phantom data for commitment scheme
-    _phantom: PhantomData<CS>,
-}
-
-impl<CS: HomomorphicCommitmentScheme> HomomorphicProof<CS> {
-    /// Create a new homomorphic proof
-    pub fn new(
-        operation_type: HomomorphicOperation,
-        inputs: Vec<CS::Commitment>,
-        result: CS::Commitment,
-        selector: Selector,
-        auxiliary_data: Vec<u8>,
-    ) -> Self {
-        Self {
-            operation_type,
-            inputs,
-            result,
-            selector,
-            auxiliary_data,
-            _phantom: PhantomData,
-        }
-    }
-
-    /// Create a new homomorphic proof with default selector (None)
-    pub fn new_simple(
-        operation_type: HomomorphicOperation,
-        inputs: Vec<CS::Commitment>,
-        result: CS::Commitment,
-        auxiliary_data: Vec<u8>,
-    ) -> Self {
-        Self::new(
-            operation_type,
-            inputs,
-            result,
-            Selector::None,
-            auxiliary_data,
-        )
-    }
-
-    /// Get the operation type
-    pub fn operation_type(&self) -> HomomorphicOperation {
-        self.operation_type
-    }
-
-    /// Get the input commitments
-    pub fn inputs(&self) -> &[CS::Commitment] {
-        &self.inputs
-    }
-
-    /// Get the result commitment
-    pub fn result(&self) -> &CS::Commitment {
-        &self.result
-    }
-
-    /// Get the selector used for this proof
-    pub fn selector(&self) -> &Selector {
-        &self.selector
-    }
-
-    /// Get the auxiliary data
-    pub fn auxiliary_data(&self) -> &[u8] {
-        &self.auxiliary_data
-    }
-
-    /// Serialize the proof to bytes
-    pub fn to_bytes(&self) -> HomomorphicResult<Vec<u8>> {
-        // This is a simplified serialization implementation
-        // In a real implementation, we would use a proper serialization format
-
-        let mut result = Vec::new();
-
-        // Serialize operation type
-        match self.operation_type {
-            HomomorphicOperation::Addition => result.push(1),
-            HomomorphicOperation::ScalarMultiplication => result.push(2),
-            HomomorphicOperation::Custom(id) => {
-                result.push(3);
-                result.extend_from_slice(&(id).to_le_bytes());
-            }
-        }
-
-        // Serialize input count
-        result.extend_from_slice(&(self.inputs.len() as u32).to_le_bytes());
-
-        // Serialize inputs
-        for input in &self.inputs {
-            let bytes = input.as_ref().to_vec();
-            result.extend_from_slice(&(bytes.len() as u32).to_le_bytes());
-            result.extend_from_slice(&bytes);
-        }
-
-        // Serialize result
-        let result_bytes = self.result.as_ref().to_vec();
-        result.extend_from_slice(&(result_bytes.len() as u32).to_le_bytes());
-        result.extend_from_slice(&result_bytes);
-
-        // Serialize selector type
-        match &self.selector {
-            Selector::Position(_) => result.push(1),
-            Selector::Key(_) => result.push(2),
-            Selector::Predicate(_) => result.push(3),
-            Selector::None => result.push(0),
-        }
-
-        // Serialize selector data if present
-        match &self.selector {
-            Selector::Position(pos) => {
-                result.extend_from_slice(&(*pos as u64).to_le_bytes());
-            }
-            Selector::Key(key) => {
-                result.extend_from_slice(&(key.len() as u32).to_le_bytes());
-                result.extend_from_slice(key);
-            }
-            Selector::Predicate(data) => {
-                result.extend_from_slice(&(data.len() as u32).to_le_bytes());
-                result.extend_from_slice(data);
-            }
-            Selector::None => {} // No additional data
-        }
-
-        // Serialize auxiliary data
-        result.extend_from_slice(&(self.auxiliary_data.len() as u32).to_le_bytes());
-        result.extend_from_slice(&self.auxiliary_data);
-
-        Ok(result)
-    }
-
-    /// Create from bytes
-    pub fn from_bytes(_bytes: &[u8]) -> HomomorphicResult<Self>
-    where
-        CS::Commitment: From<Vec<u8>>,
-    {
-        // This would be a complete deserialization implementation
-        // For now, we'll just return an error
-        Err(HomomorphicError::Custom(
-            "Deserialization not implemented".to_string(),
-        ))
-    }
-}
-
-/// Generator for homomorphic proofs
-pub struct ProofGenerator<CS: HomomorphicCommitmentScheme> {
-    /// Commitment scheme
-    scheme: CS,
-}
-
-impl<CS: HomomorphicCommitmentScheme> ProofGenerator<CS> {
-    /// Create a new proof generator
-    pub fn new(scheme: CS) -> Self {
-        Self { scheme }
-    }
-
-    /// Generate a proof for an add operation
-    pub fn prove_add(
-        &self,
-        a: &CS::Commitment,
-        b: &CS::Commitment,
-        result: &CS::Commitment,
-        selector: &Selector,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        // Verify that result = a + b
-        let computed_result = self.scheme.add(a, b)?;
-
-        // Check that the computed result matches the provided result
-        if computed_result.as_ref() != result.as_ref() {
-            return Err(HomomorphicError::VerificationFailure);
-        }
-
-        // Create the proof with the specified selector
-        Ok(HomomorphicProof::new(
-            HomomorphicOperation::Addition,
-            vec![a.clone(), b.clone()],
-            result.clone(),
-            selector.clone(),
-            Vec::new(), // No auxiliary data needed for addition
-        ))
-    }
-
-    /// Generate a proof for a scalar multiply operation
-    pub fn prove_scalar_multiply(
-        &self,
-        a: &CS::Commitment,
-        scalar: i32,
-        result: &CS::Commitment,
-        selector: &Selector,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        if scalar <= 0 {
-            return Err(HomomorphicError::NegativeScalar);
-        }
-
-        // Verify that result = a * scalar
-        let computed_result = self.scheme.scalar_multiply(a, scalar)?;
-
-        // Check that the computed result matches the provided result
-        if computed_result.as_ref() != result.as_ref() {
-            return Err(HomomorphicError::VerificationFailure);
-        }
-
-        // Create the proof with scalar in auxiliary data
-        let mut auxiliary_data = Vec::new();
-        auxiliary_data.extend_from_slice(&scalar.to_le_bytes());
-
-        Ok(HomomorphicProof::new(
-            HomomorphicOperation::ScalarMultiplication,
-            vec![a.clone()],
-            result.clone(),
-            selector.clone(),
-            auxiliary_data,
-        ))
-    }
-
-    /// Generate a proof for an operation
-    pub fn prove_operation(
-        &self,
-        operation: &CommitmentOperation,
-        result: &CS::Commitment,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        // Default to None selector for backward compatibility
-        self.prove_operation_with_selector(operation, result, &Selector::None)
-    }
-
-    /// Generate a proof for an operation with a specific selector
-    pub fn prove_operation_with_selector(
-        &self,
-        operation: &CommitmentOperation,
-        result: &CS::Commitment,
-        selector: &Selector,
-    ) -> HomomorphicResult<HomomorphicProof<CS>> {
-        match operation {
-            CommitmentOperation::Add { left, right } => {
-                // Downcast inputs
-                let a = left.downcast_ref::<CS::Commitment>().ok_or_else(|| {
-                    HomomorphicError::InvalidInput(
-                        "Left operand is not the correct commitment type".into(),
-                    )
-                })?;
-                let b = right.downcast_ref::<CS::Commitment>().ok_or_else(|| {
-                    HomomorphicError::InvalidInput(
-                        "Right operand is not the correct commitment type".into(),
-                    )
-                })?;
-
-                self.prove_add(a, b, result, selector)
-            }
-            CommitmentOperation::ScalarMultiply { commitment, scalar } => {
-                // Downcast input
-                let a = commitment.downcast_ref::<CS::Commitment>().ok_or_else(|| {
-                    HomomorphicError::InvalidInput("Commitment is not the correct type".into())
-                })?;
-
-                self.prove_scalar_multiply(a, *scalar, result, selector)
-            }
-            CommitmentOperation::Custom { .. } => Err(HomomorphicError::UnsupportedOperation(
-                HomomorphicOperation::Custom(0),
-            )),
-        }
-    }
-
-    /// Verify a homomorphic proof
-    pub fn verify_proof(&self, proof: &HomomorphicProof<CS>) -> HomomorphicResult<bool> {
-        // Use default empty context for backward compatibility
-        self.verify_proof_with_context(proof, &ProofContext::default())
-    }
-
-    /// Verify a homomorphic proof with context
-    pub fn verify_proof_with_context(
-        &self,
-        proof: &HomomorphicProof<CS>,
-        context: &ProofContext,
-    ) -> HomomorphicResult<bool> {
-        match proof.operation_type() {
-            HomomorphicOperation::Addition => {
-                if proof.inputs().len() != 2 {
-                    return Err(HomomorphicError::InvalidInput(
-                        "Addition proof requires exactly 2 inputs".into(),
-                    ));
-                }
-
-                let a = &proof.inputs()[0];
-                let b = &proof.inputs()[1];
-
-                // Compute a + b
-                let computed_result = self.scheme.add(a, b)?;
-
-                // Check that computed result matches the proof result
-                Ok(computed_result.as_ref() == proof.result().as_ref())
-            }
-            HomomorphicOperation::ScalarMultiplication => {
-                if proof.inputs().len() != 1 {
-                    return Err(HomomorphicError::InvalidInput(
-                        "Scalar multiplication proof requires exactly 1 input".into(),
-                    ));
-                }
-
-                let a = &proof.inputs()[0];
-
-                // Extract scalar from auxiliary data
-                if proof.auxiliary_data().len() < 4 {
-                    return Err(HomomorphicError::InvalidInput(
-                        "Invalid auxiliary data for scalar multiplication".into(),
-                    ));
-                }
-
-                let mut scalar_bytes = [0u8; 4];
-                scalar_bytes.copy_from_slice(&proof.auxiliary_data()[0..4]);
-                let scalar = i32::from_le_bytes(scalar_bytes);
-
-                if scalar <= 0 {
-                    return Err(HomomorphicError::NegativeScalar);
-                }
-
-                // Check the context for any additional verification parameters
-                if let Some(precision_data) = context.get_data("precision") {
-                    if !precision_data.is_empty() {
-                        // Use precision parameter if provided
-                        // This is just an example of how context might be used
-                        let precision = precision_data[0];
-                        if precision > 0 {
-                            // High precision verification logic would go here
-                        }
-                    }
-                }
-
-                // Compute a * scalar
-                let computed_result = self.scheme.scalar_multiply(a, scalar)?;
-
-                // Check that computed result matches the proof result
-                Ok(computed_result.as_ref() == proof.result().as_ref())
-            }
-            HomomorphicOperation::Custom(_) => Err(HomomorphicError::UnsupportedOperation(
-                proof.operation_type(),
-            )),
-        }
-    }
-}```
-
-##### File: homomorphic/Cargo.toml
-##*Size: 4.0K, Lines: 16, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-homomorphic"
-version = "0.1.0"
-edition = "2021"
-description = "Homomorphic operations implementation for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-depin-sdk-commitment-schemes = { path = "../commitment_schemes" }
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-
-[features]
-default = []
-```
-
-#### Directory: services
-
-##### Directory: services/src
-
-###### Directory: services/src/external_data
-
-####### File: services/src/external_data/mod.rs
-####*Size: 4.0K, Lines: 12, Type: ASCII text*
-
-```rust
-//! External data module implementation
-
-use depin_sdk_core::services::{BlockchainService, ServiceType};
-
-pub struct ExternalDataService {
-    // Add your implementation fields here
-}
-
-impl BlockchainService for ExternalDataService {
-    fn service_type(&self) -> ServiceType {
-        ServiceType::ExternalData
-    }
-}```
-
-###### Directory: services/src/governance
-
-####### File: services/src/governance/mod.rs
-####*Size: 4.0K, Lines: 156, Type: ASCII text*
-
-```rust
-//! Governance module implementations for the DePIN SDK
-
-use std::time::Duration;
-
-/// Governance proposal type
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum ProposalType {
-    /// Parameter change proposal
-    ParameterChange,
-    /// Software upgrade proposal
-    SoftwareUpgrade,
-    /// Text proposal
-    Text,
-    /// Custom proposal type
-    Custom(String),
-}
-
-/// Governance vote option
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum VoteOption {
-    /// Yes vote
-    Yes,
-    /// No vote
-    No,
-    /// No with veto vote
-    NoWithVeto,
-    /// Abstain vote
-    Abstain,
-}
-
-/// Governance parameters
-#[derive(Debug, Clone)]
-pub struct GovernanceParams {
-    /// Minimum deposit to submit a proposal
-    pub min_deposit: u64,
-    /// Maximum deposit period
-    pub max_deposit_period: Duration,
-    /// Voting period
-    pub voting_period: Duration,
-    /// Quorum percentage (0-100)
-    pub quorum: u8,
-    /// Threshold percentage (0-100)
-    pub threshold: u8,
-    /// Veto threshold percentage (0-100)
-    pub veto_threshold: u8,
-}
-
-impl Default for GovernanceParams {
-    fn default() -> Self {
-        Self {
-            min_deposit: 10000,
-            max_deposit_period: Duration::from_secs(60 * 60 * 24 * 14), // 14 days
-            voting_period: Duration::from_secs(60 * 60 * 24 * 14),      // 14 days
-            quorum: 33,                                                 // 33%
-            threshold: 50,                                              // 50%
-            veto_threshold: 33,                                         // 33%
-        }
-    }
-}
-
-/// Governance module
-pub struct GovernanceModule {
-    /// Governance parameters
-    params: GovernanceParams,
-}
-
-impl GovernanceModule {
-    /// Create a new governance module
-    pub fn new(params: GovernanceParams) -> Self {
-        Self { params }
-    }
-
-    /// Create a new governance module with default parameters
-    pub fn default() -> Self {
-        Self {
-            params: GovernanceParams::default(),
-        }
-    }
-
-    /// Get the governance parameters
-    pub fn params(&self) -> &GovernanceParams {
-        &self.params
-    }
-
-    /// Submit a proposal
-    pub fn submit_proposal(
-        &self,
-        _proposal_type: ProposalType,
-        _title: &str,
-        _description: &str,
-        _proposer: &[u8],
-        _deposit: u64,
-    ) -> Result<u64, String> {
-        // In a real implementation, this would create and store a proposal
-        // For now, just return a dummy proposal ID
-        Ok(1)
-    }
-
-    /// Vote on a proposal
-    pub fn vote(
-        &self,
-        _proposal_id: u64,
-        _voter: &[u8],
-        _option: VoteOption,
-    ) -> Result<(), String> {
-        // In a real implementation, this would record a vote
-        Ok(())
-    }
-
-    /// Get proposal status
-    pub fn get_proposal_status(&self, _proposal_id: u64) -> Result<String, String> {
-        // In a real implementation, this would fetch the proposal status
-        Ok("Voting".to_string())
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_governance_params_default() {
-        let params = GovernanceParams::default();
-        assert_eq!(params.min_deposit, 10000);
-        assert_eq!(params.quorum, 33);
-        assert_eq!(params.threshold, 50);
-        assert_eq!(params.veto_threshold, 33);
-    }
-
-    #[test]
-    fn test_governance_module() {
-        let module = GovernanceModule::default();
-
-        // Test proposal submission
-        let proposal_id = module
-            .submit_proposal(
-                ProposalType::Text,
-                "Test Proposal",
-                "This is a test proposal",
-                &[1, 2, 3, 4],
-                10000,
-            )
-            .unwrap();
-
-        assert_eq!(proposal_id, 1);
-
-        // Test voting
-        module
-            .vote(proposal_id, &[1, 2, 3, 4], VoteOption::Yes)
-            .unwrap();
-
-        // Test status query
-        let status = module.get_proposal_status(proposal_id).unwrap();
-        assert_eq!(status, "Voting");
-    }
-}
-```
-
-###### Directory: services/src/ibc
-
-####### Directory: services/src/ibc/src
-
-######## Directory: services/src/ibc/src/conversion
-
-######### File: services/src/ibc/src/conversion/mod.rs
-######*Size: 4.0K, Lines: 21, Type: ASCII text*
-
-```rust
-//! Value conversion utilities for IBC module
-/// Trait for types that can be converted from/to bytes
-/// This unifies the previously separate ValueConversion and FromBytes traits
-pub trait ByteConvertible: Sized {
-    /// Convert from bytes to this type
-    fn from_bytes(bytes: &[u8]) -> Option<Self>;
-
-    /// Convert this type to bytes
-    fn to_bytes(&self) -> Vec<u8>;
-}
-
-// Implement for Vec<u8> which is the most common value type
-impl ByteConvertible for Vec<u8> {
-    fn from_bytes(bytes: &[u8]) -> Option<Self> {
-        Some(bytes.to_vec())
-    }
-
-    fn to_bytes(&self) -> Vec<u8> {
-        self.clone()
-    }
-}
-```
-
-######## Directory: services/src/ibc/src/light_client
-
-######### Directory: services/src/ibc/src/light_client/tests
-
-######### File: services/src/ibc/src/light_client/mod.rs
-######*Size: 12K, Lines: 341, Type: C source, ASCII text*
-
-```rust
-//! IBC light client implementations
-
-use crate::conversion::ByteConvertible;
-use crate::translation::ProofTranslatorRegistry;
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::ibc::{LightClient, UniversalProofFormat};
-use std::any::Any;
-use std::collections::HashMap;
-
-/// Type-erased commitment scheme wrapper that avoids dynamic dispatch limitations
-struct SchemeWrapper {
-    /// The actual scheme (boxed as Any)
-    inner: Box<dyn Any + Send + Sync>,
-    /// Function pointer for commit operation
-    commit_fn: fn(&dyn Any, &[Option<Vec<u8>>]) -> Box<dyn AsRef<[u8]> + Send + Sync>,
-    /// Function pointer for create_proof operation
-    create_proof_fn: fn(&dyn Any, &Selector, &[u8]) -> Result<Box<dyn Any + Send + Sync>, String>,
-    /// Function pointer for verify operation
-    verify_fn: fn(&dyn Any, &dyn Any, &dyn Any, &Selector, &[u8], &ProofContext) -> bool,
-    /// Scheme identifier
-    id: String,
-}
-
-/// Universal light client that can verify proofs from multiple commitment schemes
-pub struct UniversalLightClient {
-    /// Supported scheme implementations
-    schemes: HashMap<String, SchemeWrapper>,
-    /// Translator registry
-    translators: ProofTranslatorRegistry,
-    /// Default scheme to use
-    default_scheme: Option<String>,
-}
-
-impl UniversalLightClient {
-    /// Create a new universal light client
-    pub fn new() -> Self {
-        Self {
-            schemes: HashMap::new(),
-            translators: ProofTranslatorRegistry::new(),
-            default_scheme: None,
-        }
-    }
-
-    /// Register a commitment scheme
-    pub fn register_scheme<C>(&mut self, scheme_id: &str, scheme: C)
-    where
-        C: CommitmentScheme + 'static,
-        C::Value: ByteConvertible + AsRef<[u8]>, // Using unified trait
-    {
-        // Create type-erased wrapper functions
-        let commit_fn = |any_scheme: &dyn Any,
-                         values: &[Option<Vec<u8>>]|
-         -> Box<dyn AsRef<[u8]> + Send + Sync> {
-            let scheme = any_scheme.downcast_ref::<C>().unwrap();
-            // Convert Vec<u8> to C::Value using ByteConvertible trait
-            let typed_values: Vec<Option<C::Value>> = values
-                .iter()
-                .map(|v| v.as_ref().and_then(|bytes| C::Value::from_bytes(bytes)))
-                .collect();
-
-            let commitment = scheme.commit(&typed_values);
-            Box::new(commitment)
-        };
-
-        let create_proof_fn = |any_scheme: &dyn Any,
-                               selector: &Selector,
-                               value: &[u8]|
-         -> Result<Box<dyn Any + Send + Sync>, String> {
-            let scheme = any_scheme.downcast_ref::<C>().unwrap();
-            // Convert value to C::Value using ByteConvertible trait
-            if let Some(typed_value) = C::Value::from_bytes(value) {
-                scheme
-                    .create_proof(selector, &typed_value)
-                    .map(|proof| Box::new(proof) as Box<dyn Any + Send + Sync>)
-            } else {
-                Err(format!(
-                    "Failed to convert {} bytes to the expected format",
-                    value.len()
-                ))
-            }
-        };
-
-        let verify_fn = |any_scheme: &dyn Any,
-                         any_commitment: &dyn Any,
-                         any_proof: &dyn Any,
-                         selector: &Selector,
-                         value: &[u8],
-                         context: &ProofContext|
-         -> bool {
-            if let Some(scheme) = any_scheme.downcast_ref::<C>() {
-                if let Some(commitment) = any_commitment.downcast_ref::<C::Commitment>() {
-                    if let Some(proof) = any_proof.downcast_ref::<C::Proof>() {
-                        // Convert value to C::Value
-                        if let Some(typed_value) = C::Value::from_bytes(value) {
-                            return scheme.verify(
-                                commitment,
-                                proof,
-                                selector,
-                                &typed_value,
-                                context,
-                            );
-                        }
-                    }
-                }
-            }
-            false
-        };
-
-        let wrapper = SchemeWrapper {
-            inner: Box::new(scheme),
-            commit_fn,
-            create_proof_fn,
-            verify_fn,
-            id: scheme_id.to_string(),
-        };
-
-        self.schemes.insert(scheme_id.to_string(), wrapper);
-        if self.default_scheme.is_none() {
-            self.default_scheme = Some(scheme_id.to_string());
-        }
-    }
-
-    /// Set the default scheme
-    pub fn set_default_scheme(&mut self, scheme_id: &str) -> Result<(), String> {
-        if self.schemes.contains_key(scheme_id) {
-            self.default_scheme = Some(scheme_id.to_string());
-            Ok(())
-        } else {
-            Err(format!("Scheme '{}' not registered", scheme_id))
-        }
-    }
-
-    /// Register a proof translator
-    pub fn register_translator(
-        &mut self,
-        translator: Box<dyn depin_sdk_core::ibc::ProofTranslator>,
-    ) {
-        self.translators.register(translator);
-    }
-
-    /// Get supported schemes
-    pub fn supported_schemes(&self) -> Vec<String> {
-        self.schemes.keys().cloned().collect()
-    }
-
-    /// Helper method to convert native proof bytes to a proof object
-    fn deserialize_proof(
-        &self,
-        scheme_id: &str,
-        proof_bytes: &[u8],
-    ) -> Option<Box<dyn Any + Send + Sync>> {
-        // In a real implementation, this would deserialize from the proper format
-        // based on the scheme's expected proof format
-        let _scheme = self.schemes.get(scheme_id)?;
-
-        // Log the deserialization attempt for debugging
-        log::debug!(
-            "Deserializing proof for scheme {}, {} bytes",
-            scheme_id,
-            proof_bytes.len()
-        );
-
-        // Simply wrap the bytes for now
-        // In a real implementation, you'd have scheme-specific deserialization
-        Some(Box::new(proof_bytes.to_vec()))
-    }
-
-    /// Helper method to extract selector from proof bytes
-    fn extract_selector_from_proof(
-        &self,
-        scheme_id: &str,
-        _proof_bytes: &[u8],
-        fallback_key: &[u8],
-    ) -> Selector {
-        // In a real implementation, this would extract the selector information
-        // from the proof bytes based on the scheme's format
-
-        // Log the extraction attempt
-        log::debug!(
-            "Extracting selector for scheme {}, fallback key: {} bytes",
-            scheme_id,
-            fallback_key.len()
-        );
-
-        // For now, return a key-based selector as a default
-        Selector::Key(fallback_key.to_vec())
-    }
-}
-
-impl LightClient for UniversalLightClient {
-    fn verify_native_proof(
-        &self,
-        commitment: &[u8],
-        proof: &[u8],
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        // Create a default context for internal use
-        let context = ProofContext::default();
-
-        // Use the default scheme if available
-        if let Some(scheme_id) = &self.default_scheme {
-            if let Some(scheme) = self.schemes.get(scheme_id) {
-                // Extract selector from proof (or use key selector as fallback)
-                let selector = self.extract_selector_from_proof(scheme_id, proof, key);
-
-                // Deserialize proof data
-                if let Some(deserialized_proof) = self.deserialize_proof(scheme_id, proof) {
-                    // Attempt to verify with the scheme
-                    // We use the type-erased function to avoid dynamic dispatch limitations
-                    let result = (scheme.verify_fn)(
-                        scheme.inner.as_ref(),
-                        &commitment.to_vec(), // Simple wrapper for commitment bytes
-                        deserialized_proof.as_ref(),
-                        &selector,
-                        value,
-                        &context,
-                    );
-
-                    // Log the verification result
-                    log::debug!(
-                        "Native proof verification result: {}, scheme: {}",
-                        result,
-                        scheme_id
-                    );
-
-                    return result;
-                }
-            }
-        }
-
-        log::warn!("Native proof verification failed, no suitable scheme found");
-        false
-    }
-
-    fn verify_universal_proof(
-        &self,
-        commitment: &[u8],
-        proof: &UniversalProofFormat,
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        let scheme_id = &proof.scheme_id.0;
-
-        // Log received proof information
-        log::debug!(
-            "Verifying universal proof: scheme={}, key={} bytes, provided_key={} bytes",
-            scheme_id,
-            proof.key.len(),
-            key.len()
-        );
-
-        // Create a context from the proof metadata
-        let mut combined_context = ProofContext::new();
-
-        // Migrate metadata from core proof to our context
-        for (key, value) in &proof.metadata {
-            combined_context.add_data(key, value.clone());
-        }
-
-        // Determine which key to use - prefer proof's key if present, otherwise use provided key
-        let key_to_use = if !proof.key.is_empty() {
-            &proof.key
-        } else {
-            key
-        };
-
-        // Create selector based on the key
-        let selector = Selector::Key(key_to_use.to_vec());
-
-        // Log the key decision
-        log::debug!(
-            "Using {} for verification: {} bytes",
-            if key_to_use.as_ptr() == proof.key.as_ptr() {
-                "proof key"
-            } else {
-                "provided key"
-            },
-            key_to_use.len()
-        );
-
-        // If we support this scheme directly, use it
-        if let Some(scheme) = self.schemes.get(scheme_id) {
-            // Deserialize the proof data
-            if let Some(deserialized_proof) = self.deserialize_proof(scheme_id, &proof.proof_data) {
-                // Verify using the scheme
-                let result = (scheme.verify_fn)(
-                    scheme.inner.as_ref(),
-                    &commitment.to_vec(), // Simple wrapper for commitment bytes
-                    deserialized_proof.as_ref(),
-                    &selector,
-                    value,
-                    &combined_context,
-                );
-
-                // Log direct verification result
-                log::debug!("Direct verification result: {}", result);
-
-                return result;
-            }
-        }
-
-        // If we don't support this scheme directly, try to translate it
-        if let Some(default_id) = &self.default_scheme {
-            log::debug!("Attempting translation to scheme: {}", default_id);
-
-            // Attempt to translate the proof to our default scheme
-            if let Some(translated_proof) = self.translators.translate_universal(default_id, proof)
-            {
-                if let Some(scheme) = self.schemes.get(default_id) {
-                    // Verify using the translated proof
-                    let result = (scheme.verify_fn)(
-                        scheme.inner.as_ref(),
-                        &commitment.to_vec(), // Simple wrapper for commitment bytes
-                        translated_proof.as_ref(),
-                        &selector,
-                        value,
-                        &combined_context,
-                    );
-
-                    // Log translation verification result
-                    log::debug!("Translation verification result: {}", result);
-
-                    return result;
-                }
-            } else {
-                log::warn!("Failed to translate proof to scheme: {}", default_id);
-            }
-        }
-
-        log::warn!(
-            "Universal proof verification failed for scheme: {}",
-            scheme_id
-        );
-        false
-    }
-
-    fn supported_schemes(&self) -> Vec<String> {
-        self.schemes.keys().cloned().collect()
-    }
-}
-```
-
-######## Directory: services/src/ibc/src/proof
-
-######### Directory: services/src/ibc/src/proof/tests
-
-######### File: services/src/ibc/src/proof/formats.rs
-######*Size: 4.0K, Lines: 82, Type: ASCII text*
-
-```rust
-// File: crates/ibc/src/proof/formats.rs
-
-use depin_sdk_core::commitment::{ProofContext, Selector};
-use depin_sdk_core::ibc::UniversalProofFormat as CoreProofFormat;
-use std::collections::HashMap;
-
-use crate::proof::UniversalProofFormat as LocalProofFormat;
-
-/// Helper for converting between proof formats
-pub struct ProofFormatConverter;
-
-impl ProofFormatConverter {
-    /// Convert from core to local proof format
-    pub fn core_to_local(core: &CoreProofFormat) -> LocalProofFormat {
-        // Extract selector from key
-        let selector = if core.key.is_empty() {
-            Selector::None
-        } else {
-            Selector::Key(core.key.clone())
-        };
-
-        // Create local proof format
-        let mut local = LocalProofFormat::new(
-            core.scheme_id.clone(),
-            core.proof_data.clone(),
-            selector,
-            core.value.clone(),
-        );
-
-        // Copy metadata
-        for (key, value) in &core.metadata {
-            local.add_metadata(key, value.clone());
-        }
-
-        local
-    }
-
-    /// Convert from local to core proof format
-    pub fn local_to_core(local: &LocalProofFormat) -> CoreProofFormat {
-        // Extract key from selector if available
-        let key = match &local.selector {
-            Selector::Key(k) => k.clone(),
-            _ => local.key.clone(), // Fall back to explicit key field
-        };
-
-        // Create core proof format
-        let mut core = CoreProofFormat {
-            scheme_id: local.scheme_id.clone(),
-            format_version: local.format_version,
-            proof_data: local.proof_data.clone(),
-            metadata: HashMap::new(),
-            key, // Using key directly
-            value: local.value.clone(),
-        };
-
-        // Copy metadata
-        for (key, value) in &local.metadata {
-            core.metadata.insert(key.clone(), value.clone());
-        }
-
-        core
-    }
-
-    /// Create a combined context from proof and additional context
-    pub fn create_combined_context(
-        proof: &LocalProofFormat,
-        additional: Option<&ProofContext>,
-    ) -> ProofContext {
-        let mut combined = proof.context.clone();
-
-        // Add additional context data if provided
-        if let Some(additional_ctx) = additional {
-            for (key, value) in &additional_ctx.data {
-                // Only add if not already present
-                if !combined.data.contains_key(key) {
-                    combined.add_data(key, value.clone());
-                }
-            }
-        }
-
-        combined
-    }
-}```
-
-######### File: services/src/ibc/src/proof/mod.rs
-######*Size: 8.0K, Lines: 194, Type: ASCII text*
-
-```rust
-//! Definition of the UniversalProofFormat
-//! 
-use depin_sdk_core::commitment::{ProofContext, SchemeIdentifier, Selector};
-use std::collections::HashMap;
-
-// Explicitly declare the formats module
-pub mod formats;
-use formats::ProofFormatConverter;
-
-/// Universal proof format that can represent any commitment scheme's proof
-#[derive(Debug, Clone)]
-pub struct UniversalProofFormat {
-    /// Identifier of the commitment scheme that created this proof
-    pub scheme_id: SchemeIdentifier,
-
-    /// Version of the proof format
-    pub format_version: u8,
-
-    /// The serialized proof data
-    pub proof_data: Vec<u8>,
-
-    /// Additional metadata for the proof
-    pub metadata: HashMap<String, Vec<u8>>,
-
-    /// Selector that this proof is for
-    pub selector: Selector,
-
-    /// Key that this proof is for (backward compatibility)
-    pub key: Vec<u8>,
-
-    /// Value this proof is proving (if known)
-    pub value: Option<Vec<u8>>,
-
-    /// Verification context
-    pub context: ProofContext,
-}
-
-impl UniversalProofFormat {
-    /// Create a new universal proof format
-    pub fn new(
-        scheme_id: SchemeIdentifier,
-        proof_data: Vec<u8>,
-        selector: Selector,
-        value: Option<Vec<u8>>,
-    ) -> Self {
-        // For backward compatibility, extract a key from the selector if possible
-        let key = match &selector {
-            Selector::Key(k) => k.clone(),
-            _ => Vec::new(),
-        };
-
-        Self {
-            scheme_id,
-            format_version: 1,
-            proof_data,
-            metadata: HashMap::new(),
-            selector,
-            key,
-            value,
-            context: ProofContext::default(),
-        }
-    }
-
-    /// Add metadata to the proof
-    pub fn add_metadata(&mut self, key: &str, value: Vec<u8>) {
-        self.metadata.insert(key.to_string(), value);
-    }
-
-    /// Get metadata from the proof
-    pub fn get_metadata(&self, key: &str) -> Option<&Vec<u8>> {
-        self.metadata.get(key)
-    }
-
-    /// Add context data
-    pub fn add_context_data(&mut self, key: &str, value: Vec<u8>) {
-        self.context.add_data(key, value);
-    }
-
-    /// Get context data
-    pub fn get_context_data(&self, key: &str) -> Option<&Vec<u8>> {
-        self.context.get_data(key)
-    }
-
-    /// Create a new proof with a position-based selector
-    pub fn with_position(
-        scheme_id: SchemeIdentifier,
-        proof_data: Vec<u8>,
-        position: usize,
-        value: Option<Vec<u8>>,
-    ) -> Self {
-        Self::new(scheme_id, proof_data, Selector::Position(position), value)
-    }
-
-    /// Create a new proof with a key-based selector
-    pub fn with_key(
-        scheme_id: SchemeIdentifier,
-        proof_data: Vec<u8>,
-        key: Vec<u8>,
-        value: Option<Vec<u8>>,
-    ) -> Self {
-        Self::new(scheme_id, proof_data, Selector::Key(key), value)
-    }
-
-    /// Create a new proof with a predicate-based selector
-    pub fn with_predicate(
-        scheme_id: SchemeIdentifier,
-        proof_data: Vec<u8>,
-        predicate: Vec<u8>,
-        value: Option<Vec<u8>>,
-    ) -> Self {
-        Self::new(scheme_id, proof_data, Selector::Predicate(predicate), value)
-    }
-
-    /// Create a new proof with no selector
-    pub fn with_no_selector(
-        scheme_id: SchemeIdentifier,
-        proof_data: Vec<u8>,
-        value: Option<Vec<u8>>,
-    ) -> Self {
-        Self::new(scheme_id, proof_data, Selector::None, value)
-    }
-}
-
-/// Helper functions for working with UniversalProofFormat
-pub struct IBCProofUtils;
-
-impl IBCProofUtils {
-    /// Create a new universal proof format
-    pub fn create_universal_proof(
-        scheme_id: &str,
-        proof_data: Vec<u8>,
-        selector: Selector,
-        value: Option<Vec<u8>>,
-    ) -> UniversalProofFormat {
-        UniversalProofFormat::new(
-            SchemeIdentifier::new(scheme_id),
-            proof_data,
-            selector,
-            value,
-        )
-    }
-
-    /// Get scheme ID from a universal proof
-    pub fn get_scheme_id(proof: &UniversalProofFormat) -> &str {
-        &proof.scheme_id.0
-    }
-
-    /// Get proof data from a universal proof
-    pub fn get_proof_data(proof: &UniversalProofFormat) -> &[u8] {
-        &proof.proof_data
-    }
-
-    /// Get selector from a universal proof
-    pub fn get_selector(proof: &UniversalProofFormat) -> &Selector {
-        &proof.selector
-    }
-
-    /// Get key from a universal proof
-    pub fn get_key(proof: &UniversalProofFormat) -> &[u8] {
-        &proof.key
-    }
-
-    /// Get value from a universal proof
-    ///
-    /// This function returns a borrowed slice of the value stored in the proof,
-    /// if it exists. The lifetime of the returned slice is bound to the lifetime
-    /// of the input `proof`.
-    pub fn get_value<'a>(proof: &'a UniversalProofFormat) -> Option<&'a [u8]> {
-        proof.value.as_ref().map(|v| v.as_slice())
-    }
-
-    /// Add metadata to a universal proof
-    pub fn add_metadata(proof: &mut UniversalProofFormat, key: &str, value: Vec<u8>) {
-        proof.add_metadata(key, value);
-    }
-
-    /// Get metadata from a universal proof
-    pub fn get_metadata<'a>(proof: &'a UniversalProofFormat, key: &str) -> Option<&'a Vec<u8>> {
-        proof.get_metadata(key)
-    }
-
-    /// Add context data to a universal proof
-    pub fn add_context_data(proof: &mut UniversalProofFormat, key: &str, value: Vec<u8>) {
-        proof.add_context_data(key, value);
-    }
-
-    /// Get context data from a universal proof
-    pub fn get_context_data<'a>(proof: &'a UniversalProofFormat, key: &str) -> Option<&'a Vec<u8>> {
-        proof.get_context_data(key)
-    }
-}
-
-/// Serialization utilities for proofs (snipped for brevity)
-pub struct ProofSerialization;
-// Implement serialization methods here...```
-
-######### File: services/src/ibc/src/proof/mod.rs:8:5
-######*Size: 0, Lines: 0, Type: empty*
-
-######*File content not included (exceeds threshold or non-text file)*
-
-######## Directory: services/src/ibc/src/translation
-
-######### Directory: services/src/ibc/src/translation/tests
-
-######### File: services/src/ibc/src/translation/generic.rs
-######*Size: 4.0K, Lines: 115, Type: ASCII text*
-
-```rust
-//! Generic proof translator implementation
-
-use std::any::Any;
-use std::marker::PhantomData;
-
-use crate::conversion::ByteConvertible;
-use depin_sdk_core::commitment::{CommitmentScheme, SchemeIdentifier, Selector};
-use depin_sdk_core::ibc::{ProofTranslator, UniversalProofFormat};
-use std::collections::HashMap;
-
-/// Generic proof translator between two commitment schemes
-pub struct GenericProofTranslator<S, T>
-where
-    S: CommitmentScheme,
-    T: CommitmentScheme,
-{
-    /// Source scheme
-    source_scheme: S,
-    /// Source scheme ID
-    source_id: SchemeIdentifier,
-    /// Target scheme
-    target_scheme: T,
-    /// Target scheme ID
-    target_id: SchemeIdentifier,
-    /// Phantom marker
-    _phantom: PhantomData<(S, T)>,
-}
-
-impl<S, T> GenericProofTranslator<S, T>
-where
-    S: CommitmentScheme,
-    T: CommitmentScheme,
-{
-    /// Create a new generic proof translator
-    pub fn new(
-        source_scheme: S,
-        source_id: SchemeIdentifier,
-        target_scheme: T,
-        target_id: SchemeIdentifier,
-    ) -> Self {
-        Self {
-            source_scheme,
-            source_id,
-            target_scheme,
-            target_id,
-            _phantom: PhantomData,
-        }
-    }
-}
-
-impl<S, T> ProofTranslator for GenericProofTranslator<S, T>
-where
-    S: CommitmentScheme,
-    T: CommitmentScheme,
-    T::Value: ByteConvertible,
-{
-    fn source_scheme(&self) -> SchemeIdentifier {
-        self.source_id.clone()
-    }
-
-    fn target_scheme(&self) -> SchemeIdentifier {
-        self.target_id.clone()
-    }
-
-    fn to_universal(
-        &self,
-        proof: &dyn Any,
-        key: &[u8],
-        value: Option<&[u8]>,
-    ) -> Option<UniversalProofFormat> {
-        // Try to downcast the proof to source scheme's proof type
-        let source_proof = proof.downcast_ref::<S::Proof>()?;
-
-        // Create universal proof format with scheme ID, key, and value
-        Some(UniversalProofFormat {
-            scheme_id: self.source_id.clone(),
-            proof_data: vec![0; 32], // Placeholder - in real code we'd properly serialize
-            metadata: HashMap::new(),
-            key: key.to_vec(),
-            value: value.map(|v| v.to_vec()),
-        })
-    }
-
-    fn from_universal(&self, universal: &UniversalProofFormat) -> Option<Box<dyn Any>> {
-        // Verify scheme ID matches
-        if universal.scheme_id != self.source_id {
-            log::warn!(
-                "Scheme ID mismatch: expected {}, got {}",
-                self.source_id.0,
-                universal.scheme_id.0
-            );
-            return None;
-        }
-
-        // Convert the value to the target scheme's Value type if it exists
-        let value_bytes = universal.value.as_ref()?;
-        let target_value = T::Value::from_bytes(value_bytes)?;
-
-        // Create a proof in the target scheme using a key selector
-        let selector = if universal.key.is_empty() {
-            log::warn!("Empty key in universal proof");
-            None
-        } else {
-            Some(Selector::Key(universal.key.clone()))
-        }?;
-
-        // In a real implementation, we would properly deserialize and convert the proof
-        match self.target_scheme.create_proof(&selector, &target_value) {
-            Ok(target_proof) => Some(Box::new(target_proof)),
-            Err(err) => {
-                log::error!("Failed to create target proof: {}", err);
-                None
-            }
-        }
-    }
-}```
-
-######### File: services/src/ibc/src/translation/mod.rs
-######*Size: 8.0K, Lines: 182, Type: ASCII text*
-
-```rust
-//! IBC proof translation between different commitment schemes
-
-use std::any::Any;
-use std::collections::HashMap;
-
-use crate::conversion::ByteConvertible;
-use crate::proof::formats::ProofFormatConverter;
-use crate::proof::UniversalProofFormat as LocalProofFormat;
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
-use depin_sdk_core::ibc::{ProofTranslator, UniversalProofFormat as CoreProofFormat};
-
-/// Registry for proof translators
-pub struct ProofTranslatorRegistry {
-    /// Map from (source, target) scheme IDs to translator instances
-    translators: HashMap<(String, String), Box<dyn ProofTranslator>>,
-}
-
-impl ProofTranslatorRegistry {
-    /// Create a new proof translator registry
-    pub fn new() -> Self {
-        Self {
-            translators: HashMap::new(),
-        }
-    }
-
-    /// Register a proof translator
-    pub fn register(&mut self, translator: Box<dyn ProofTranslator>) {
-        let source = translator.source_scheme().0.clone();
-        let target = translator.target_scheme().0.clone();
-        self.translators.insert((source, target), translator);
-    }
-
-    /// Get a proof translator
-    pub fn get(&self, source: &str, target: &str) -> Option<&dyn ProofTranslator> {
-        self.translators
-            .get(&(source.to_string(), target.to_string()))
-            .map(|t| t.as_ref())
-    }
-
-    /// Translate a proof between schemes
-    pub fn translate(
-        &self,
-        source: &str,
-        target: &str,
-        proof: &dyn Any,
-        key: &[u8],
-        value: Option<&[u8]>,
-    ) -> Option<Box<dyn Any>> {
-        // Get the translator and perform translation
-        let translator = self.get(source, target)?;
-
-        // Log translation attempt
-        log::debug!(
-            "Translating proof: {} -> {}, key: {} bytes",
-            source,
-            target,
-            key.len()
-        );
-
-        translator.translate(proof, key, value)
-    }
-
-    /// Translate with context
-    pub fn translate_with_context(
-        &self,
-        source: &str,
-        target: &str,
-        proof: &dyn Any,
-        key: &[u8],
-        value: Option<&[u8]>,
-        context: &ProofContext,
-    ) -> Option<Box<dyn Any>> {
-        // For translators that don't support context directly,
-        // we'll convert relevant context data to universal proof metadata
-        let translator = self.get(source, target)?;
-
-        // First attempt to use universal format as an intermediate
-        if let Some(universal) = translator.to_universal(proof, key, value) {
-            // Copy context data to metadata
-            let mut enriched = universal;
-            for (key, value) in &context.data {
-                if !enriched.metadata.contains_key(key) {
-                    enriched.metadata.insert(key.clone(), value.clone());
-                }
-            }
-
-            // Then translate from the enriched universal format
-            translator.from_universal(&enriched)
-        } else {
-            // Fall back to direct translation if universal conversion fails
-            translator.translate(proof, key, value)
-        }
-    }
-
-    /// Translate a universal proof to a specific scheme
-    pub fn translate_universal(
-        &self,
-        target: &str,
-        universal: &CoreProofFormat,
-    ) -> Option<Box<dyn Any>> {
-        let source = &universal.scheme_id.0;
-        let translator = self.get(source, target)?;
-
-        // Log translation attempt
-        log::debug!("Translating universal proof: {} -> {}", source, target);
-
-        translator.from_universal(universal)
-    }
-
-    /// Translate a local proof format to a specific scheme
-    pub fn translate_local_universal(
-        &self,
-        target: &str,
-        local_universal: &LocalProofFormat,
-    ) -> Option<Box<dyn Any>> {
-        // Convert local format to core format
-        let core_universal = ProofFormatConverter::local_to_core(local_universal);
-
-        // Then translate using the core format
-        self.translate_universal(target, &core_universal)
-    }
-
-    /// Convert a proof to universal format
-    pub fn to_universal(
-        &self,
-        source: &str,
-        proof: &dyn Any,
-        key: &[u8],
-        value: Option<&[u8]>,
-    ) -> Option<CoreProofFormat> {
-        // Find any translator for this source scheme
-        for ((src, _), translator) in &self.translators {
-            if src == source {
-                return translator.to_universal(proof, key, value);
-            }
-        }
-        None
-    }
-
-    /// Convert a proof to local universal format
-    pub fn to_local_universal(
-        &self,
-        source: &str,
-        proof: &dyn Any,
-        key: &[u8],
-        value: Option<&[u8]>,
-    ) -> Option<LocalProofFormat> {
-        // First convert to core format
-        let core = self.to_universal(source, proof, key, value)?;
-
-        // Then convert to local format
-        Some(ProofFormatConverter::core_to_local(&core))
-    }
-
-    /// List all supported source schemes
-    pub fn source_schemes(&self) -> Vec<String> {
-        let mut schemes = self
-            .translators
-            .keys()
-            .map(|(source, _)| source.clone())
-            .collect::<Vec<_>>();
-        schemes.sort();
-        schemes.dedup();
-        schemes
-    }
-
-    /// List all supported target schemes
-    pub fn target_schemes(&self) -> Vec<String> {
-        let mut schemes = self
-            .translators
-            .keys()
-            .map(|(_, target)| target.clone())
-            .collect::<Vec<_>>();
-        schemes.sort();
-        schemes.dedup();
-        schemes
-    }
-
-    /// List all supported translations
-    pub fn supported_translations(&self) -> Vec<(String, String)> {
-        self.translators.keys().cloned().collect()
-    }
-}```
-
-######### File: services/src/ibc/src/translation/mod.rs:6:5
-######*Size: 0, Lines: 0, Type: empty*
-
-######*File content not included (exceeds threshold or non-text file)*
-
-######### File: services/src/ibc/src/translation/mod.rs:9:66
-######*Size: 0, Lines: 0, Type: empty*
-
-######*File content not included (exceeds threshold or non-text file)*
-
-######## Directory: services/src/ibc/src/verification
-
-######### Directory: services/src/ibc/src/verification/tests
-
-######### File: services/src/ibc/src/verification/mod.rs
-######*Size: 8.0K, Lines: 259, Type: ASCII text*
-
-```rust
-//! IBC verification utilities
-
-use depin_sdk_core::commitment::{ProofContext, Selector};
-use depin_sdk_core::ibc::{LightClient, UniversalProofFormat};
-use std::collections::HashMap;
-use std::sync::Arc;
-
-/// Registry for light clients
-pub struct LightClientRegistry {
-    /// Map from chain ID to light client instance
-    clients: HashMap<String, Arc<dyn LightClient>>,
-}
-
-impl LightClientRegistry {
-    /// Create a new light client registry
-    pub fn new() -> Self {
-        Self {
-            clients: HashMap::new(),
-        }
-    }
-
-    /// Register a light client
-    pub fn register(&mut self, chain_id: &str, client: Arc<dyn LightClient>) {
-        self.clients.insert(chain_id.to_string(), client);
-    }
-
-    /// Get a light client by chain ID
-    pub fn get(&self, chain_id: &str) -> Option<Arc<dyn LightClient>> {
-        self.clients.get(chain_id).cloned()
-    }
-
-    /// Verify a proof against a specific chain
-    pub fn verify(
-        &self,
-        chain_id: &str,
-        commitment: &[u8],
-        proof: &[u8],
-        selector: &Selector,
-        value: &[u8],
-        context: Option<&ProofContext>,
-    ) -> bool {
-        if let Some(client) = self.get(chain_id) {
-            // Extract key bytes from selector
-            let key_bytes = match selector {
-                Selector::Key(key) => key.as_slice(),
-                Selector::Position(pos) => {
-                    // Convert position to bytes if needed
-                    // For now just use empty slice or could use position as bytes
-                    &[]
-                }
-                // Handle other selector types
-                _ => &[],
-            };
-
-            client.verify_native_proof(commitment, proof, key_bytes, value)
-        } else {
-            false
-        }
-    }
-
-    /// Verify a universal proof against a specific chain
-    pub fn verify_universal(
-        &self,
-        chain_id: &str,
-        commitment: &[u8],
-        proof: &UniversalProofFormat,
-        value: &[u8],
-        context: Option<&ProofContext>,
-    ) -> bool {
-        if let Some(client) = self.get(chain_id) {
-            client.verify_universal_proof(commitment, proof, &proof.key, value)
-        } else {
-            false
-        }
-    }
-
-    /// List all registered chain IDs
-    pub fn chain_ids(&self) -> Vec<String> {
-        self.clients.keys().cloned().collect()
-    }
-}
-
-/// Proof verification result
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum VerificationResult {
-    /// Proof verified successfully
-    Success,
-    /// Proof verification failed
-    Failure(String),
-    /// Chain not found
-    ChainNotFound(String),
-    /// Unsupported proof format
-    UnsupportedProofFormat,
-    /// Invalid selector
-    InvalidSelector(String),
-    /// Missing or invalid context
-    InvalidContext(String),
-}
-
-/// Cross-chain proof verifier
-pub struct CrossChainVerifier {
-    /// Light client registry
-    registry: LightClientRegistry,
-    /// Trusted commitments by chain ID and height
-    commitments: HashMap<String, HashMap<u64, Vec<u8>>>,
-    /// Cached proof contexts by chain ID
-    contexts: HashMap<String, ProofContext>,
-}
-
-impl CrossChainVerifier {
-    /// Create a new cross-chain proof verifier
-    pub fn new(registry: LightClientRegistry) -> Self {
-        Self {
-            registry,
-            commitments: HashMap::new(),
-            contexts: HashMap::new(),
-        }
-    }
-
-    /// Add a trusted commitment
-    pub fn add_trusted_commitment(&mut self, chain_id: &str, height: u64, commitment: Vec<u8>) {
-        let chain_commitments = self
-            .commitments
-            .entry(chain_id.to_string())
-            .or_insert_with(HashMap::new);
-
-        chain_commitments.insert(height, commitment);
-    }
-
-    /// Add a proof context for a chain
-    pub fn add_context(&mut self, chain_id: &str, context: ProofContext) {
-        self.contexts.insert(chain_id.to_string(), context);
-    }
-
-    /// Get proof context for a chain
-    pub fn get_context(&self, chain_id: &str) -> Option<&ProofContext> {
-        self.contexts.get(chain_id)
-    }
-
-    /// Get the latest height for a chain
-    pub fn latest_height(&self, chain_id: &str) -> Option<u64> {
-        self.commitments
-            .get(chain_id)
-            .and_then(|commitments| commitments.keys().max().copied())
-    }
-
-    /// Get the commitment at a specific height
-    pub fn get_commitment(&self, chain_id: &str, height: u64) -> Option<&[u8]> {
-        self.commitments
-            .get(chain_id)
-            .and_then(|commitments| commitments.get(&height))
-            .map(|c| c.as_slice())
-    }
-
-    /// Verify a proof against the latest commitment for a chain
-    pub fn verify_proof(
-        &self,
-        chain_id: &str,
-        proof: &[u8],
-        selector: &Selector,
-        value: &[u8],
-    ) -> VerificationResult {
-        // Get the latest height
-        let height = match self.latest_height(chain_id) {
-            Some(h) => h,
-            None => return VerificationResult::ChainNotFound(chain_id.to_string()),
-        };
-
-        // Get the commitment at that height
-        let commitment = match self.get_commitment(chain_id, height) {
-            Some(c) => c,
-            None => {
-                return VerificationResult::Failure(format!(
-                    "No commitment found for chain {} at height {}",
-                    chain_id, height
-                ))
-            }
-        };
-
-        // Get the context for the chain
-        let context = self.get_context(chain_id);
-
-        // Verify the proof
-        if self
-            .registry
-            .verify(chain_id, commitment, proof, selector, value, context)
-        {
-            VerificationResult::Success
-        } else {
-            VerificationResult::Failure(format!(
-                "Proof verification failed for chain {} at height {}",
-                chain_id, height
-            ))
-        }
-    }
-
-    /// Verify a universal proof against the latest commitment for a chain
-    pub fn verify_universal_proof(
-        &self,
-        chain_id: &str,
-        proof: &UniversalProofFormat,
-        value: &[u8],
-    ) -> VerificationResult {
-        // Get the latest height
-        let height = match self.latest_height(chain_id) {
-            Some(h) => h,
-            None => return VerificationResult::ChainNotFound(chain_id.to_string()),
-        };
-
-        // Get the commitment at that height
-        let commitment = match self.get_commitment(chain_id, height) {
-            Some(c) => c,
-            None => {
-                return VerificationResult::Failure(format!(
-                    "No commitment found for chain {} at height {}",
-                    chain_id, height
-                ))
-            }
-        };
-
-        // Get the context for the chain
-        let context = self.get_context(chain_id);
-
-        // Verify the proof
-        if self
-            .registry
-            .verify_universal(chain_id, commitment, proof, value, context)
-        {
-            VerificationResult::Success
-        } else {
-            VerificationResult::Failure(format!(
-                "Proof verification failed for chain {} at height {}",
-                chain_id, height
-            ))
-        }
-    }
-
-    /// List all registered chain IDs
-    pub fn chain_ids(&self) -> Vec<String> {
-        self.registry.chain_ids()
-    }
-
-    /// Create verification context for a chain
-    pub fn create_context(&self, chain_id: &str, height: Option<u64>) -> ProofContext {
-        let mut context = ProofContext::new();
-
-        // Add chain ID to context
-        context.add_data("chain_id", chain_id.as_bytes().to_vec());
-
-        // Add height to context if specified
-        if let Some(h) = height {
-            context.add_data("height", h.to_le_bytes().to_vec());
-        } else if let Some(h) = self.latest_height(chain_id) {
-            context.add_data("height", h.to_le_bytes().to_vec());
-        }
-
-        context
-    }
-}
-```
-
-######## File: services/src/ibc/src/lib.rs
-#####*Size: 4.0K, Lines: 12, Type: ASCII text*
-
-```rust
-//! # DePIN SDK IBC
-//!
-//! Inter-Blockchain Communication implementation for the DePIN SDK.
-
-pub mod proof;
-pub mod translation;
-pub mod light_client;
-pub mod verification;
-pub mod conversion;
-
-use depin_sdk_core::ibc::{ProofTranslator, UniversalProofFormat};
-use depin_sdk_core::commitment::{CommitmentScheme, SchemeIdentifier};
-```
-
-######## File: services/src/ibc/src/lib.rs:11:27
-#####*Size: 0, Lines: 0, Type: empty*
-
-#####*File content not included (exceeds threshold or non-text file)*
-
-######## File: services/src/ibc/src/lib.rs:12:34
-#####*Size: 0, Lines: 0, Type: empty*
-
-#####*File content not included (exceeds threshold or non-text file)*
-
-####### File: services/src/ibc/Cargo.toml
-####*Size: 4.0K, Lines: 13, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-ibc"
-version = "0.1.0"
-edition = "2021"
-description = "Inter-Blockchain Communication implementation for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-depin-sdk-commitment-schemes = { path = "../commitment_schemes" }
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-```
-
-###### Directory: services/src/semantic
-
-####### File: services/src/semantic/mod.rs
-####*Size: 4.0K, Lines: 12, Type: ASCII text*
-
-```rust
-//! Semantic module implementation
-
-use depin_sdk_core::services::{BlockchainService, ServiceType};
-
-pub struct SemanticService {
-    // Add your implementation fields here
-}
-
-impl BlockchainService for SemanticService {
-    fn service_type(&self) -> ServiceType {
-        ServiceType::Semantic
-    }
-}```
-
-###### File: services/src/lib.rs
-###*Size: 4.0K, Lines: 3, Type: ASCII text*
-
-```rust
-pub mod external_data;
-pub mod governance;
-pub mod semantic;
-```
-
-##### File: services/Cargo.toml
-##*Size: 4.0K, Lines: 17, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-services"
-version = "0.1.0"
-edition = "2021"
-description = "Services for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-bytes = { workspace = true }
-anyhow = { workspace = true }
-
-[features]
-default = []
-```
-
-#### Directory: state_trees
-
-##### Directory: state_trees/src
-
-###### Directory: state_trees/src/file
-
-####### File: state_trees/src/file/mod.rs
-####*Size: 8.0K, Lines: 166, Type: ASCII text*
-
-```rust
-// Path: crates/state_trees/src/file/mod.rs
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::error::StateError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use serde::{Deserialize, Serialize};
-use std::any::Any;
-use std::collections::HashMap;
-use std::fs::{File, OpenOptions};
-use std::io::{self};
-use std::marker::PhantomData;
-use std::path::{Path, PathBuf};
-
-/// A simple, file-backed state tree implementation for demonstration purposes.
-/// It uses a HashMap internally and serializes to a JSON file.
-///
-/// FIX: The internal HashMap now uses `String` for keys to be compatible with
-/// the JSON format, which requires string keys for objects. Binary keys are
-/// hex-encoded before being used with the map.
-#[derive(Serialize, Deserialize, Debug)]
-pub struct FileStateTree<C: CommitmentScheme> {
-    path: PathBuf,
-    #[serde(skip, default)]
-    scheme: C,
-    // FIX: Changed key type from Vec<u8> to String.
-    data: HashMap<String, Vec<u8>>,
-    #[serde(skip)]
-    _phantom: PhantomData<C::Value>,
-}
-
-impl<C> FileStateTree<C>
-where
-    C: CommitmentScheme + Clone + Default,
-    C::Value: From<Vec<u8>>,
-{
-    pub fn new<P: AsRef<Path>>(path: P, scheme: C) -> Self {
-        let path_buf = path.as_ref().to_path_buf();
-        Self::load(&path_buf, scheme.clone()).unwrap_or_else(|_| Self {
-            path: path_buf,
-            scheme,
-            data: HashMap::new(),
-            _phantom: PhantomData,
-        })
-    }
-
-    fn load<P: AsRef<Path>>(path: P, scheme: C) -> io::Result<Self> {
-        let file = File::open(path)?;
-        let mut loaded: Self = serde_json::from_reader(file)
-            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
-        loaded.scheme = scheme;
-        Ok(loaded)
-    }
-
-    fn save(&self) -> io::Result<()> {
-        let file = OpenOptions::new()
-            .write(true)
-            .create(true)
-            .truncate(true)
-            .open(&self.path)?;
-        serde_json::to_writer_pretty(file, self)
-            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))
-    }
-}
-
-impl<C> StateTree for FileStateTree<C>
-where
-    C: CommitmentScheme + Clone + Send + Sync + Default,
-    C::Value: From<Vec<u8>>,
-{
-    type Commitment = C::Commitment;
-    type Proof = C::Proof;
-
-    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
-        // FIX: Hex-encode the key for lookup.
-        let key_hex = hex::encode(key);
-        Ok(self.data.get(&key_hex).cloned())
-    }
-
-    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
-        // FIX: Hex-encode the key before insertion.
-        let key_hex = hex::encode(key);
-        self.data.insert(key_hex, value.to_vec());
-        self.save()
-            .map_err(|e| StateError::WriteError(e.to_string()))
-    }
-
-    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
-        // FIX: Hex-encode the key for removal.
-        let key_hex = hex::encode(key);
-        self.data.remove(&key_hex);
-        self.save()
-            .map_err(|e| StateError::WriteError(e.to_string()))
-    }
-
-    fn root_commitment(&self) -> Self::Commitment {
-        let mut values_to_sort = self.data.values().cloned().collect::<Vec<_>>();
-        values_to_sort.sort();
-
-        let values_to_commit: Vec<Option<C::Value>> = values_to_sort
-            .into_iter()
-            .map(|v| Some(C::Value::from(v)))
-            .collect();
-
-        self.scheme.commit(&values_to_commit)
-    }
-
-    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-        // FIX: Hex-encode the key for lookup.
-        let key_hex = hex::encode(key);
-        let value = self.data.get(&key_hex)?;
-        self.scheme
-            .create_proof(
-                &Selector::Key(key.to_vec()),
-                &C::Value::from(value.clone()),
-            )
-            .ok()
-    }
-
-    fn verify_proof(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        self.scheme.verify(
-            commitment,
-            proof,
-            &Selector::Key(key.to_vec()),
-            &C::Value::from(value.to_vec()),
-            &ProofContext::default(),
-        )
-    }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-}
-
-impl<C> StateManager for FileStateTree<C>
-where
-    C: CommitmentScheme + Clone + Send + Sync + Default,
-    C::Commitment: Send + Sync,
-    C::Proof: Send + Sync,
-    C::Value: From<Vec<u8>> + Send + Sync,
-{
-    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-        for (key, value) in updates {
-            // FIX: Hex-encode each key before batch insertion.
-            let key_hex = hex::encode(key);
-
-            self.data.insert(key_hex, value.to_vec());
-        }
-        self.save()
-            .map_err(|e| StateError::WriteError(e.to_string()))
-    }
-
-    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-        let mut values = Vec::with_capacity(keys.len());
-        for key in keys {
-            // FIX: Hex-encode each key for batch lookup.
-            let key_hex = hex::encode(key);
-            values.push(self.data.get(&key_hex).cloned());
-        }
-        Ok(values)
-    }
-}```
-
-###### Directory: state_trees/src/hashmap
-
-####### File: state_trees/src/hashmap/mod.rs
-####*Size: 4.0K, Lines: 110, Type: ASCII text*
-
-```rust
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::error::StateError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use std::any::Any;
-use std::collections::HashMap;
-
-/// HashMap-based state tree implementation
-pub struct HashMapStateTree<CS: CommitmentScheme> {
-    /// Data store. Made `pub(crate)` to allow the `FileStateTree` wrapper to access it.
-    pub(crate) data: HashMap<Vec<u8>, CS::Value>,
-    /// Commitment scheme. Made `pub(crate)` for consistency.
-    pub(crate) scheme: CS,
-}
-
-impl<CS: CommitmentScheme> HashMapStateTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    /// Create a new HashMap-based state tree
-    pub fn new(scheme: CS) -> Self {
-        Self {
-            data: HashMap::new(),
-            scheme,
-        }
-    }
-
-    /// Convert Vec<u8> to Value type
-    fn to_value(&self, bytes: &[u8]) -> CS::Value {
-        CS::Value::from(bytes.to_vec())
-    }
-}
-
-impl<CS: CommitmentScheme> StateTree for HashMapStateTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    type Commitment = CS::Commitment;
-    type Proof = CS::Proof;
-
-    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
-        Ok(self.data.get(key).map(|v| v.as_ref().to_vec()))
-    }
-
-    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
-        self.data.insert(key.to_vec(), self.to_value(value));
-        Ok(())
-    }
-
-    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
-        self.data.remove(key);
-        Ok(())
-    }
-
-    fn root_commitment(&self) -> Self::Commitment {
-        // Keys must be sorted to ensure a deterministic commitment.
-        let mut sorted_keys: Vec<_> = self.data.keys().collect();
-        sorted_keys.sort();
-
-        let values: Vec<Option<CS::Value>> = sorted_keys
-            .iter()
-            .map(|key| self.data.get(*key).cloned())
-            .collect();
-        self.scheme.commit(&values)
-    }
-
-    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-        let value = self.get(key).ok()?.map(|v| self.to_value(&v))?;
-        let selector = Selector::Key(key.to_vec());
-        self.scheme.create_proof(&selector, &value).ok()
-    }
-
-    fn verify_proof(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        let context = ProofContext::default();
-        let typed_value = self.to_value(value);
-        let selector = Selector::Key(key.to_vec());
-
-        self.scheme
-            .verify(commitment, proof, &selector, &typed_value, &context)
-    }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-}
-
-impl<CS: CommitmentScheme> StateManager for HashMapStateTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-        for (key, value) in updates {
-            let value_typed = self.to_value(value);
-            self.data.insert(key.to_vec(), value_typed);
-        }
-        Ok(())
-    }
-
-    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-        let mut values = Vec::with_capacity(keys.len());
-        for key in keys {
-            values.push(self.data.get(key).map(|v| v.as_ref().to_vec()));
-        }
-        Ok(values)
-    }
-}```
-
-###### Directory: state_trees/src/iavl
-
-####### File: state_trees/src/iavl/mod.rs
-####*Size: 4.0K, Lines: 110, Type: ASCII text*
-
-```rust
-//! IAVL tree implementation
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::error::StateError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use std::any::Any;
-use std::collections::HashMap;
-
-/// IAVL tree implementation
-pub struct IAVLTree<CS: CommitmentScheme> {
-    /// Data store
-    data: HashMap<Vec<u8>, CS::Value>,
-    /// Commitment scheme
-    scheme: CS,
-}
-
-impl<CS: CommitmentScheme> IAVLTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    /// Create a new IAVL tree
-    pub fn new(scheme: CS) -> Self {
-        Self {
-            data: HashMap::new(),
-            scheme,
-        }
-    }
-
-    /// Get the underlying commitment scheme
-    pub fn scheme(&self) -> &CS {
-        &self.scheme
-    }
-
-    /// Convert a raw byte value to the commitment scheme's value type
-    fn to_value(&self, value: &[u8]) -> CS::Value {
-        CS::Value::from(value.to_vec())
-    }
-}
-
-impl<CS: CommitmentScheme> StateTree for IAVLTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    type Commitment = CS::Commitment;
-    type Proof = CS::Proof;
-
-    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
-        let scheme_value = self.to_value(value);
-        self.data.insert(key.to_vec(), scheme_value);
-        Ok(())
-    }
-
-    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
-        Ok(self.data.get(key).map(|v| v.as_ref().to_vec()))
-    }
-
-    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
-        self.data.remove(key);
-        Ok(())
-    }
-
-    fn root_commitment(&self) -> Self::Commitment {
-        let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-        self.scheme.commit(&values)
-    }
-
-    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-        let value = self.data.get(key)?;
-        let selector = Selector::Key(key.to_vec());
-        self.scheme.create_proof(&selector, value).ok()
-    }
-
-    fn verify_proof(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        let selector = Selector::Key(key.to_vec());
-        let context = ProofContext::default();
-        let scheme_value = self.to_value(value);
-        self.scheme
-            .verify(commitment, proof, &selector, &scheme_value, &context)
-    }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-}
-
-// FIX: Implement the StateManager trait.
-impl<CS: CommitmentScheme> StateManager for IAVLTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-        for (key, value) in updates {
-            self.insert(key, value)?;
-        }
-        Ok(())
-    }
-
-    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-        let mut results = Vec::with_capacity(keys.len());
-        for key in keys {
-            results.push(self.get(key)?);
-        }
-        Ok(results)
-    }
-}```
-
-###### Directory: state_trees/src/sparse_merkle
-
-####### File: state_trees/src/sparse_merkle/mod.rs
-####*Size: 4.0K, Lines: 111, Type: ASCII text*
-
-```rust
-//! Sparse Merkle tree implementation
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::error::StateError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use std::any::Any;
-use std::collections::HashMap;
-
-/// Sparse Merkle tree implementation
-pub struct SparseMerkleTree<CS: CommitmentScheme> {
-    /// Data store
-    data: HashMap<Vec<u8>, CS::Value>,
-    /// Commitment scheme
-    scheme: CS,
-}
-
-impl<CS: CommitmentScheme> SparseMerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    /// Create a new sparse Merkle tree
-    pub fn new(scheme: CS) -> Self {
-        Self {
-            data: HashMap::new(),
-            scheme,
-        }
-    }
-
-    fn to_value(&self, bytes: &[u8]) -> CS::Value {
-        CS::Value::from(bytes.to_vec())
-    }
-}
-
-impl<CS: CommitmentScheme> StateTree for SparseMerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    type Commitment = CS::Commitment;
-    type Proof = CS::Proof;
-
-    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
-        let value_typed = self.to_value(value);
-        self.data.insert(key.to_vec(), value_typed);
-        Ok(())
-    }
-
-    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
-        Ok(self.data.get(key).map(|v| v.as_ref().to_vec()))
-    }
-
-    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
-        self.data.remove(key);
-        Ok(())
-    }
-
-    fn root_commitment(&self) -> Self::Commitment {
-        let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-        self.scheme.commit(&values)
-    }
-
-    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-        let value_result = self.get(key).ok()?;
-        let value = value_result?;
-        let value_typed = self.to_value(&value);
-        self.scheme
-            .create_proof(&Selector::Key(key.to_vec()), &value_typed)
-            .ok()
-    }
-
-    fn verify_proof(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        let value_typed = self.to_value(value);
-        let context = ProofContext::default();
-        self.scheme.verify(
-            commitment,
-            proof,
-            &Selector::Key(key.to_vec()),
-            &value_typed,
-            &context,
-        )
-    }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-}
-
-// FIX: Implement the StateManager trait.
-impl<CS: CommitmentScheme> StateManager for SparseMerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-        for (key, value) in updates {
-            self.insert(key, value)?;
-        }
-        Ok(())
-    }
-
-    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-        let mut results = Vec::with_capacity(keys.len());
-        for key in keys {
-            results.push(self.get(key)?);
-        }
-        Ok(results)
-    }
-}```
-
-###### Directory: state_trees/src/verkle
-
-####### File: state_trees/src/verkle/mod.rs
-####*Size: 4.0K, Lines: 150, Type: ASCII text*
-
-```rust
-//! Verkle tree implementation
-
-use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-use depin_sdk_core::error::StateError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use std::any::Any;
-use std::collections::HashMap;
-
-/// Verkle tree implementation
-pub struct VerkleTree<CS: CommitmentScheme> {
-    /// Data store
-    data: HashMap<Vec<u8>, CS::Value>,
-    /// Commitment scheme
-    scheme: CS,
-    /// Branching factor
-    branching_factor: usize,
-}
-
-impl<CS: CommitmentScheme> VerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    /// Create a new Verkle tree with the specified branching factor
-    pub fn new(scheme: CS, branching_factor: usize) -> Self {
-        Self {
-            data: HashMap::new(),
-            scheme,
-            branching_factor,
-        }
-    }
-
-    /// Get the branching factor
-    pub fn branching_factor(&self) -> usize {
-        self.branching_factor
-    }
-
-    /// Get the underlying commitment scheme
-    pub fn scheme(&self) -> &CS {
-        &self.scheme
-    }
-
-    /// Get the number of elements stored in the tree
-    pub fn len(&self) -> usize {
-        self.data.len()
-    }
-
-    /// Check if the tree is empty
-    pub fn is_empty(&self) -> bool {
-        self.data.is_empty()
-    }
-}
-
-impl<CS: CommitmentScheme> StateTree for VerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    type Commitment = CS::Commitment;
-    type Proof = CS::Proof;
-
-    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
-        let cs_value = self
-            .convert_value(value)
-            .map_err(|e| StateError::InvalidValue(e))?;
-        self.data.insert(key.to_vec(), cs_value);
-        Ok(())
-    }
-
-    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
-        Ok(self.data.get(key).map(|v| self.extract_value(v)))
-    }
-
-    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
-        self.data.remove(key);
-        Ok(())
-    }
-
-    fn root_commitment(&self) -> Self::Commitment {
-        let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-        self.scheme.commit(&values)
-    }
-
-    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-        let value = self.data.get(key)?;
-        self.scheme
-            .create_proof(&Selector::Key(key.to_vec()), value)
-            .ok()
-    }
-
-    fn verify_proof(
-        &self,
-        commitment: &Self::Commitment,
-        proof: &Self::Proof,
-        key: &[u8],
-        value: &[u8],
-    ) -> bool {
-        if let Ok(cs_value) = self.convert_value(value) {
-            let mut context = ProofContext::new();
-            context.add_data(
-                "branching_factor",
-                self.branching_factor.to_le_bytes().to_vec(),
-            );
-            self.scheme.verify(
-                commitment,
-                proof,
-                &Selector::Key(key.to_vec()),
-                &cs_value,
-                &context,
-            )
-        } else {
-            false
-        }
-    }
-
-    fn as_any(&self) -> &dyn Any {
-        self
-    }
-}
-
-// FIX: Implement the StateManager trait.
-impl<CS: CommitmentScheme> StateManager for VerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-        for (key, value) in updates {
-            self.insert(key, value)?;
-        }
-        Ok(())
-    }
-
-    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-        let mut results = Vec::with_capacity(keys.len());
-        for key in keys {
-            results.push(self.get(key)?);
-        }
-        Ok(results)
-    }
-}
-
-impl<CS: CommitmentScheme> VerkleTree<CS>
-where
-    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-{
-    fn convert_value(&self, value: &[u8]) -> Result<CS::Value, String> {
-        Ok(CS::Value::from(value.to_vec()))
-    }
-
-    fn extract_value(&self, value: &CS::Value) -> Vec<u8> {
-        value.as_ref().to_vec()
-    }
-}```
-
-###### File: state_trees/src/lib.rs
-###*Size: 4.0K, Lines: 15, Type: ASCII text*
-
-```rust
-//! # DePIN SDK State Trees
-//!
-//! Implementations of various state tree structures for the DePIN SDK.
-
-pub mod file;
-pub mod hashmap;
-pub mod iavl;
-pub mod sparse_merkle;
-pub mod verkle;
-
-// Re-export concrete implementations for convenience
-pub use file::FileStateTree;
-pub use hashmap::HashMapStateTree;
-pub use iavl::IAVLTree;
-pub use sparse_merkle::SparseMerkleTree;
-pub use verkle::VerkleTree;```
-
-##### File: state_trees/Cargo.toml
-##*Size: 4.0K, Lines: 22, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-state-trees"
-version = "0.1.0"
-edition = "2021"
-description = "State tree implementations for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-depin-sdk-commitment-schemes = { path = "../commitment_schemes" }
-log = { workspace = true }
-serde = { workspace = true }
-thiserror = { workspace = true }
-bytes = { workspace = true }
-serde_json = { workspace = true }
-hex = { workspace = true }
-
-[features]
-default = []
-verkle = ["depin-sdk-commitment-schemes/kzg"]
-sparse_merkle = ["depin-sdk-commitment-schemes/hash"]
-iavl = ["depin-sdk-commitment-schemes/hash"]
-```
-
-#### Directory: test_utils
-
-##### Directory: test_utils/src
-
-###### Directory: test_utils/src/assertions
-
-####### Directory: test_utils/src/assertions/tests
-
-####### File: test_utils/src/assertions/mod.rs
-####*Size: 4.0K, Lines: 57, Type: ASCII text*
-
-```rust
-//! Assertion utilities for testing
-
-/// Assert that two byte arrays are equal
-#[macro_export]
-macro_rules! assert_bytes_eq {
-    ($left:expr, $right:expr) => {
-        assert_eq!($left.as_ref(), $right.as_ref());
-    };
-    ($left:expr, $right:expr, $($arg:tt)+) => {
-        assert_eq!($left.as_ref(), $right.as_ref(), $($arg)+);
-    };
-}
-
-/// Assert that a result is OK and unwrap it
-#[macro_export]
-macro_rules! assert_ok {
-    ($expr:expr) => {
-        match $expr {
-            Ok(val) => val,
-            Err(err) => panic!("Expected Ok, got Err: {:?}", err),
-        }
-    };
-    ($expr:expr, $($arg:tt)+) => {
-        match $expr {
-            Ok(val) => val,
-            Err(err) => panic!("Expected Ok, got Err: {:?} ({})", err, format!($($arg)+)),
-        }
-    };
-}
-
-/// Assert that a result is Err and unwrap the error
-#[macro_export]
-macro_rules! assert_err {
-    ($expr:expr) => {
-        match $expr {
-            Ok(val) => panic!("Expected Err, got Ok: {:?}", val),
-            Err(err) => err,
-        }
-    };
-    ($expr:expr, $($arg:tt)+) => {
-        match $expr {
-            Ok(val) => panic!("Expected Err, got Ok: {:?} ({})", val, format!($($arg)+)),
-            Err(err) => err,
-        }
-    };
-}
-
-/// Assert that a value is within a specific range
-#[macro_export]
-macro_rules! assert_in_range {
-    ($value:expr, $min:expr, $max:expr) => {
-        assert!($value >= $min && $value <= $max, "{} not in range [{}, {}]", $value, $min, $max);
-    };
-    ($value:expr, $min:expr, $max:expr, $($arg:tt)+) => {
-        assert!($value >= $min && $value <= $max, "{} not in range [{}, {}]: {}", $value, $min, $max, format!($($arg)+));
-    };
-}
-```
-
-###### Directory: test_utils/src/fixtures
-
-####### Directory: test_utils/src/fixtures/tests
-
-####### File: test_utils/src/fixtures/mod.rs
-####*Size: 4.0K, Lines: 118, Type: ASCII text*
-
-```rust
-//! Test fixtures for reproducible tests
-
-use std::fs;
-use std::io;
-use std::path::{Path, PathBuf};
-
-/// Test fixture manager
-pub struct Fixtures {
-    /// Base directory for fixtures
-    base_dir: PathBuf,
-}
-
-impl Fixtures {
-    /// Create a new fixtures manager with the specified base directory
-    pub fn new<P: AsRef<Path>>(base_dir: P) -> io::Result<Self> {
-        let base_dir = base_dir.as_ref().to_path_buf();
-        fs::create_dir_all(&base_dir)?;
-        Ok(Self { base_dir })
-    }
-
-    /// Get a fixture file path
-    pub fn path<P: AsRef<Path>>(&self, relative_path: P) -> PathBuf {
-        self.base_dir.join(relative_path)
-    }
-
-    /// Read a fixture file
-    pub fn read<P: AsRef<Path>>(&self, relative_path: P) -> io::Result<Vec<u8>> {
-        let path = self.path(relative_path);
-        fs::read(path)
-    }
-
-    /// Read a fixture file as a string
-    pub fn read_string<P: AsRef<Path>>(&self, relative_path: P) -> io::Result<String> {
-        let path = self.path(relative_path);
-        fs::read_to_string(path)
-    }
-
-    /// Write data to a fixture file
-    pub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(
-        &self,
-        relative_path: P,
-        contents: C,
-    ) -> io::Result<()> {
-        let path = self.path(relative_path);
-        if let Some(parent) = path.parent() {
-            fs::create_dir_all(parent)?;
-        }
-        fs::write(path, contents)
-    }
-
-    /// Create a temporary fixture directory
-    pub fn create_dir<P: AsRef<Path>>(&self, relative_path: P) -> io::Result<PathBuf> {
-        let path = self.path(relative_path);
-        fs::create_dir_all(&path)?;
-        Ok(path)
-    }
-
-    /// Check if a fixture file exists
-    pub fn exists<P: AsRef<Path>>(&self, relative_path: P) -> bool {
-        self.path(relative_path).exists()
-    }
-
-    /// Remove a fixture file or directory
-    pub fn remove<P: AsRef<Path>>(&self, relative_path: P) -> io::Result<()> {
-        let path = self.path(relative_path);
-        if path.is_dir() {
-            fs::remove_dir_all(path)
-        } else {
-            fs::remove_file(path)
-        }
-    }
-}
-
-/// Predefined test fixtures
-pub struct TestFixtures;
-
-impl TestFixtures {
-    /// Get a small sample message for testing
-    pub fn small_message() -> &'static [u8] {
-        b"This is a small test message"
-    }
-
-    /// Get a medium sample message for testing
-    pub fn medium_message() -> Vec<u8> {
-        let mut data = Vec::with_capacity(1024);
-        for i in 0..1024 {
-            data.push((i % 256) as u8);
-        }
-        data
-    }
-
-    /// Get a large sample message for testing
-    pub fn large_message() -> Vec<u8> {
-        let mut data = Vec::with_capacity(65536);
-        for i in 0..65536 {
-            data.push((i % 256) as u8);
-        }
-        data
-    }
-
-    /// Get a sample key pair for testing
-    pub fn sample_keypair() -> (Vec<u8>, Vec<u8>) {
-        // These are just dummy values for testing
-        let public_key = vec![
-            0x04, 0xa3, 0xb2, 0xc1, 0xd0, 0xe5, 0xf4, 0x23, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc,
-            0xde, 0xf0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc,
-            0xdd, 0xee, 0xff, 0x00,
-        ];
-
-        let private_key = vec![
-            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54,
-            0x32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc,
-            0xdd, 0xee, 0xff, 0x00,
-        ];
-
-        (public_key, private_key)
-    }
-}
-```
-
-###### Directory: test_utils/src/randomness
-
-####### Directory: test_utils/src/randomness/tests
-
-####### File: test_utils/src/randomness/mod.rs
-####*Size: 4.0K, Lines: 52, Type: ASCII text*
-
-```rust
-//! Deterministic randomness for reproducible tests
-
-use rand::rngs::StdRng;
-use rand::{RngCore, SeedableRng};
-
-/// Deterministic random number generator for tests
-pub struct TestRng {
-    /// Internal RNG with fixed seed
-    rng: StdRng,
-}
-
-impl TestRng {
-    /// Create a new test RNG with the specified seed
-    pub fn new(seed: u64) -> Self {
-        // Convert the u64 seed to a [u8; 32] seed array
-        let mut seed_array = [0u8; 32];
-        let seed_bytes = seed.to_le_bytes();
-        // Copy the u64 bytes into the first 8 bytes of the seed array
-        seed_array[..8].copy_from_slice(&seed_bytes);
-
-        Self {
-            rng: StdRng::from_seed(seed_array),
-        }
-    }
-
-    /// Create a test RNG with the default seed 12345
-    pub fn with_default_seed() -> Self {
-        Self::new(12345)
-    }
-
-    /// Fill a buffer with random bytes
-    pub fn fill_bytes(&mut self, dest: &mut [u8]) {
-        self.rng.fill_bytes(dest);
-    }
-
-    /// Generate a random value
-    pub fn next_u32(&mut self) -> u32 {
-        self.rng.next_u32()
-    }
-
-    /// Generate a random value
-    pub fn next_u64(&mut self) -> u64 {
-        self.rng.next_u64()
-    }
-}
-
-// Implement Default trait instead of just a method named default
-impl Default for TestRng {
-    fn default() -> Self {
-        Self::with_default_seed()
-    }
-}
-```
-
-###### File: test_utils/src/lib.rs
-###*Size: 4.0K, Lines: 7, Type: ASCII text*
-
-```rust
-//! # DePIN SDK Test Utilities
-//!
-//! Utilities for testing the DePIN SDK components.
-
-pub mod assertions;
-pub mod fixtures;
-pub mod randomness;
-```
-
-##### File: test_utils/Cargo.toml
-##*Size: 4.0K, Lines: 10, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-test-utils"
-version = "0.1.0"
-edition = "2021"
-description = "Utilities for testing the DePIN SDK components"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-rand = { workspace = true }
-```
-
-#### Directory: transaction_models
-
-##### Directory: transaction_models/src
-
-###### Directory: transaction_models/src/account
-
-####### File: transaction_models/src/account/mod.rs
-####*Size: 8.0K, Lines: 178, Type: ASCII text*
-
-```rust
-// Path: crates/transaction_models/src/account/mod.rs
-
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::error::{StateError, TransactionError};
-use depin_sdk_core::state::StateManager;
-use depin_sdk_core::transaction::TransactionModel;
-use serde::{Deserialize, Serialize};
-
-// FIX: Add derive macros for PartialEq and Eq, required by HybridTransaction.
-#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-pub struct AccountTransaction {
-    pub from: Vec<u8>,
-    pub to: Vec<u8>,
-    pub amount: u64,
-    pub nonce: u64,
-}
-
-#[derive(Serialize, Deserialize, Debug, Clone)]
-pub struct Account {
-    pub balance: u64,
-    pub nonce: u64,
-}
-
-// FIX: Add derive(Debug) as required by HybridConfig.
-#[derive(Debug, Clone, Default)]
-pub struct AccountConfig {
-    pub initial_balance: u64,
-}
-
-// FIX: Add derive(Debug, Clone) as required by HybridModel.
-#[derive(Debug, Clone)]
-pub struct AccountModel<CS: CommitmentScheme> {
-    config: AccountConfig,
-    _commitment_scheme: CS,
-}
-
-impl<CS: CommitmentScheme> AccountModel<CS> {
-    pub fn new(commitment_scheme: CS) -> Self {
-        Self {
-            config: AccountConfig::default(),
-            _commitment_scheme: commitment_scheme,
-        }
-    }
-
-    pub fn with_config(commitment_scheme: CS, config: AccountConfig) -> Self {
-        Self {
-            config,
-            _commitment_scheme: commitment_scheme,
-        }
-    }
-
-    fn get_account<S: StateManager + ?Sized>(&self, state: &S, key: &[u8]) -> Result<Account, TransactionError> {
-        let value = state.get(key)?;
-        match value {
-            Some(data) => self.decode_account(&data),
-            None => Ok(Account {
-                balance: self.config.initial_balance,
-                nonce: 0,
-            }),
-        }
-    }
-
-    fn decode_account(&self, data: &[u8]) -> Result<Account, TransactionError> {
-        // FIX: Use the correct `Serialization` variant.
-        serde_json::from_slice(data).map_err(|e| TransactionError::Serialization(e.to_string()))
-    }
-
-    fn encode_account(&self, account: &Account) -> Vec<u8> {
-        serde_json::to_vec(account).unwrap()
-    }
-}
-
-impl<CS: CommitmentScheme + Send + Sync> TransactionModel for AccountModel<CS> {
-    type Transaction = AccountTransaction;
-    type CommitmentScheme = CS;
-    type Proof = ();
-
-    // FIX: Add the required `where` clause to the method signature.
-    fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        let sender_account = self.get_account(state, &tx.from)?;
-        if sender_account.balance < tx.amount {
-            // FIX: Use the correct `Invalid` variant.
-            return Err(TransactionError::Invalid("Insufficient balance".to_string()));
-        }
-        if sender_account.nonce != tx.nonce {
-            return Err(TransactionError::Invalid("Invalid nonce".to_string()));
-        }
-        Ok(true)
-    }
-
-    // FIX: Add the required `where` clause.
-    fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        // Since we now have `From<StateError>` for `TransactionError`, `?` works.
-        if !self.validate(tx, state)? {
-            // FIX: Use the correct `Invalid` variant.
-            return Err(TransactionError::Invalid("Validation failed".to_string()));
-        }
-
-        let sender_key = tx.from.clone();
-        let mut sender_account = self.get_account(state, &sender_key)?;
-        sender_account.balance -= tx.amount;
-        sender_account.nonce += 1;
-        state.insert(&sender_key, &self.encode_account(&sender_account))?;
-
-        let receiver_key = tx.to.clone();
-        let mut receiver_account = self.get_account(state, &receiver_key)?;
-        receiver_account.balance = receiver_account
-            .balance
-            .checked_add(tx.amount)
-            // FIX: Use the correct `Invalid` variant.
-            .ok_or(TransactionError::Invalid("Balance overflow".to_string()))?;
-        state.insert(&receiver_key, &self.encode_account(&receiver_account))?;
-
-        Ok(())
-    }
-
-    fn create_coinbase_transaction(
-        &self,
-        _block_height: u64,
-        _recipient: &[u8],
-    ) -> Result<Self::Transaction, TransactionError> {
-        // Account models don't typically have coinbase transactions.
-        Err(TransactionError::Invalid(
-            "Coinbase not supported for account model".to_string(),
-        ))
-    }
-
-    // FIX: Add the required `where` clause.
-    fn generate_proof<S>(
-        &self,
-        _tx: &Self::Transaction,
-        _state: &S,
-    ) -> Result<Self::Proof, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        Ok(())
-    }
-
-    // FIX: Add the required `where` clause.
-    fn verify_proof<S>(
-        &self,
-        _proof: &Self::Proof,
-        _state: &S,
-    ) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        Ok(true)
-    }
-
-    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
-        // FIX: Use the correct `Serialization` variant.
-        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-    }
-
-    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
-        // FIX: Use the correct `Deserialization` variant.
-        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-    }
-}```
-
-###### Directory: transaction_models/src/hybrid
-
-####### File: transaction_models/src/hybrid/mod.rs
-####*Size: 8.0K, Lines: 145, Type: ASCII text*
-
-```rust
-// Path: crates/transaction_models/src/hybrid/mod.rs
-
-use crate::account::{AccountConfig, AccountModel, AccountTransaction};
-use crate::utxo::{UTXOConfig, UTXOModel, UTXOTransaction};
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::error::TransactionError;
-use depin_sdk_core::state::StateManager;
-use depin_sdk_core::transaction::TransactionModel;
-use serde::{Deserialize, Serialize};
-
-#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-pub enum HybridTransaction {
-    Account(AccountTransaction),
-    UTXO(UTXOTransaction),
-}
-
-#[derive(Debug, Clone)]
-pub enum HybridProof {
-    // FIX: Match the inner models' proof types, which are now `()`.
-    Account(()),
-    UTXO(()),
-}
-
-#[derive(Debug, Clone, Default)]
-pub struct HybridConfig {
-    pub account_config: AccountConfig,
-    pub utxo_config: UTXOConfig,
-}
-
-#[derive(Debug, Clone)]
-pub struct HybridModel<CS: CommitmentScheme> {
-    account_model: AccountModel<CS>,
-    utxo_model: UTXOModel<CS>,
-}
-
-impl<CS: CommitmentScheme + Clone> HybridModel<CS> {
-    pub fn new(scheme: CS) -> Self {
-        Self {
-            account_model: AccountModel::new(scheme.clone()),
-            utxo_model: UTXOModel::new(scheme),
-        }
-    }
-    pub fn with_config(scheme: CS, config: HybridConfig) -> Self {
-        Self {
-            account_model: AccountModel::with_config(scheme.clone(), config.account_config),
-            utxo_model: UTXOModel::with_config(scheme, config.utxo_config),
-        }
-    }
-}
-
-impl<CS: CommitmentScheme + Clone + Send + Sync> TransactionModel for HybridModel<CS> {
-    type Transaction = HybridTransaction;
-    type CommitmentScheme = CS;
-    type Proof = HybridProof;
-
-    fn create_coinbase_transaction(
-        &self,
-        block_height: u64,
-        recipient: &[u8],
-    ) -> Result<Self::Transaction, TransactionError> {
-        let utxo_coinbase = self
-            .utxo_model
-            .create_coinbase_transaction(block_height, recipient)?;
-        Ok(HybridTransaction::UTXO(utxo_coinbase))
-    }
-
-    // FIX: Add the required `where` clause to the method signature.
-    fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        match tx {
-            HybridTransaction::Account(account_tx) => self.account_model.validate(account_tx, state),
-            HybridTransaction::UTXO(utxo_tx) => self.utxo_model.validate(utxo_tx, state),
-        }
-    }
-
-    // FIX: Add the required `where` clause.
-    fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        match tx {
-            HybridTransaction::Account(account_tx) => self.account_model.apply(account_tx, state),
-            HybridTransaction::UTXO(utxo_tx) => self.utxo_model.apply(utxo_tx, state),
-        }
-    }
-
-    // FIX: Add the required `where` clause.
-    fn generate_proof<S>(
-        &self,
-        tx: &Self::Transaction,
-        state: &S,
-    ) -> Result<Self::Proof, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        match tx {
-            HybridTransaction::Account(account_tx) => {
-                let proof = self.account_model.generate_proof(account_tx, state)?;
-                Ok(HybridProof::Account(proof))
-            }
-            HybridTransaction::UTXO(utxo_tx) => {
-                let proof = self.utxo_model.generate_proof(utxo_tx, state)?;
-                Ok(HybridProof::UTXO(proof))
-            }
-        }
-    }
-
-    // FIX: Add the required `where` clause.
-    fn verify_proof<S>(
-        &self,
-        proof: &Self::Proof,
-        state: &S,
-    ) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        match proof {
-            HybridProof::Account(account_proof) => {
-                self.account_model.verify_proof(account_proof, state)
-            }
-            HybridProof::UTXO(utxo_proof) => self.utxo_model.verify_proof(utxo_proof, state),
-        }
-    }
-
-    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
-        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-    }
-
-    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
-        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-    }
-}```
-
-###### Directory: transaction_models/src/utxo
-
-####### File: transaction_models/src/utxo/mod.rs
-####*Size: 8.0K, Lines: 190, Type: ASCII text*
-
-```rust
-// Path: crates/transaction_models/src/utxo/mod.rs
-
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::error::{StateError, TransactionError};
-use depin_sdk_core::state::StateManager;
-use depin_sdk_core::transaction::TransactionModel;
-use serde::{Deserialize, Serialize};
-use sha2::{Digest, Sha256};
-
-#[derive(Debug, Clone, Default)]
-pub struct UTXOConfig {
-    pub max_inputs: usize,
-    pub max_outputs: usize,
-}
-
-pub trait UTXOOperations {
-    fn create_utxo_key(&self, tx_hash: &[u8], index: u32) -> Vec<u8>;
-}
-
-#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-pub struct Input {
-    pub tx_hash: Vec<u8>,
-    pub output_index: u32,
-    pub signature: Vec<u8>,
-}
-
-#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-pub struct Output {
-    pub value: u64,
-    pub public_key: Vec<u8>,
-}
-
-#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-pub struct UTXOTransaction {
-    pub inputs: Vec<Input>,
-    pub outputs: Vec<Output>,
-}
-
-impl UTXOTransaction {
-    pub fn hash(&self) -> Vec<u8> {
-        let serialized = serde_json::to_vec(self).unwrap();
-        Sha256::digest(&serialized).to_vec()
-    }
-}
-
-#[derive(Debug, Clone)]
-pub struct UTXOModel<CS: CommitmentScheme> {
-    config: UTXOConfig,
-    _commitment_scheme: CS,
-}
-
-impl<CS: CommitmentScheme + Clone> UTXOModel<CS> {
-    pub fn new(commitment_scheme: CS) -> Self {
-        Self {
-            config: UTXOConfig::default(),
-            _commitment_scheme: commitment_scheme,
-        }
-    }
-    pub fn with_config(commitment_scheme: CS, config: UTXOConfig) -> Self {
-        Self {
-            config,
-            _commitment_scheme: commitment_scheme,
-        }
-    }
-}
-
-impl<CS: CommitmentScheme> UTXOOperations for UTXOModel<CS> {
-    fn create_utxo_key(&self, tx_hash: &[u8], index: u32) -> Vec<u8> {
-        let mut key = b"u".to_vec();
-        key.extend_from_slice(tx_hash);
-        key.extend_from_slice(&index.to_le_bytes());
-        key
-    }
-}
-
-impl<CS: CommitmentScheme + Clone + Send + Sync> TransactionModel for UTXOModel<CS> {
-    type Transaction = UTXOTransaction;
-    type CommitmentScheme = CS;
-    type Proof = ();
-
-    fn validate<SM>(&self, tx: &Self::Transaction, state: &SM) -> Result<bool, TransactionError>
-    where
-        SM: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        // --- FIX: Add special validation logic for coinbase transactions ---
-        // A coinbase transaction is the only valid transaction type with no inputs.
-        if tx.inputs.is_empty() {
-            // A valid coinbase should have at least one output to reward the miner.
-            // More complex rules (e.g., exactly one output) could be added here.
-            return Ok(!tx.outputs.is_empty());
-        }
-        // --- End Fix ---
-
-        if tx.inputs.len() > self.config.max_inputs || tx.outputs.len() > self.config.max_outputs {
-            return Ok(false);
-        }
-
-        let mut total_input: u64 = 0;
-        for input in &tx.inputs {
-            let key = self.create_utxo_key(&input.tx_hash, input.output_index);
-            let utxo_bytes = state.get(&key)?.ok_or_else(|| {
-                TransactionError::Invalid(format!("Input UTXO not found"))
-            })?;
-            let utxo: Output = serde_json::from_slice(&utxo_bytes)
-                .map_err(|e| TransactionError::Invalid(format!("Deserialize error: {}", e)))?;
-            total_input = total_input.checked_add(utxo.value)
-                .ok_or_else(|| TransactionError::Invalid("Input value overflow".to_string()))?;
-        }
-
-        let total_output: u64 = tx.outputs.iter().map(|o| o.value).sum();
-        if total_input < total_output {
-            return Ok(false);
-        }
-
-        Ok(true)
-    }
-
-    fn apply<SM>(&self, tx: &Self::Transaction, state: &mut SM) -> Result<(), TransactionError>
-    where
-        SM: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        if !self.validate(tx, state)? {
-            return Err(TransactionError::Invalid("Validation failed".to_string()));
-        }
-        for input in &tx.inputs {
-            let key = self.create_utxo_key(&input.tx_hash, input.output_index);
-            state.delete(&key)?;
-        }
-        let tx_hash = tx.hash();
-        for (index, output) in tx.outputs.iter().enumerate() {
-            let key = self.create_utxo_key(&tx_hash, index as u32);
-            let value = serde_json::to_vec(output)
-                .map_err(|e| TransactionError::Serialization(e.to_string()))?;
-            state.insert(&key, &value)?;
-        }
-        Ok(())
-    }
-
-    fn create_coinbase_transaction(
-        &self,
-        _block_height: u64,
-        recipient: &[u8],
-    ) -> Result<Self::Transaction, TransactionError> {
-        Ok(UTXOTransaction {
-            inputs: vec![],
-            outputs: vec![Output { value: 50, public_key: recipient.to_vec() }],
-        })
-    }
-
-    fn generate_proof<S>(
-        &self,
-        _tx: &Self::Transaction,
-        _state: &S,
-    ) -> Result<Self::Proof, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        Ok(())
-    }
-
-    fn verify_proof<S>(
-        &self,
-        _proof: &Self::Proof,
-        _state: &S,
-    ) -> Result<bool, TransactionError>
-    where
-        S: StateManager<
-                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-            > + ?Sized,
-    {
-        Ok(true)
-    }
-
-    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
-        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-    }
-
-    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
-        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-    }
-}```
-
-###### File: transaction_models/src/lib.rs
-###*Size: 4.0K, Lines: 10, Type: ASCII text*
-
-```rust
-// Path: crates/transaction_models/src/lib.rs
-
-#![allow(clippy::new_without_default)]
-pub mod account;
-pub mod hybrid;
-pub mod utxo;
-
-pub use account::{AccountConfig, AccountModel, AccountTransaction};
-// FIX: The HybridOperations trait does not exist, so this line is removed.
-pub use hybrid::{HybridConfig, HybridModel, HybridTransaction};
-pub use utxo::{UTXOConfig, UTXOModel, UTXOTransaction};```
-
-##### File: transaction_models/Cargo.toml
-##*Size: 4.0K, Lines: 19, Type: ASCII text*
-
-```toml
-[package]
-name = "depin-sdk-transaction-models"
-version = "0.1.0"
-edition = "2021"
-description = "Transaction model implementations for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-log = { workspace = true }
-serde = { workspace = true, features = ["derive"] }
-serde_json = { workspace = true }
-thiserror = { workspace = true }
-sha2 = { workspace = true }
-# FIX: Add the missing 'hex' dependency used for logging UTXO hashes.
-hex = { workspace = true }
-
-[features]
-default = []
-```
-
-#### Directory: validator
-
-##### Directory: validator/src
-
-###### Directory: validator/src/bin
-
-####### File: validator/src/bin/validator_hybrid.rs
-####*Size: 4.0K, Lines: 73, Type: C source, ASCII text*
-
-```rust
-// Path: crates/validator/src/bin/validator_hybrid.rs
-
-use anyhow::anyhow;
-use clap::Parser;
-// FIX: Import WorkloadContainer from its new, correct location in `core`.
-use depin_sdk_core::validator::WorkloadContainer;
-use depin_sdk_core::{config::WorkloadConfig, Container};
-use depin_sdk_state_trees::file::FileStateTree;
-// FIX: Add necessary imports.
-use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-use depin_sdk_validator::{
-    common::GuardianContainer,
-    hybrid::{ApiContainer, InterfaceContainer},
-    standard::OrchestrationContainer,
-};
-use std::path::PathBuf;
-use std::sync::Arc;
-use tokio::sync::Mutex;
-
-
-#[derive(Parser, Debug)]
-#[clap(name = "validator_hybrid", about = "A hybrid DePIN SDK validator node with public APIs.")]
-struct Opts {
-    #[clap(long, default_value = "./config")]
-    config_dir: String,
-}
-
-#[tokio::main]
-async fn main() -> anyhow::Result<()> {
-    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-    let opts = Opts::parse();
-    let path = PathBuf::from(opts.config_dir);
-
-    log::info!("Initializing Hybrid Validator...");
-
-    // FIX: Pass borrowed paths (`&`) to the `new` constructors.
-    let guardian = GuardianContainer::new(&path.join("guardian.toml"))?;
-
-    let state_tree = FileStateTree::new("state.json", HashCommitmentScheme::new());
-
-    let workload = Arc::new(WorkloadContainer::new(
-        WorkloadConfig::default(),
-        state_tree,
-    ));
-
-    let orchestration = Arc::new(OrchestrationContainer::new(
-        &path.join("orchestration.toml"),
-    )?);
-    
-    // Wire up a dummy chain for now.
-    orchestration.set_chain_and_workload_ref(Arc::new(Mutex::new(())), workload);
-
-    let interface = InterfaceContainer::new(&path.join("interface.toml"))?;
-    let api = ApiContainer::new(&path.join("api.toml"))?;
-
-
-    log::info!("Starting services...");
-    guardian.start()?;
-    // FIX: The start method is async and must be awaited.
-    orchestration.start().await?;
-    interface.start()?;
-    api.start()?;
-
-    tokio::signal::ctrl_c().await?;
-    log::info!("Shutdown signal received.");
-
-    api.stop()?;
-    interface.stop()?;
-    orchestration.stop().await?;
-    guardian.stop()?;
-    log::info!("Validator stopped gracefully.");
-    
-    Ok(())
-}```
-
-####### File: validator/src/bin/validator.rs
-####*Size: 4.0K, Lines: 64, Type: C source, ASCII text*
-
-```rust
-// Path: crates/validator/src/bin/validator.rs
-
-use anyhow::anyhow;
-use clap::Parser;
-use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-// FIX: core::Container is now async
-use depin_sdk_core::validator::{Container, WorkloadContainer};
-use depin_sdk_core::WorkloadConfig;
-use depin_sdk_state_trees::file::FileStateTree;
-use depin_sdk_validator::{common::GuardianContainer, standard::OrchestrationContainer};
-use std::path::PathBuf;
-use std::sync::Arc;
-use tokio::sync::Mutex;
-
-#[derive(Parser, Debug)]
-#[clap(name = "validator", about = "A standard DePIN SDK validator node.")]
-struct Opts {
-    #[clap(long, default_value = "./config")]
-    config_dir: String,
-}
-
-#[tokio::main]
-async fn main() -> anyhow::Result<()> {
-    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-    let opts = Opts::parse();
-    let path = PathBuf::from(opts.config_dir);
-
-    log::info!("Initializing Standard Validator...");
-
-    let guardian = GuardianContainer::new(&path.join("guardian.toml"))?;
-
-    let state_tree = FileStateTree::new("state.json", HashCommitmentScheme::new());
-
-    let workload_config = WorkloadConfig {
-        enabled_vms: vec!["WASM".to_string()],
-    };
-
-    let workload = Arc::new(WorkloadContainer::new(workload_config, state_tree));
-
-    // FIX: OrchestrationContainer::new is now async and must be awaited.
-    let orchestration = Arc::new(
-        OrchestrationContainer::<
-            HashCommitmentScheme,
-            (), // Placeholder for TM
-            FileStateTree<HashCommitmentScheme>,
-        >::new(&path.join("orchestration.toml"))
-        .await?,
-    );
-
-    // Wire up a dummy chain for now. In a real scenario, this would be part of the composition root.
-    // orchestration.set_chain_and_workload_ref(Arc::new(Mutex::new(())), workload);
-
-    log::info!("Starting services...");
-    orchestration.start().await?;
-    guardian.start().await?;
-
-    tokio::signal::ctrl_c().await?;
-    log::info!("Shutdown signal received.");
-
-    orchestration.stop().await?;
-    guardian.stop().await?;
-    log::info!("Validator stopped gracefully.");
-
-    Ok(())
-}```
-
-###### Directory: validator/src/common
-
-####### Directory: validator/src/common/tests
-
-######## File: validator/src/common/tests/mod.rs
-#####*Size: 4.0K, Lines: 45, Type: ASCII text*
-
-```rust
-//! Tests for common validator components
-
-#[cfg(test)]
-mod tests {
-    use super::super::guardian::{BootStatus, GuardianContainer};
-    use super::super::security::SecurityChannel;
-    use std::path::Path;
-
-    #[test]
-    fn test_guardian_container() {
-        let config_path = Path::new("test_config.toml");
-        let guardian = GuardianContainer::new(config_path);
-
-        // Initial state
-        assert_eq!(guardian.boot_status(), BootStatus::NotStarted);
-
-        // Start boot process
-        guardian.start_boot().unwrap();
-        assert_eq!(guardian.boot_status(), BootStatus::Completed);
-
-        // Verify attestation
-        let attestation_result = guardian.verify_attestation().unwrap();
-        assert!(attestation_result);
-    }
-
-    #[test]
-    fn test_security_channel() {
-        let channel = SecurityChannel::new("test_source", "test_destination");
-
-        assert_eq!(channel.source, "test_source");
-        assert_eq!(channel.destination, "test_destination");
-        assert_eq!(channel.channel_id, "test_source:test_destination");
-
-        // Test establish
-        channel.establish().unwrap();
-
-        // Test send and receive
-        let data = vec![1, 2, 3, 4];
-        channel.send(&data).unwrap();
-
-        let received = channel.receive(10).unwrap();
-        // In our implementation, receive returns empty data for testing
-        assert_eq!(received.len(), 0);
-    }
-}
-```
-
-####### File: validator/src/common/attestation.rs
-####*Size: 16K, Lines: 415, Type: ASCII text*
-
-```rust
-// attestation.rs - Container attestation implementation
-
-use crate::chain::ChainState;
-use crate::crypto::{CryptoProvider, SignatureScheme};
-use serde::{Deserialize, Serialize};
-use std::time::{Duration, SystemTime};
-
-/// Attestation data structure that follows chain's signature evolution
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct ContainerAttestation {
-    /// Container identifier
-    pub container_id: ContainerId,
-
-    /// Merkle root of measured binaries and memory
-    pub merkle_root: MerkleRoot,
-
-    /// Challenge nonce from Guardian
-    pub nonce: Vec<u8>,
-
-    /// Timestamp of attestation
-    pub timestamp: Timestamp,
-
-    /// Public key for verification (format depends on current scheme)
-    pub public_key: Vec<u8>,
-
-    /// Signature over (nonce || merkle_root || timestamp)
-    /// Uses the chain's current signature scheme
-    pub signature: Vec<u8>,
-
-    /// Metadata about the attestation
-    pub metadata: AttestationMetadata,
-}
-
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct AttestationMetadata {
-    /// Which signature scheme was used (for verification)
-    pub signature_scheme: SignatureScheme,
-
-    /// Container version
-    pub container_version: String,
-
-    /// Additional measurements
-    pub extended_measurements: HashMap<String, Vec<u8>>,
-}
-
-/// Attestation manager that handles the protocol
-pub struct AttestationManager {
-    /// Reference to chain state for current signature scheme
-    chain_state: Arc<ChainState>,
-
-    /// Cryptographic provider
-    crypto_provider: Arc<CryptoProvider>,
-
-    /// Container's key pair (format depends on current scheme)
-    key_pair: Arc<RwLock<KeyPair>>,
-
-    /// Configuration
-    config: AttestationConfig,
-
-    /// Attestation history for monitoring
-    history: RwLock<AttestationHistory>,
-}
-
-impl AttestationManager {
-    /// Creates attestation using current chain signature scheme
-    pub async fn create_attestation(
-        &self,
-        nonce: &[u8],
-        measurements: &ContainerMeasurements,
-    ) -> Result<ContainerAttestation, AttestationError> {
-        // Get current signature scheme from chain
-        let current_scheme = self
-            .chain_state
-            .get_active_signature_scheme()
-            .await
-            .map_err(|e| AttestationError::ChainStateError(e))?;
-
-        // Build merkle root from measurements
-        let merkle_root = self.compute_merkle_root(measurements)?;
-
-        // Create attestation message
-        let timestamp = current_time();
-        let message = self.build_attestation_message(nonce, &merkle_root, timestamp)?;
-
-        // Sign using current scheme
-        let key_pair = self.key_pair.read().await;
-        let (signature, public_key) = match current_scheme {
-            SignatureScheme::Ed25519 => {
-                let sig = self
-                    .crypto_provider
-                    .sign_ed25519(&key_pair.ed25519()?, &message)?;
-                let pk = key_pair.ed25519()?.public_key();
-                (sig, pk)
-            }
-            SignatureScheme::Dilithium2 => {
-                let sig = self
-                    .crypto_provider
-                    .sign_dilithium2(&key_pair.dilithium2()?, &message)?;
-                let pk = key_pair.dilithium2()?.public_key();
-                (sig, pk)
-            }
-            SignatureScheme::Falcon512 => {
-                let sig = self
-                    .crypto_provider
-                    .sign_falcon512(&key_pair.falcon512()?, &message)?;
-                let pk = key_pair.falcon512()?.public_key();
-                (sig, pk)
-            }
-            // Add other schemes as needed
-            _ => return Err(AttestationError::UnsupportedScheme(current_scheme)),
-        };
-
-        // Create attestation
-        let attestation = ContainerAttestation {
-            container_id: self.get_container_id(),
-            merkle_root,
-            nonce: nonce.to_vec(),
-            timestamp,
-            public_key,
-            signature,
-            metadata: AttestationMetadata {
-                signature_scheme: current_scheme,
-                container_version: self.get_container_version(),
-                extended_measurements: measurements.extended.clone(),
-            },
-        };
-
-        // Record in history
-        self.history.write().await.record_attestation(&attestation);
-
-        Ok(attestation)
-    }
-
-    /// Handles key rotation when chain signature scheme changes
-    pub async fn handle_signature_rotation(
-        &self,
-        new_scheme: SignatureScheme,
-    ) -> Result<(), RotationError> {
-        info!(
-            "Rotating attestation keys to {:?} following chain rotation",
-            new_scheme
-        );
-
-        // Generate new key pair for the scheme
-        let new_key_pair = match new_scheme {
-            SignatureScheme::Ed25519 => KeyPair::generate_ed25519(&mut self.crypto_provider.rng())?,
-            SignatureScheme::Dilithium2 => {
-                KeyPair::generate_dilithium2(&mut self.crypto_provider.rng())?
-            }
-            SignatureScheme::Falcon512 => {
-                KeyPair::generate_falcon512(&mut self.crypto_provider.rng())?
-            }
-            _ => return Err(RotationError::UnsupportedScheme(new_scheme)),
-        };
-
-        // Atomic key replacement
-        let mut key_pair = self.key_pair.write().await;
-        *key_pair = new_key_pair;
-
-        // Notify Guardian of key rotation
-        self.notify_guardian_of_rotation(new_scheme).await?;
-
-        Ok(())
-    }
-
-    /// Builds the attestation message to be signed
-    fn build_attestation_message(
-        &self,
-        nonce: &[u8],
-        merkle_root: &MerkleRoot,
-        timestamp: Timestamp,
-    ) -> Result<Vec<u8>, AttestationError> {
-        let mut message = Vec::new();
-        message.extend_from_slice(nonce);
-        message.extend_from_slice(merkle_root.as_bytes());
-        message.extend_from_slice(&timestamp.to_be_bytes());
-        Ok(message)
-    }
-
-    /// Monitors chain for signature scheme changes
-    pub async fn monitor_scheme_changes(&self) -> Result<(), Error> {
-        let mut current_scheme = self.chain_state.get_active_signature_scheme().await?;
-
-        loop {
-            // Check every block for scheme changes
-            tokio::time::sleep(self.config.scheme_check_interval).await;
-
-            let new_scheme = self.chain_state.get_active_signature_scheme().await?;
-            if new_scheme != current_scheme {
-                info!(
-                    "Detected signature scheme change: {:?} -> {:?}",
-                    current_scheme, new_scheme
-                );
-
-                // Handle rotation
-                self.handle_signature_rotation(new_scheme).await?;
-                current_scheme = new_scheme;
-            }
-        }
-    }
-}
-
-/// Guardian-side attestation verifier
-pub struct AttestationVerifier {
-    chain_state: Arc<ChainState>,
-    crypto_provider: Arc<CryptoProvider>,
-    config: AttestationConfig,
-    container_registry: Arc<ContainerRegistry>,
-}
-
-impl AttestationVerifier {
-    /// Verifies attestation using the scheme it was created with
-    pub async fn verify_attestation(
-        &self,
-        attestation: &ContainerAttestation,
-    ) -> Result<(), AttestationError> {
-        // Verify timestamp freshness
-        let now = current_time();
-        let age = now.saturating_sub(attestation.timestamp);
-        if age > self.config.max_attestation_age {
-            return Err(AttestationError::StaleAttestation { age });
-        }
-
-        // Check clock skew
-        if attestation.timestamp > now + self.config.max_clock_skew {
-            return Err(AttestationError::ClockSkew);
-        }
-
-        // Verify container is registered
-        let container_info = self
-            .container_registry
-            .get(&attestation.container_id)
-            .await
-            .ok_or(AttestationError::UnknownContainer)?;
-
-        // Build message for verification
-        let message = self.build_attestation_message(
-            &attestation.nonce,
-            &attestation.merkle_root,
-            attestation.timestamp,
-        )?;
-
-        // Verify signature using the scheme specified in metadata
-        match attestation.metadata.signature_scheme {
-            SignatureScheme::Ed25519 => {
-                self.crypto_provider.verify_ed25519(
-                    &attestation.public_key,
-                    &message,
-                    &attestation.signature,
-                )?;
-            }
-            SignatureScheme::Dilithium2 => {
-                self.crypto_provider.verify_dilithium2(
-                    &attestation.public_key,
-                    &message,
-                    &attestation.signature,
-                )?;
-            }
-            SignatureScheme::Falcon512 => {
-                self.crypto_provider.verify_falcon512(
-                    &attestation.public_key,
-                    &message,
-                    &attestation.signature,
-                )?;
-            }
-            _ => {
-                return Err(AttestationError::UnsupportedScheme(
-                    attestation.metadata.signature_scheme,
-                ))
-            }
-        }
-
-        // Verify merkle root matches expected manifest
-        self.verify_merkle_root_integrity(
-            &attestation.merkle_root,
-            &container_info.expected_manifest,
-        )?;
-
-        Ok(())
-    }
-
-    /// Batch verification for efficiency when possible
-    pub async fn verify_attestation_batch(
-        &self,
-        attestations: &[ContainerAttestation],
-    ) -> Result<Vec<Result<(), AttestationError>>, Error> {
-        // Group by signature scheme for batch verification
-        let mut by_scheme: HashMap<SignatureScheme, Vec<&ContainerAttestation>> = HashMap::new();
-
-        for attestation in attestations {
-            by_scheme
-                .entry(attestation.metadata.signature_scheme)
-                .or_default()
-                .push(attestation);
-        }
-
-        let mut results = Vec::with_capacity(attestations.len());
-
-        // Batch verify each scheme group
-        for (scheme, group) in by_scheme {
-            match scheme {
-                SignatureScheme::Ed25519 => {
-                    // Ed25519 supports efficient batch verification
-                    let batch_results = self.batch_verify_ed25519(group).await?;
-                    results.extend(batch_results);
-                }
-                _ => {
-                    // Other schemes: verify individually
-                    for attestation in group {
-                        results.push(self.verify_attestation(attestation).await);
-                    }
-                }
-            }
-        }
-
-        Ok(results)
-    }
-}
-
-/// Attestation monitoring and health tracking
-#[derive(Debug)]
-pub struct AttestationHealth {
-    pub success_rate: f64,
-    pub average_latency: Duration,
-    pub failed_containers: Vec<ContainerId>,
-    pub last_rotation: Option<(SignatureScheme, Timestamp)>,
-}
-
-impl AttestationManager {
-    /// Gets current attestation health metrics
-    pub async fn get_health(&self) -> AttestationHealth {
-        let history = self.history.read().await;
-
-        AttestationHealth {
-            success_rate: history.calculate_success_rate(),
-            average_latency: history.calculate_average_latency(),
-            failed_containers: history.get_failed_containers(),
-            last_rotation: history.get_last_rotation(),
-        }
-    }
-}
-
-/// Errors specific to attestation
-#[derive(Debug, thiserror::Error)]
-pub enum AttestationError {
-    #[error("Unsupported signature scheme: {0:?}")]
-    UnsupportedScheme(SignatureScheme),
-
-    #[error("Stale attestation (age: {age:?})")]
-    StaleAttestation { age: Duration },
-
-    #[error("Clock skew detected")]
-    ClockSkew,
-
-    #[error("Unknown container")]
-    UnknownContainer,
-
-    #[error("Merkle root mismatch")]
-    MerkleRootMismatch,
-
-    #[error("Chain state error: {0}")]
-    ChainStateError(#[from] ChainStateError),
-
-    #[error("Cryptographic error: {0}")]
-    CryptoError(#[from] CryptoError),
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[tokio::test]
-    async fn test_attestation_follows_chain_rotation() {
-        // Setup
-        let chain_state = Arc::new(mock_chain_state());
-        let crypto_provider = Arc::new(CryptoProvider::new());
-        let manager = AttestationManager::new(chain_state.clone(), crypto_provider);
-
-        // Initially using Ed25519
-        chain_state
-            .set_active_scheme(SignatureScheme::Ed25519)
-            .await;
-
-        // Create attestation with Ed25519
-        let attestation1 = manager
-            .create_attestation(b"nonce1", &measurements())
-            .await?;
-        assert_eq!(
-            attestation1.metadata.signature_scheme,
-            SignatureScheme::Ed25519
-        );
-
-        // Chain rotates to Dilithium2
-        chain_state
-            .set_active_scheme(SignatureScheme::Dilithium2)
-            .await;
-        manager
-            .handle_signature_rotation(SignatureScheme::Dilithium2)
-            .await?;
-
-        // New attestation uses Dilithium2
-        let attestation2 = manager
-            .create_attestation(b"nonce2", &measurements())
-            .await?;
-        assert_eq!(
-            attestation2.metadata.signature_scheme,
-            SignatureScheme::Dilithium2
-        );
-
-        // Both attestations can be verified
-        let verifier = AttestationVerifier::new(chain_state, crypto_provider);
-        verifier.verify_attestation(&attestation1).await?;
-        verifier.verify_attestation(&attestation2).await?;
-    }
-}
-```
-
-####### File: validator/src/common/guardian.rs
-####*Size: 4.0K, Lines: 63, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/common/guardian.rs
-
-use async_trait::async_trait;
-use depin_sdk_core::error::ValidatorError;
-use depin_sdk_core::validator::{Container, GuardianContainer as GuardianContainerTrait};
-use std::path::Path;
-// FIX: Add imports for atomic state management
-use std::sync::{
-    atomic::{AtomicBool, Ordering},
-    Arc,
-};
-
-#[derive(Debug, Default)]
-pub struct GuardianContainer {
-    // FIX: Use Arc<AtomicBool> for thread-safe interior mutability.
-    running: Arc<AtomicBool>,
-}
-
-impl GuardianContainer {
-    pub fn new(_config_path: &Path) -> anyhow::Result<Self> {
-        // FIX: Initialize the atomic bool correctly.
-        Ok(Self {
-            running: Arc::new(AtomicBool::new(false)),
-        })
-    }
-}
-
-#[async_trait]
-impl Container for GuardianContainer {
-    async fn start(&self) -> Result<(), ValidatorError> {
-        log::info!("Starting GuardianContainer...");
-        // FIX: Atomically set the running flag to true.
-        self.running.store(true, Ordering::SeqCst);
-        Ok(())
-    }
-
-    async fn stop(&self) -> Result<(), ValidatorError> {
-        log::info!("Stopping GuardianContainer...");
-        // FIX: Atomically set the running flag to false.
-        self.running.store(false, Ordering::SeqCst);
-        Ok(())
-    }
-
-    fn is_running(&self) -> bool {
-        // FIX: Atomically load the value of the running flag.
-        self.running.load(Ordering::SeqCst)
-    }
-
-    fn id(&self) -> &'static str {
-        "guardian"
-    }
-}
-
-impl GuardianContainerTrait for GuardianContainer {
-    fn start_boot(&self) -> Result<(), ValidatorError> {
-        log::info!("Guardian: Initiating secure boot sequence...");
-        Ok(())
-    }
-
-    fn verify_attestation(&self) -> Result<bool, ValidatorError> {
-        log::info!("Guardian: Verifying inter-container attestation...");
-        Ok(true)
-    }
-}```
-
-####### File: validator/src/common/mod.rs
-####*Size: 4.0K, Lines: 10, Type: ASCII text*
-
-```rust
-//! Common validator components shared by all types
-
-mod guardian;
-mod security;
-
-#[cfg(test)]
-mod tests;
-
-pub use guardian::*;
-pub use security::*;
-```
-
-####### File: validator/src/common/security.rs
-####*Size: 4.0K, Lines: 55, Type: ASCII text*
-
-```rust
-//! Implementation of security boundaries between containers
-
-use std::error::Error;
-
-/// Security channel for communication between containers
-pub struct SecurityChannel {
-    /// Source container ID
-    pub source: String,
-    /// Destination container ID
-    pub destination: String,
-    /// Channel ID
-    pub channel_id: String,
-}
-
-impl SecurityChannel {
-    /// Create a new security channel
-    pub fn new(source: &str, destination: &str) -> Self {
-        let channel_id = format!("{}:{}", source, destination);
-        
-        Self {
-            source: source.to_string(),
-            destination: destination.to_string(),
-            channel_id,
-        }
-    }
-    
-    /// Establish the security channel
-    pub fn establish(&self) -> Result<(), Box<dyn Error + Send + Sync>> {
-        // Simplified channel establishment for initial setup
-        // In a real implementation, we would:
-        // 1. Perform mutual authentication
-        // 2. Establish encrypted channel
-        // 3. Set up access controls
-        
-        println!("Establishing security channel: {}", self.channel_id);
-        
-        Ok(())
-    }
-    
-    /// Send data through the security channel
-    pub fn send(&self, data: &[u8]) -> Result<(), Box<dyn Error + Send + Sync>> {
-        // Simplified sending for initial setup
-        println!("Sending {} bytes through channel {}", data.len(), self.channel_id);
-        
-        Ok(())
-    }
-    
-    /// Receive data from the security channel
-    pub fn receive(&self, max_size: usize) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
-        // Simplified receiving for initial setup
-        println!("Receiving up to {} bytes from channel {}", max_size, self.channel_id);
-        
-        // Return empty data for now
-        Ok(Vec::new())
-    }
-}```
-
-###### Directory: validator/src/hybrid
-
-####### Directory: validator/src/hybrid/tests
-
-######## File: validator/src/hybrid/tests/mod.rs
-#####*Size: 4.0K, Lines: 63, Type: ASCII text*
-
-```rust
-//! Tests for hybrid validator components
-
-#[cfg(test)]
-mod tests {
-    use super::super::{ApiContainer, HybridValidator, InterfaceContainer};
-    use std::net::SocketAddr;
-    use std::path::Path;
-
-    #[test]
-    fn test_interface_container() {
-        let config_path = Path::new("test_interface.toml");
-        let interface = InterfaceContainer::new(config_path);
-
-        assert!(!interface.is_running());
-
-        interface.start().unwrap();
-        // Note: in the current implementation, the running state isn't actually updated
-
-        // Test connection handling
-        let addr: SocketAddr = "127.0.0.1:8080".parse().unwrap();
-        let data = vec![1, 2, 3, 4];
-        let result = interface.handle_connection(addr, &data).unwrap();
-        assert_eq!(result, vec![5, 6, 7, 8]); // Should return the mock result defined in the implementation
-
-        interface.stop().unwrap();
-    }
-
-    #[test]
-    fn test_api_container() {
-        let config_path = Path::new("test_api.toml");
-        let api = ApiContainer::new(config_path);
-
-        assert!(!api.is_running());
-
-        api.start().unwrap();
-        // Note: in the current implementation, the running state isn't actually updated
-
-        // Test API request handling
-        let endpoint = "test_endpoint";
-        let params = vec![1, 2, 3, 4];
-        let result = api.handle_request(endpoint, &params).unwrap();
-        assert_eq!(result, vec![9, 10, 11, 12]); // Should return the mock result defined in the implementation
-
-        api.stop().unwrap();
-    }
-
-    #[test]
-    fn test_hybrid_validator() {
-        let temp_dir = std::env::temp_dir();
-
-        // This is just a test, so we're not actually creating these files
-        // In a real test, we might want to create temporary config files
-
-        // Create validator
-        let validator = HybridValidator::new(&temp_dir).unwrap();
-
-        // Start validator - this should start all containers
-        validator.start().unwrap();
-
-        // Stop validator - this should stop all containers
-        validator.stop().unwrap();
-    }
-}
-```
-
-####### File: validator/src/hybrid/api.rs
-####*Size: 4.0K, Lines: 63, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/hybrid/api.rs
-
-use depin_sdk_core::error::ValidatorError;
-use depin_sdk_core::validator::Container;
-use serde::Deserialize;
-use std::path::Path;
-// FIX: Add imports for atomic state management
-use std::sync::{
-    atomic::{AtomicBool, Ordering},
-    Arc,
-};
-use toml;
-
-/// Configuration for the API container, loaded from `api.toml`.
-#[derive(Deserialize)]
-pub struct ApiConfig {
-    pub listen_address: String,
-    pub enabled_endpoints: Vec<String>,
-}
-
-/// The ApiContainer is responsible for implementing the public-facing JSON-RPC
-/// or other state-query APIs for a hybrid validator.
-pub struct ApiContainer {
-    config: ApiConfig,
-    // FIX: Use Arc<AtomicBool> for thread-safe state.
-    running: Arc<AtomicBool>,
-}
-
-impl ApiContainer {
-    pub fn new(config_path: &Path) -> anyhow::Result<Self> {
-        let config_str = std::fs::read_to_string(config_path)?;
-        let config: ApiConfig = toml::from_str(&config_str)?;
-        Ok(Self {
-            config,
-            running: Arc::new(AtomicBool::new(false)),
-        })
-    }
-}
-
-#[async_trait::async_trait]
-impl Container for ApiContainer {
-    async fn start(&self) -> Result<(), ValidatorError> {
-        log::info!(
-            "Starting ApiContainer, listening on {}...",
-            self.config.listen_address
-        );
-        self.running.store(true, Ordering::SeqCst);
-        Ok(())
-    }
-
-    async fn stop(&self) -> Result<(), ValidatorError> {
-        log::info!("Stopping ApiContainer...");
-        self.running.store(false, Ordering::SeqCst);
-        Ok(())
-    }
-
-    fn is_running(&self) -> bool {
-        self.running.load(Ordering::SeqCst)
-    }
-
-    fn id(&self) -> &'static str {
-        "api"
-    }
-}```
-
-####### File: validator/src/hybrid/interface.rs
-####*Size: 4.0K, Lines: 63, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/hybrid/interface.rs
-
-use depin_sdk_core::error::ValidatorError;
-use depin_sdk_core::validator::Container;
-use serde::Deserialize;
-use std::path::Path;
-// FIX: Add imports for atomic state management
-use std::sync::{
-    atomic::{AtomicBool, Ordering},
-    Arc,
-};
-use toml;
-
-/// Configuration for the Interface container, loaded from `interface.toml`.
-#[derive(Deserialize)]
-pub struct InterfaceConfig {
-    pub max_connections: u32,
-    pub rate_limit_per_second: u64,
-}
-
-/// The InterfaceContainer manages raw network connections, protocol routing,
-/// and basic DDoS protection for a hybrid validator's public-facing services.
-pub struct InterfaceContainer {
-    config: InterfaceConfig,
-    // FIX: Use Arc<AtomicBool> for thread-safe state.
-    running: Arc<AtomicBool>,
-}
-
-impl InterfaceContainer {
-    pub fn new(config_path: &Path) -> anyhow::Result<Self> {
-        let config_str = std::fs::read_to_string(config_path)?;
-        let config: InterfaceConfig = toml::from_str(&config_str)?;
-        Ok(Self {
-            config,
-            running: Arc::new(AtomicBool::new(false)),
-        })
-    }
-}
-
-#[async_trait::async_trait]
-impl Container for InterfaceContainer {
-    async fn start(&self) -> Result<(), ValidatorError> {
-        log::info!(
-            "Starting InterfaceContainer with max {} connections...",
-            self.config.max_connections
-        );
-        self.running.store(true, Ordering::SeqCst);
-        Ok(())
-    }
-
-    async fn stop(&self) -> Result<(), ValidatorError> {
-        log::info!("Stopping InterfaceContainer...");
-        self.running.store(false, Ordering::SeqCst);
-        Ok(())
-    }
-
-    fn is_running(&self) -> bool {
-        self.running.load(Ordering::SeqCst)
-    }
-
-    fn id(&self) -> &'static str {
-        "interface"
-    }
-}```
-
-####### File: validator/src/hybrid/mod.rs
-####*Size: 4.0K, Lines: 7, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/hybrid/mod.rs
-
-pub mod api;
-pub mod interface;
-
-// FIX: Publicly re-export the containers so they are visible to binaries.
-pub use api::ApiContainer;
-pub use interface::InterfaceContainer;```
-
-###### Directory: validator/src/standard
-
-####### Directory: validator/src/standard/tests
-
-######## File: validator/src/standard/tests/mod.rs
-#####*Size: 4.0K, Lines: 57, Type: ASCII text*
-
-```rust
-//! Tests for standard validator components
-
-#[cfg(test)]
-mod tests {
-    use super::super::{OrchestrationContainer, StandardValidator, WorkloadContainer};
-    use crate::common::GuardianContainer;
-    use std::path::Path;
-
-    #[test]
-    fn test_orchestration_container() {
-        let config_path = Path::new("test_orchestration.toml");
-        let orchestration = OrchestrationContainer::new(config_path);
-
-        assert!(!orchestration.is_running());
-
-        orchestration.start().unwrap();
-        // Note: in the current implementation, the running state isn't actually updated
-        // In a real implementation, we'd expect is_running() to return true here
-
-        orchestration.stop().unwrap();
-    }
-
-    #[test]
-    fn test_workload_container() {
-        let config_path = Path::new("test_workload.toml");
-        let workload = WorkloadContainer::new(config_path);
-
-        assert!(!workload.is_running());
-
-        workload.start().unwrap();
-        // Note: in the current implementation, the running state isn't actually updated
-
-        // Test transaction execution
-        let tx_data = vec![1, 2, 3, 4];
-        let result = workload.execute_transaction(&tx_data).unwrap();
-        assert_eq!(result, vec![1, 2, 3, 4]); // Should return the mock result defined in the implementation
-
-        workload.stop().unwrap();
-    }
-
-    #[test]
-    fn test_standard_validator() {
-        let temp_dir = std::env::temp_dir();
-
-        // This is just a test, so we're not actually creating these files
-        // In a real test, we might want to create temporary config files
-
-        // Create validator
-        let validator = StandardValidator::new(&temp_dir).unwrap();
-
-        // Start validator - this should start all containers
-        validator.start().unwrap();
-
-        // Stop validator - this should stop all containers
-        validator.stop().unwrap();
-    }
-}
-```
-
-####### File: validator/src/standard/mod.rs
-####*Size: 4.0K, Lines: 6, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/standard/mod.rs
-
-pub mod orchestration;
-pub mod workload;
-
-// FIX: Publicly re-export the container so it's visible to binaries in the same crate.
-pub use orchestration::OrchestrationContainer;```
-
-####### File: validator/src/standard/orchestration.rs
-####*Size: 12K, Lines: 273, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/standard/orchestration.rs
-
-use crate::config::OrchestrationConfig;
-use async_trait::async_trait;
-use depin_sdk_core::{
-    chain::SovereignChain,
-    commitment::CommitmentScheme,
-    error::ValidatorError,
-    state::{StateManager, StateTree},
-    transaction::TransactionModel,
-    validator::{Container, WorkloadContainer},
-};
-use futures::StreamExt;
-use libp2p::{
-    core::upgrade, gossipsub, identity, noise, swarm::SwarmEvent, tcp, yamux, Swarm,
-    SwarmBuilder, Transport,
-};
-use std::fmt::Debug;
-use std::sync::{
-    atomic::{AtomicBool, Ordering},
-    Arc,
-};
-use tokio::{
-    sync::{watch, Mutex, OnceCell},
-    task::JoinHandle,
-    time::{self, Duration},
-};
-
-pub struct OrchestrationContainer<CS, TM, ST>
-where
-    CS: CommitmentScheme + Send + Sync + 'static,
-    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-    TM::Transaction: Clone + Debug + Send + Sync,
-    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
-{
-    _config: OrchestrationConfig,
-    chain: Arc<OnceCell<Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>>>,
-    workload: Arc<OnceCell<Arc<WorkloadContainer<ST>>>>,
-    swarm: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-    shutdown_sender: Arc<watch::Sender<bool>>,
-    task_handles: Arc<Mutex<Vec<JoinHandle<()>>>>,
-    is_running: Arc<AtomicBool>,
-}
-
-impl<CS, TM, ST> OrchestrationContainer<CS, TM, ST>
-where
-    CS: CommitmentScheme + Send + Sync + 'static,
-    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-    TM::Transaction: Clone + Debug + Send + Sync,
-    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-        + Send
-        + Sync
-        + 'static
-        + Debug,
-    CS::Commitment: Send + Sync + Debug,
-{
-    pub async fn new(config_path: &std::path::Path) -> anyhow::Result<Self> {
-        let _config: OrchestrationConfig =
-            toml::from_str(&std::fs::read_to_string(config_path)?)?;
-
-        let (shutdown_sender, _) = watch::channel(false);
-
-        let local_key = identity::Keypair::generate_ed25519();
-
-        let swarm = SwarmBuilder::with_existing_identity(local_key)
-            .with_tokio()
-            .with_other_transport(|key| {
-                let noise_config = noise::Config::new(key)
-                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
-                let transport = tcp::tokio::Transport::new(tcp::Config::default())
-                    .upgrade(upgrade::Version::V1Lazy)
-                    .authenticate(noise_config)
-                    .multiplex(yamux::Config::default())
-                    .timeout(std::time::Duration::from_secs(20))
-                    .boxed();
-                Ok(transport)
-            })?
-            .with_behaviour(|key| {
-                let gossipsub_config = gossipsub::Config::default();
-                gossipsub::Behaviour::new(
-                    gossipsub::MessageAuthenticity::Signed(key.clone()),
-                    gossipsub_config,
-                )
-                .expect("Valid gossipsub config")
-            })?
-            .build();
-
-        Ok(Self {
-            _config,
-            chain: Arc::new(OnceCell::new()),
-            workload: Arc::new(OnceCell::new()),
-            swarm: Arc::new(Mutex::new(swarm)),
-            shutdown_sender: Arc::new(shutdown_sender),
-            task_handles: Arc::new(Mutex::new(Vec::new())),
-            is_running: Arc::new(AtomicBool::new(false)),
-        })
-    }
-
-    pub fn set_chain_and_workload_ref(
-        &self,
-        chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
-        workload_ref: Arc<WorkloadContainer<ST>>,
-    ) {
-        self.chain.set(chain_ref).expect("Chain ref already set");
-        self.workload
-            .set(workload_ref)
-            .expect("Workload ref already set");
-    }
-
-    async fn run_event_loop(
-        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-        mut shutdown_receiver: watch::Receiver<bool>,
-    ) {
-        loop {
-            tokio::select! {
-                biased;
-                _ = shutdown_receiver.changed() => {
-                    if *shutdown_receiver.borrow() {
-                        log::info!("Orchestration event loop received shutdown signal.");
-                        break;
-                    }
-                },
-                event = async { swarm_ref.lock().await.select_next_some().await } => {
-                     match event {
-                        SwarmEvent::Behaviour(gossipsub::Event::Message { message, .. }) => {
-                            log::info!(
-                                "Received block gossip from peer {:?}: '{}'",
-                                message.source,
-                                String::from_utf8_lossy(&message.data)
-                            );
-                        }
-                        SwarmEvent::NewListenAddr { address, .. } => {
-                            log::info!("OrchestrationContainer now listening on {}", address);
-                        }
-                        SwarmEvent::ConnectionEstablished { peer_id, .. } => {
-                            log::info!("Connection established with peer: {:?}", peer_id);
-                        }
-                        _ => {}
-                    }
-                }
-            }
-        }
-    }
-
-    async fn run_block_production(
-        chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
-        workload_ref: Arc<WorkloadContainer<ST>>,
-        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-        is_running: Arc<AtomicBool>,
-    ) {
-        let mut interval = time::interval(Duration::from_secs(10));
-        while is_running.load(Ordering::SeqCst) {
-            interval.tick().await;
-
-            let new_block;
-            {
-                let mut chain = chain_ref.lock().await;
-                let tm = chain.transaction_model().clone();
-                let coinbase_result = tm
-                    .create_coinbase_transaction(chain.status().height + 1, &[]);
-                
-                let coinbase = match coinbase_result {
-                    Ok(tx) => tx,
-                    Err(e) => {
-                        log::error!("Failed to create coinbase transaction: {:?}", e);
-                        continue;
-                    }
-                };
-
-                new_block = chain.create_block(vec![coinbase], &workload_ref);
-
-                if let Err(e) = chain
-                    .process_block(new_block.clone(), &workload_ref)
-                    .await
-                {
-                    log::error!("Failed to process new block: {:?}", e);
-                    continue;
-                }
-                log::info!("Produced and processed new block #{}", new_block.header.height);
-            }
-            
-            // --- FIX: Decouple network publishing from the main loop ---
-            // Spawn a separate task to handle the potentially slow network I/O.
-            // This prevents the main block production loop from ever getting stuck.
-            let swarm_clone = swarm_ref.clone();
-            tokio::spawn(async move {
-                let mut swarm = swarm_clone.lock().await;
-                let topic = gossipsub::IdentTopic::new("blocks");
-                let message_data = serde_json::to_vec(&new_block.header).unwrap_or_default();
-
-                if let Err(e) = swarm.behaviour_mut().publish(topic, message_data) {
-                    log::warn!("Failed to publish block (likely no peers): {:?}", e);
-                }
-            });
-        }
-        log::info!("Orchestration block production loop finished.");
-    }
-}
-
-#[async_trait]
-impl<CS, TM, ST> Container for OrchestrationContainer<CS, TM, ST>
-where
-    CS: CommitmentScheme + Send + Sync + 'static,
-    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-    TM::Transaction: Clone + Debug + Send + Sync,
-    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-        + Send
-        + Sync
-        + 'static
-        + Debug,
-    CS::Commitment: Send + Sync + Debug,
-{
-    fn id(&self) -> &'static str {
-        "orchestration_container"
-    }
-
-    fn is_running(&self) -> bool {
-        self.is_running.load(Ordering::SeqCst)
-    }
-
-    async fn start(&self) -> Result<(), ValidatorError> {
-        if self.is_running() {
-            return Err(ValidatorError::AlreadyRunning(self.id().to_string()));
-        }
-        log::info!("OrchestrationContainer starting...");
-        self.is_running.store(true, Ordering::SeqCst);
-        
-        let mut handles = self.task_handles.lock().await;
-
-        let event_loop_receiver = self.shutdown_sender.subscribe();
-        let swarm_clone = self.swarm.clone();
-        handles.push(tokio::spawn(async move {
-            Self::run_event_loop(swarm_clone, event_loop_receiver).await;
-        }));
-
-        let chain_clone = self.chain.get().unwrap().clone();
-        let workload_clone = self.workload.get().unwrap().clone();
-        let swarm_clone_2 = self.swarm.clone();
-        let is_running_clone = self.is_running.clone();
-
-        handles.push(tokio::spawn(async move {
-            Self::run_block_production(
-                chain_clone,
-                workload_clone,
-                swarm_clone_2,
-                is_running_clone,
-            )
-            .await;
-        }));
-
-        Ok(())
-    }
-
-    async fn stop(&self) -> Result<(), ValidatorError> {
-        if !self.is_running() {
-            return Ok(());
-        }
-        log::info!("OrchestrationContainer stopping...");
-        self.is_running.store(false, Ordering::SeqCst);
-        
-        self.shutdown_sender.send(true).map_err(|e| {
-            ValidatorError::Other(format!("Failed to send shutdown signal: {}", e))
-        })?;
-
-        let mut handles = self.task_handles.lock().await;
-        for handle in handles.drain(..) {
-            handle.await.map_err(|e| ValidatorError::Other(format!("Task panicked during shutdown: {}", e)))?;
-        }
-
-        Ok(())
-    }
-}```
-
-####### File: validator/src/standard/workload.rs
-####*Size: 4.0K, Lines: 50, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/standard/workload.rs
-
-use crate::traits::WorkloadLogic;
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::error::ValidatorError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use depin_sdk_core::transaction::TransactionModel;
-use depin_sdk_core::validator::WorkloadContainer;
-
-impl<ST> WorkloadLogic<ST> for WorkloadContainer<ST>
-where
-    // FIX: The bound must be StateManager (which implies StateTree) and Sized.
-    ST: StateManager + Send + Sync,
-{
-    fn execute_transaction<CS, TM>(
-        &self,
-        tx: &TM::Transaction,
-        model: &TM,
-    ) -> impl std::future::Future<Output = Result<(), ValidatorError>> + Send
-    where
-        CS: CommitmentScheme<
-            Commitment = <ST as StateTree>::Commitment,
-            Proof = <ST as StateTree>::Proof,
-        >,
-        TM: TransactionModel<CommitmentScheme = CS> + Sync,
-        TM::Transaction: Sync,
-        // FIX: The bound `ST: StateManager` is now satisfied by the impl block's bounds.
-        ST: StateManager,
-    {
-        async move {
-            let state_tree_arc = self.state_tree();
-            let mut state = state_tree_arc.lock().await;
-
-            let is_valid = model
-                .validate(tx, &*state)
-                .map_err(|e| ValidatorError::Other(e.to_string()))?;
-            if !is_valid {
-                return Err(ValidatorError::Other(
-                    "Transaction validation failed".to_string(),
-                ));
-            }
-
-            model
-                .apply(tx, &mut *state)
-                .map_err(|e| ValidatorError::Other(e.to_string()))?;
-
-            log::info!("Successfully executed transaction and updated state.");
-            Ok(())
-        }
-    }
-}```
-
-###### Directory: validator/src/traits
-
-####### File: validator/src/traits/mod.rs
-####*Size: 4.0K, Lines: 25, Type: ASCII text*
-
-```rust
-// Path: crates/validator/src/traits/mod.rs
-
-use depin_sdk_core::commitment::CommitmentScheme;
-use depin_sdk_core::error::ValidatorError;
-use depin_sdk_core::state::{StateManager, StateTree};
-use depin_sdk_core::transaction::TransactionModel;
-use std::future::Future;
-
-/// Defines the logic for a workload execution container.
-pub trait WorkloadLogic<ST: StateTree + ?Sized> {
-    /// Executes a single transaction, validating it and applying it to the state tree.
-    fn execute_transaction<CS, TM>(
-        &self,
-        tx: &TM::Transaction,
-        model: &TM,
-    ) -> impl Future<Output = Result<(), ValidatorError>> + Send
-    where
-        CS: CommitmentScheme<
-            Commitment = <ST as StateTree>::Commitment,
-            Proof = <ST as StateTree>::Proof,
-        >,
-        // FIX: Add Sync bounds to ensure thread safety for captured references.
-        TM: TransactionModel<CommitmentScheme = CS> + Sync,
-        TM::Transaction: Sync,
-        ST: StateManager;
-}```
-
-###### File: validator/src/config.rs
-###*Size: 4.0K, Lines: 49, Type: ASCII text*
-
-```rust
-//! Configuration structures for validator containers.
-
-use serde::Deserialize;
-
-/// Configuration for the Guardian container (`guardian.toml`).
-#[derive(Debug, Deserialize)]
-pub struct GuardianConfig {
-    pub signature_policy: AttestationSignaturePolicy,
-}
-
-#[derive(Debug, Deserialize)]
-#[serde(rename_all = "PascalCase")]
-pub enum AttestationSignaturePolicy {
-    FollowChain,
-    Fixed,
-}
-
-/// Configuration for the Orchestration container (`orchestration.toml`).
-#[derive(Debug, Deserialize)]
-pub struct OrchestrationConfig {
-    pub consensus_type: ConsensusType,
-}
-
-#[derive(Debug, Deserialize)]
-#[serde(rename_all = "PascalCase")]
-pub enum ConsensusType {
-    ProofOfStake,
-    ProofOfWork,
-    ProofOfAuthority,
-}
-
-/// Configuration for the Workload container (`workload.toml`).
-#[derive(Debug, Deserialize)]
-pub struct WorkloadConfig {
-    pub enabled_vms: Vec<String>,
-}
-
-/// Configuration for the Interface container (`interface.toml`).
-#[derive(Debug, Deserialize)]
-pub struct InterfaceConfig {
-    pub listen_address: String,
-    pub max_connections: u32,
-}
-
-/// Configuration for the API container (`api.toml`).
-#[derive(Debug, Deserialize)]
-pub struct ApiConfig {
-    pub listen_address: String,
-    pub enabled_endpoints: Vec<String>,
-}```
-
-###### File: validator/src/lib.rs
-###*Size: 4.0K, Lines: 12, Type: ASCII text*
-
-```rust
-//! # DePIN SDK Validator
-//!
-//! Validator implementation with container architecture for the DePIN SDK.
-
-pub mod config;
-pub mod common;
-pub mod standard;
-pub mod hybrid;
-// NEW: Public traits for this crate are defined here.
-pub mod traits;
-
-// Re-export the new public trait.
-pub use traits::WorkloadLogic;```
-
-##### File: validator/Cargo.toml
-##*Size: 4.0K, Lines: 44, Type: ASCII text*
-
-```toml
-# Path: crates/validator/Cargo.toml
-
-[package]
-name = "depin-sdk-validator"
-version = "0.1.0"
-edition = "2021"
-description = "Validator container implementations for the DePIN SDK"
-license = "MIT OR Apache-2.0"
-
-[dependencies]
-depin-sdk-core = { path = "../core" }
-log = { workspace = true }
-anyhow = { workspace = true }
-serde = { workspace = true, features = ["derive"] }
-serde_json = { workspace = true }
-# FIX: The `sync` feature is required for tokio::sync::watch
-tokio = { workspace = true, features = ["full", "sync"] }
-libp2p = { workspace = true }
-futures = { workspace = true }
-async-trait = { workspace = true }
-toml = { workspace = true }
-clap = { workspace = true, features = ["derive"], optional = true }
-env_logger = { workspace = true, optional = true }
-depin-sdk-state-trees = { path = "../state_trees", optional = true }
-depin-sdk-commitment-schemes = { path = "../commitment_schemes", optional = true }
-
-[features]
-default = []
-validator-bins = [
-    "dep:clap",
-    "dep:env_logger",
-    "dep:depin-sdk-state-trees",
-    "dep:depin-sdk-commitment-schemes",
-]
-
-[[bin]]
-name = "validator"
-path = "src/bin/validator.rs"
-required-features = ["validator-bins"]
-
-[[bin]]
-name = "validator_hybrid"
-path = "src/bin/validator_hybrid.rs"
-required-features = ["validator-bins"]
-```
-
diff --git a/crates/chain/src/app/mod.rs b/crates/chain/src/app/mod.rs
index b778c64..dd27384 100644
--- a/crates/chain/src/app/mod.rs
+++ b/crates/chain/src/app/mod.rs
@@ -7,23 +7,20 @@ use async_trait::async_trait;
 use depin_sdk_core::app::{Block, BlockHeader, ChainError, ChainStatus, SovereignAppChain};
 use depin_sdk_core::chain::SovereignChain;
 use depin_sdk_core::commitment::CommitmentScheme;
-// REMOVED: Unused import `StateError`
 use depin_sdk_core::services::UpgradableService;
-// REMOVED: Unused import `StateTree`
 use depin_sdk_core::state::StateManager;
 use depin_sdk_core::transaction::TransactionModel;
 use depin_sdk_core::validator::WorkloadContainer;
 use depin_sdk_validator::traits::WorkloadLogic;
+use libp2p::PeerId;
+use std::collections::HashSet;
 use std::fmt::Debug;
 use std::sync::Arc;
 use std::time::{SystemTime, UNIX_EPOCH};
 
-// Define a well-known key for storing the chain status in the state tree.
 const STATUS_KEY: &[u8] = b"chain::status";
+const VALIDATOR_SET_KEY: &[u8] = b"system::validators";
 
-/// A container struct that holds the chain's data (`SovereignAppChain`) and its
-/// associated logic managers (`ModuleUpgradeManager`).
-/// This struct implements the `SovereignChain` trait.
 #[derive(Debug)]
 pub struct ChainLogic<CS, TM: TransactionModel> {
     app_chain: SovereignAppChain<CS, TM>,
@@ -36,31 +33,22 @@ where
     CS: CommitmentScheme,
     TM: TransactionModel<CommitmentScheme = CS>,
 {
-    /// The `new` constructor is an inherent method on the logic struct,
-    /// which allows the `SovereignChain` trait to be object-safe.
     pub fn new(
         commitment_scheme: CS,
         transaction_model: TM,
         chain_id: &str,
         initial_services: Vec<Arc<dyn UpgradableService>>,
     ) -> Self {
-        // This now creates a default/genesis status, which will be overwritten
-        // by load_or_initialize_status if state exists.
         let status = ChainStatus {
             height: 0,
-            latest_timestamp: SystemTime::now()
-                .duration_since(UNIX_EPOCH)
-                .unwrap()
-                .as_secs(),
+            latest_timestamp: 0,
             total_transactions: 0,
             is_running: false,
         };
-
         let mut service_manager = ModuleUpgradeManager::new();
         for service in initial_services {
             service_manager.register_service(service);
         }
-
         let app_chain = SovereignAppChain {
             commitment_scheme,
             transaction_model,
@@ -69,14 +57,12 @@ where
             recent_blocks: Vec::new(),
             max_recent_blocks: 100,
         };
-
         Self {
             app_chain,
             service_manager,
         }
     }
 
-    /// [NEW METHOD] Loads chain status from the state manager, or initializes it if not found.
     pub async fn load_or_initialize_status<ST>(
         &mut self,
         workload: &WorkloadContainer<ST>,
@@ -84,10 +70,8 @@ where
     where
         ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
     {
-        // FIX: Create a longer-lived binding for the Arc<Mutex> to solve the lifetime error.
         let state_tree = workload.state_tree();
         let mut state = state_tree.lock().await;
-
         match state.get(STATUS_KEY) {
             Ok(Some(status_bytes)) => {
                 let status: ChainStatus = serde_json::from_slice(&status_bytes)
@@ -108,7 +92,6 @@ where
     }
 }
 
-/// Implements the `dyn`-safe `SovereignChain` trait for the `ChainLogic` struct.
 #[async_trait]
 impl<CS, TM, ST> SovereignChain<CS, TM, ST> for ChainLogic<CS, TM>
 where
@@ -126,69 +109,82 @@ where
         &self.app_chain.transaction_model
     }
 
-    /// Processes a transaction by delegating execution to the WorkloadContainer.
     async fn process_transaction(
         &mut self,
         tx: &TM::Transaction,
         workload: &WorkloadContainer<ST>,
     ) -> Result<(), ChainError> {
         workload
-            .execute_transaction(
-                tx,
-                <Self as SovereignChain<CS, TM, ST>>::transaction_model(self),
-            )
+            .execute_transaction(tx, &self.app_chain.transaction_model)
             .await
             .map_err(|e| ChainError::Transaction(e.to_string()))?;
-
         self.app_chain.status.total_transactions += 1;
         Ok(())
     }
 
-    /// Processes a full block by iterating through its transactions and delegating
-    /// each one to the WorkloadContainer for execution.
     async fn process_block(
         &mut self,
         mut block: Block<TM::Transaction>,
         workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError> {
+    ) -> Result<Block<TM::Transaction>, ChainError> {
         if block.header.height != self.app_chain.status.height + 1 {
-            return Err(ChainError::Block("Invalid block height".to_string()));
+            return Err(ChainError::Block(format!(
+                "Invalid block height. Expected {}, got {}",
+                self.app_chain.status.height + 1,
+                block.header.height
+            )));
+        }
+        let expected_prev_hash = self
+            .app_chain
+            .recent_blocks
+            .last()
+            .map_or(vec![0; 32], |b| b.header.state_root.clone());
+        if block.header.prev_hash != expected_prev_hash {
+            return Err(ChainError::Block(format!(
+                "Invalid prev_hash for block {}. Expected {}, got {}",
+                block.header.height,
+                hex::encode(&expected_prev_hash),
+                hex::encode(&block.header.prev_hash)
+            )));
         }
-
         for tx in &block.transactions {
             self.process_transaction(tx, workload).await?;
         }
-
-        // After all transactions are processed, get the final state root from the workload container.
-        let state_root =
-            workload.state_tree().lock().await.root_commitment();
-        block.header.state_root = state_root.as_ref().to_vec();
-
         self.app_chain.status.height = block.header.height;
         self.app_chain.status.latest_timestamp = block.header.timestamp;
-        self.app_chain.recent_blocks.push(block);
-        if self.app_chain.recent_blocks.len() > self.app_chain.max_recent_blocks {
-            self.app_chain.recent_blocks.remove(0);
-        }
-
-        // [MODIFIED] Persist the updated status to the state tree.
+        
         let status_bytes = serde_json::to_vec(&self.app_chain.status)
             .map_err(|e| ChainError::Transaction(format!("Failed to serialize status: {}", e)))?;
-        workload
-            .state_tree()
-            .lock()
-            .await
-            .insert(STATUS_KEY, &status_bytes)
-            .map_err(|e| ChainError::Transaction(e.to_string()))?;
+        let validator_set_bytes = serde_json::to_vec(&block.header.validator_set)
+            .map_err(|e| ChainError::Transaction(format!("Failed to serialize validator set: {}", e)))?;
+        
+        // FIX: Bind the Arc to a variable to extend its lifetime.
+        let state_tree_arc = workload.state_tree();
+        let mut state = state_tree_arc.lock().await;
+        state.insert(STATUS_KEY, &status_bytes)
+             .map_err(|e| ChainError::Transaction(e.to_string()))?;
+        // Commit the validator set from the block header to the state tree.
+        state.insert(VALIDATOR_SET_KEY, &validator_set_bytes)
+             .map_err(|e| ChainError::Transaction(e.to_string()))?;
+        
+        let state_root = state.root_commitment();
+        drop(state); // release lock
 
-        Ok(())
+        block.header.state_root = state_root.as_ref().to_vec();
+        // Push a clone because we are returning the original block
+        self.app_chain.recent_blocks.push(block.clone());
+        if self.app_chain.recent_blocks.len() > self.app_chain.max_recent_blocks {
+            self.app_chain.recent_blocks.remove(0);
+        }
+        Ok(block)
     }
 
-    /// Creates a new block template to be filled by a block producer.
     fn create_block(
         &self,
         transactions: Vec<TM::Transaction>,
         _workload: &WorkloadContainer<ST>,
+        current_validator_set: &Vec<Vec<u8>>,
+        known_peers_bytes: &Vec<Vec<u8>>,
     ) -> Block<TM::Transaction> {
         let prev_hash = self
             .app_chain
@@ -196,13 +192,25 @@ where
             .last()
             .map_or(vec![0; 32], |b| b.header.state_root.clone());
 
-        // FIX: The state_root here is just a placeholder. The real root is calculated
-        // and overwritten in `process_block` after all transactions are executed.
-        // We remove the illegal `block_on` call and just use the previous hash as the initial value.
-        let state_root = prev_hash.clone();
+        // Propose a new validator set by taking the union of the last committed set
+        // and the current set of known network peers. This allows new nodes to be added.
+        let base_validators: HashSet<PeerId> = current_validator_set.iter()
+            .filter_map(|bytes| PeerId::from_bytes(bytes).ok())
+            .collect();
 
+        let known_peers: HashSet<PeerId> = known_peers_bytes.iter()
+            .filter_map(|bytes| PeerId::from_bytes(bytes).ok())
+            .collect();
+        
+        let mut new_validator_set_peers: Vec<PeerId> = base_validators.union(&known_peers).cloned().collect();
+        new_validator_set_peers.sort();
+        
+        let validator_set: Vec<Vec<u8>> = new_validator_set_peers.iter().map(|p| p.to_bytes()).collect();
+
+        let next_height = self.app_chain.status.height + 1;
+        let state_root = prev_hash.clone();
         let header = BlockHeader {
-            height: self.app_chain.status.height + 1,
+            height: next_height,
             prev_hash,
             state_root,
             transactions_root: vec![0; 32],
@@ -210,6 +218,7 @@ where
                 .duration_since(UNIX_EPOCH)
                 .unwrap()
                 .as_secs(),
+            validator_set,
         };
         Block {
             header,
@@ -223,4 +232,28 @@ where
             .iter()
             .find(|b| b.header.height == height)
     }
+
+    fn get_blocks_since(&self, height: u64) -> Vec<Block<TM::Transaction>> {
+        self.app_chain
+            .recent_blocks
+            .iter()
+            .filter(|b| b.header.height > height)
+            .cloned()
+            .collect()
+    }
+
+    async fn get_validator_set(
+        &self,
+        workload: &WorkloadContainer<ST>,
+    ) -> Result<Vec<Vec<u8>>, ChainError> {
+        // FIX: Bind the Arc to a variable to extend its lifetime.
+        let state_tree_arc = workload.state_tree();
+        let state = state_tree_arc.lock().await;
+        match state.get(VALIDATOR_SET_KEY) {
+            Ok(Some(bytes)) => serde_json::from_slice(&bytes)
+                .map_err(|e| ChainError::Transaction(format!("Failed to deserialize validator set: {}", e))),
+            Ok(None) => Ok(Vec::new()), // Not found, return empty set
+            Err(e) => Err(ChainError::Transaction(e.to_string())),
+        }
+    }
 }
\ No newline at end of file
diff --git a/crates/chain/src/bin/mvsc.rs b/crates/chain/src/bin/mvsc.rs
index ccc8c32..647365f 100644
--- a/crates/chain/src/bin/mvsc.rs
+++ b/crates/chain/src/bin/mvsc.rs
@@ -12,7 +12,6 @@ use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
 use depin_sdk_core::config::WorkloadConfig;
 use depin_sdk_core::validator::WorkloadContainer;
 use depin_sdk_core::Container;
-// MODIFIED: Import Multiaddr directly from the top-level libp2p crate.
 use libp2p::Multiaddr;
 use depin_sdk_state_trees::file::FileStateTree;
 use depin_sdk_transaction_models::utxo::UTXOModel;
@@ -40,7 +39,6 @@ async fn main() -> anyhow::Result<()> {
     log::info!("Initializing DePIN SDK Node...");
     log::info!("Using state file: {}", &opts.state_file);
 
-    // --- 1. Initialize Independent Components ---
     let commitment_scheme = HashCommitmentScheme::new();
     let transaction_model = UTXOModel::new(commitment_scheme.clone());
     let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
@@ -48,7 +46,6 @@ async fn main() -> anyhow::Result<()> {
         enabled_vms: vec!["WASM".to_string()],
     };
 
-    // --- 2. Build the Validator Containers ---
     let workload_container = Arc::new(WorkloadContainer::new(workload_config, state_tree));
 
     let config_path = PathBuf::from(&opts.config_dir);
@@ -62,7 +59,6 @@ async fn main() -> anyhow::Result<()> {
     );
     let guardian_container = GuardianContainer::new(&config_path.join("guardian.toml"))?;
 
-    // --- 3. Create and Initialize the SovereignChain Logic ---
     let mut chain_logic = ChainLogic::new(
         commitment_scheme.clone(),
         transaction_model,
@@ -76,34 +72,25 @@ async fn main() -> anyhow::Result<()> {
     let chain_ref: Arc<Mutex<ChainLogic<HashCommitmentScheme, UTXOModel<HashCommitmentScheme>>>> =
         Arc::new(Mutex::new(chain_logic));
 
-    // --- 4. Wire Up the Components (Inversion of Control) ---
     orchestration_container.set_chain_and_workload_ref(
         chain_ref.clone(),
         workload_container.clone(),
     );
 
-    // --- 5. Start the Validator Services ---
     guardian_container.start().await.map_err(|e| anyhow!(e))?;
     orchestration_container.start().await.map_err(|e| anyhow!(e))?;
     workload_container.start().await.map_err(|e| anyhow!(e))?;
 
-    // --- DIAL PEER IF PROVIDED ---
     if let Some(peer_addr_str) = opts.peer {
         let peer_addr: Multiaddr = peer_addr_str.parse()?;
         log::info!("Attempting to dial peer: {}", peer_addr_str);
         
-        // MODIFIED: Revert to the simple, direct dial call. This now works because
-        // `peer_addr` is of the correct type (`libp2p::Multiaddr`).
-        orchestration_container
-            .swarm
-            .lock()
-            .await
-            .dial(peer_addr)?;
+        // Use the new public method to send a command, instead of locking the swarm.
+        orchestration_container.dial(peer_addr).await;
     }
 
     log::info!("Node successfully started. Running indefinitely...");
 
-    // 6. Keep the main thread alive.
     tokio::signal::ctrl_c().await?;
 
     log::info!("Shutdown signal received. Stopping node...");
diff --git a/crates/core/src/app/mod.rs b/crates/core/src/app/mod.rs
index d809c81..0e4e131 100644
--- a/crates/core/src/app/mod.rs
+++ b/crates/core/src/app/mod.rs
@@ -11,8 +11,6 @@ pub struct ChainStatus {
     pub is_running: bool,
 }
 
-// FIX: Add derive(Clone, Debug). Clone is needed for block processing,
-// and Debug is needed for `.unwrap()` calls on Results containing the block.
 #[derive(Serialize, Deserialize, Debug, Clone)]
 pub struct Block<T> {
     pub header: BlockHeader,
@@ -26,6 +24,9 @@ pub struct BlockHeader {
     pub state_root: Vec<u8>,
     pub transactions_root: Vec<u8>,
     pub timestamp: u64,
+    /// The full, sorted list of PeerIds (in bytes) that constituted the validator
+    /// set when this block was created.
+    pub validator_set: Vec<Vec<u8>>,
 }
 
 #[derive(Debug)]
diff --git a/crates/core/src/chain/mod.rs b/crates/core/src/chain/mod.rs
index 7188843..539dddb 100644
--- a/crates/core/src/chain/mod.rs
+++ b/crates/core/src/chain/mod.rs
@@ -15,6 +15,7 @@ where
     CS: CommitmentScheme,
     TM: TransactionModel<CommitmentScheme = CS>,
     ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
+    TM::Transaction: Clone,
 {
     fn status(&self) -> &ChainStatus;
     fn transaction_model(&self) -> &TM;
@@ -29,13 +30,28 @@ where
         &mut self,
         block: Block<TM::Transaction>,
         workload: &WorkloadContainer<ST>,
-    ) -> Result<(), ChainError>;
+    ) -> Result<Block<TM::Transaction>, ChainError>;
 
+    /// Creates a new block template to be filled by a block producer.
+    ///
+    /// # Arguments
+    /// * `transactions` - A vector of transactions to include in the block.
+    /// * `workload` - A reference to the workload container.
+    /// * `current_validator_set` - The validator set from the last committed state.
+    /// * `known_peers_bytes` - The current set of known validator peer IDs, as bytes,
+    ///   used to propose an updated validator set for the new block.
     fn create_block(
         &self,
         transactions: Vec<TM::Transaction>,
         workload: &WorkloadContainer<ST>,
+        current_validator_set: &Vec<Vec<u8>>,
+        known_peers_bytes: &Vec<Vec<u8>>,
     ) -> Block<TM::Transaction>;
 
     fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>>;
+
+    fn get_blocks_since(&self, height: u64) -> Vec<Block<TM::Transaction>>;
+
+    /// Retrieves the active validator set from the committed state.
+    async fn get_validator_set(&self, workload: &WorkloadContainer<ST>) -> Result<Vec<Vec<u8>>, ChainError>;
 }
\ No newline at end of file
diff --git a/crates/state_trees/src/file/mod.rs b/crates/state_trees/src/file/mod.rs
index 2f439b7..b4c73ef 100644
--- a/crates/state_trees/src/file/mod.rs
+++ b/crates/state_trees/src/file/mod.rs
@@ -93,12 +93,16 @@ where
     }
 
     fn root_commitment(&self) -> Self::Commitment {
-        let mut values_to_sort = self.data.values().cloned().collect::<Vec<_>>();
-        values_to_sort.sort();
-
-        let values_to_commit: Vec<Option<C::Value>> = values_to_sort
-            .into_iter()
-            .map(|v| Some(C::Value::from(v)))
+        // --- FIX: Ensure deterministic commitment by sorting keys first. ---
+        // This is the most robust pattern for getting a deterministic value set from a HashMap.
+        // 1. Collect all keys.
+        let mut sorted_keys: Vec<_> = self.data.keys().collect();
+        // 2. Sort the keys deterministically.
+        sorted_keys.sort();
+        // 3. Map the sorted keys to their corresponding values.
+        let values_to_commit: Vec<Option<C::Value>> = sorted_keys
+            .iter()
+            .map(|key| self.data.get(*key).map(|v| C::Value::from(v.clone())))
             .collect();
 
         self.scheme.commit(&values_to_commit)
diff --git a/crates/validator/Cargo.toml b/crates/validator/Cargo.toml
index 5fd730b..94ee784 100644
--- a/crates/validator/Cargo.toml
+++ b/crates/validator/Cargo.toml
@@ -1,5 +1,3 @@
-# Path: crates/validator/Cargo.toml
-
 [package]
 name = "depin-sdk-validator"
 version = "0.1.0"
@@ -12,9 +10,10 @@ depin-sdk-core = { path = "../core" }
 log = { workspace = true }
 anyhow = { workspace = true }
 serde = { workspace = true, features = ["derive"] }
+serde_bytes = { workspace = true }
 serde_json = { workspace = true }
-# FIX: The `sync` feature is required for tokio::sync::watch
 tokio = { workspace = true, features = ["full", "sync"] }
+# Just use workspace libp2p, all features are already specified there
 libp2p = { workspace = true }
 futures = { workspace = true }
 async-trait = { workspace = true }
@@ -23,6 +22,7 @@ clap = { workspace = true, features = ["derive"], optional = true }
 env_logger = { workspace = true, optional = true }
 depin-sdk-state-trees = { path = "../state_trees", optional = true }
 depin-sdk-commitment-schemes = { path = "../commitment_schemes", optional = true }
+rand = { workspace = true }
 
 [features]
 default = []
diff --git a/crates/validator/src/standard/orchestration.rs b/crates/validator/src/standard/orchestration.rs
index 9c780e1..a169dc3 100644
--- a/crates/validator/src/standard/orchestration.rs
+++ b/crates/validator/src/standard/orchestration.rs
@@ -3,6 +3,7 @@
 use crate::config::OrchestrationConfig;
 use async_trait::async_trait;
 use depin_sdk_core::{
+    app::Block,
     chain::SovereignChain,
     commitment::CommitmentScheme,
     error::ValidatorError,
@@ -10,23 +11,175 @@ use depin_sdk_core::{
     transaction::TransactionModel,
     validator::{Container, WorkloadContainer},
 };
+use futures::io::{AsyncRead, AsyncWrite};
 use futures::StreamExt;
-// ADDED: Import Multiaddr for the listen_on call
 use libp2p::{
-    core::upgrade, gossipsub, identity, noise, swarm::SwarmEvent, tcp, yamux, Multiaddr, Swarm,
-    SwarmBuilder, Transport,
+    core::{
+        upgrade::{read_length_prefixed, write_length_prefixed, Version},
+    },
+    gossipsub, identity, noise,
+    request_response::{self, Codec, ProtocolSupport, ResponseChannel},
+    swarm::{NetworkBehaviour, SwarmEvent},
+    tcp, yamux, Multiaddr, PeerId, SwarmBuilder, Transport,
 };
+use rand::seq::SliceRandom;
+use serde::{Deserialize, Serialize};
+use std::collections::HashSet;
 use std::fmt::Debug;
+use std::io;
+use std::iter;
 use std::sync::{
     atomic::{AtomicBool, Ordering},
     Arc,
 };
 use tokio::{
-    sync::{watch, Mutex, OnceCell},
+    sync::{mpsc, watch, Mutex, OnceCell},
     task::JoinHandle,
     time::{self, Duration},
 };
 
+/// The internal state of the node, determining its participation in consensus.
+#[derive(Debug, Clone, PartialEq, Eq)]
+enum NodeState {
+    Syncing,
+    Synced,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum SyncRequest {
+    GetStatus,
+    GetBlocks(u64),
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum SyncResponse {
+    Status(u64),
+    Blocks(Vec<Block<serde_bytes::ByteBuf>>),
+}
+
+#[derive(Debug, Clone, Default)]
+pub struct SyncCodec;
+
+#[async_trait]
+impl Codec for SyncCodec {
+    type Protocol = &'static str;
+    type Request = SyncRequest;
+    type Response = SyncResponse;
+
+    async fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> io::Result<Self::Request>
+    where T: AsyncRead + Unpin + Send {
+        let vec = read_length_prefixed(io, 1_000_000).await?;
+        serde_json::from_slice(&vec).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
+    }
+
+    async fn read_response<T>(&mut self, _: &Self::Protocol, io: &mut T) -> io::Result<Self::Response>
+    where T: AsyncRead + Unpin + Send {
+        let vec = read_length_prefixed(io, 10_000_000).await?;
+        serde_json::from_slice(&vec).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
+    }
+
+    async fn write_request<T>(&mut self, _: &Self::Protocol, io: &mut T, req: Self::Request) -> io::Result<()>
+    where T: AsyncWrite + Unpin + Send {
+        let vec = serde_json::to_vec(&req)?;
+        write_length_prefixed(io, vec).await
+    }
+
+    async fn write_response<T>(&mut self, _: &Self::Protocol, io: &mut T, res: Self::Response) -> io::Result<()>
+    where T: AsyncWrite + Unpin + Send {
+        let vec = serde_json::to_vec(&res)?;
+        write_length_prefixed(io, vec).await
+    }
+}
+
+/// Network behaviour module
+mod behaviour {
+    use super::*;
+    
+    #[derive(NetworkBehaviour)]
+    #[behaviour(to_swarm = "OrchestrationBehaviourEvent")]
+    pub struct OrchestrationBehaviour {
+        pub gossipsub: gossipsub::Behaviour,
+        pub request_response: request_response::Behaviour<SyncCodec>,
+    }
+    
+    #[derive(Debug)]
+    pub enum OrchestrationBehaviourEvent {
+        Gossipsub(gossipsub::Event),
+        RequestResponse(request_response::Event<SyncRequest, SyncResponse>),
+    }
+    
+    impl From<gossipsub::Event> for OrchestrationBehaviourEvent {
+        fn from(event: gossipsub::Event) -> Self {
+            OrchestrationBehaviourEvent::Gossipsub(event)
+        }
+    }
+    
+    impl From<request_response::Event<SyncRequest, SyncResponse>> for OrchestrationBehaviourEvent {
+        fn from(event: request_response::Event<SyncRequest, SyncResponse>) -> Self {
+            OrchestrationBehaviourEvent::RequestResponse(event)
+        }
+    }
+}
+
+use behaviour::{OrchestrationBehaviour, OrchestrationBehaviourEvent};
+
+/// Commands sent *to* the swarm task.
+#[derive(Debug)]
+pub enum SwarmCommand {
+    Listen(Multiaddr),
+    Dial(Multiaddr),
+    PublishBlock(Vec<u8>),
+    SendStatusRequest(PeerId),
+    SendBlocksRequest(PeerId, u64),
+    SendStatusResponse(ResponseChannel<SyncResponse>, u64),
+    SendBlocksResponse(ResponseChannel<SyncResponse>, Vec<Block<serde_bytes::ByteBuf>>),
+}
+
+/// Events sent *from* the swarm task back to the event loop.
+#[derive(Debug)]
+enum SwarmEventOut {
+    ConnectionEstablished(PeerId),
+    ConnectionClosed(PeerId),
+    GossipBlock(Vec<u8>, PeerId),
+    StatusRequest(PeerId, ResponseChannel<SyncResponse>),
+    BlocksRequest(PeerId, u64, ResponseChannel<SyncResponse>),
+    StatusResponse(PeerId, u64),
+    BlocksResponse(PeerId, Vec<Block<serde_bytes::ByteBuf>>),
+}
+
+/// Free function to check for quorum.
+fn has_quorum(
+    validator_set: &[Vec<u8>],
+    known_peers: &HashSet<PeerId>,
+    local_peer_id: &PeerId,
+) -> bool {
+    if validator_set.is_empty() {
+        return true;
+    }
+    let mut connected_validators = 0;
+    for peer_bytes in validator_set {
+        if let Ok(peer_id) = PeerId::from_bytes(peer_bytes) {
+            if &peer_id == local_peer_id || known_peers.contains(&peer_id) {
+                connected_validators += 1;
+            }
+        }
+    }
+    let quorum_size = (validator_set.len() / 2) + 1;
+    let has_quorum = connected_validators >= quorum_size;
+    if !has_quorum {
+        log::warn!(
+            "Quorum check failed: see {}/{} of validator set (quorum is {}). Known peers: {}",
+            connected_validators, validator_set.len(), quorum_size, known_peers.len()
+        );
+    } else {
+        log::info!(
+            "Quorum check passed: see {}/{} of validator set (quorum is {}).",
+             connected_validators, validator_set.len(), quorum_size
+        );
+    }
+    has_quorum
+}
+
 pub struct OrchestrationContainer<CS, TM, ST>
 where
     CS: CommitmentScheme + Send + Sync + 'static,
@@ -37,65 +190,53 @@ where
     _config: OrchestrationConfig,
     chain: Arc<OnceCell<Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>>>,
     workload: Arc<OnceCell<Arc<WorkloadContainer<ST>>>>,
-    pub swarm: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
+    swarm_command_sender: Mutex<Option<mpsc::Sender<SwarmCommand>>>,
+    swarm_event_receiver: Arc<Mutex<Option<mpsc::Receiver<SwarmEventOut>>>>,
     shutdown_sender: Arc<watch::Sender<bool>>,
     task_handles: Arc<Mutex<Vec<JoinHandle<()>>>>,
     is_running: Arc<AtomicBool>,
+    local_peer_id: PeerId,
 }
 
 impl<CS, TM, ST> OrchestrationContainer<CS, TM, ST>
 where
     CS: CommitmentScheme + Send + Sync + 'static,
     TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-    TM::Transaction: Clone + Debug + Send + Sync,
+    TM::Transaction: Clone + Debug + Send + Sync + for<'de> serde::Deserialize<'de> + serde::Serialize,
     ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
         + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-        + Send
-        + Sync
-        + 'static
-        + Debug,
+        + Send + Sync + 'static + Debug,
     CS::Commitment: Send + Sync + Debug,
 {
     pub async fn new(config_path: &std::path::Path) -> anyhow::Result<Self> {
-        let _config: OrchestrationConfig =
-            toml::from_str(&std::fs::read_to_string(config_path)?)?;
-
+        let _config: OrchestrationConfig = toml::from_str(&std::fs::read_to_string(config_path)?)?;
         let (shutdown_sender, _) = watch::channel(false);
-
         let local_key = identity::Keypair::generate_ed25519();
+        let local_peer_id = local_key.public().to_peer_id();
 
-        let swarm = SwarmBuilder::with_existing_identity(local_key)
-            .with_tokio()
-            .with_other_transport(|key| {
-                let noise_config = noise::Config::new(key)
-                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
-                let transport = tcp::tokio::Transport::new(tcp::Config::default())
-                    .upgrade(upgrade::Version::V1Lazy)
-                    .authenticate(noise_config)
-                    .multiplex(yamux::Config::default())
-                    .timeout(std::time::Duration::from_secs(20))
-                    .boxed();
-                Ok(transport)
-            })?
-            .with_behaviour(|key| {
-                let gossipsub_config = gossipsub::Config::default();
-                gossipsub::Behaviour::new(
-                    gossipsub::MessageAuthenticity::Signed(key.clone()),
-                    gossipsub_config,
-                )
-                .expect("Valid gossipsub config")
-            })?
-            .build();
+        let (swarm_command_sender, swarm_command_receiver) = mpsc::channel(100);
+        let (swarm_event_sender, swarm_event_receiver) = mpsc::channel(100);
 
-        Ok(Self {
+        let swarm_task_handle = tokio::spawn(Self::run_swarm_loop(
+            local_key,
+            swarm_command_receiver,
+            swarm_event_sender,
+        ));
+        
+        let container = Self {
             _config,
             chain: Arc::new(OnceCell::new()),
             workload: Arc::new(OnceCell::new()),
-            swarm: Arc::new(Mutex::new(swarm)),
+            swarm_command_sender: Mutex::new(Some(swarm_command_sender)),
+            swarm_event_receiver: Arc::new(Mutex::new(Some(swarm_event_receiver))),
             shutdown_sender: Arc::new(shutdown_sender),
-            task_handles: Arc::new(Mutex::new(Vec::new())),
+            task_handles: Arc::new(Mutex::new(vec![swarm_task_handle])),
             is_running: Arc::new(AtomicBool::new(false)),
-        })
+            local_peer_id,
+        };
+        
+        log::info!("Local Peer ID: {}", local_peer_id);
+        Ok(container)
     }
 
     pub fn set_chain_and_workload_ref(
@@ -104,182 +245,409 @@ where
         workload_ref: Arc<WorkloadContainer<ST>>,
     ) {
         self.chain.set(chain_ref).expect("Chain ref already set");
-        self.workload
-            .set(workload_ref)
-            .expect("Workload ref already set");
+        self.workload.set(workload_ref).expect("Workload ref already set");
+    }
+
+    pub async fn dial(&self, addr: Multiaddr) {
+        if let Some(sender) = self.swarm_command_sender.lock().await.as_ref() {
+            sender.send(SwarmCommand::Dial(addr)).await.ok();
+        }
+    }
+
+    async fn run_swarm_loop(
+        local_key: identity::Keypair,
+        mut command_receiver: mpsc::Receiver<SwarmCommand>,
+        event_sender: mpsc::Sender<SwarmEventOut>,
+    ) {
+        let mut swarm = SwarmBuilder::with_existing_identity(local_key)
+            .with_tokio()
+            .with_other_transport(|key| {
+                let noise_config = noise::Config::new(key).unwrap();
+                let transport = tcp::tokio::Transport::new(tcp::Config::default())
+                    .upgrade(Version::V1Lazy)
+                    .authenticate(noise_config)
+                    .multiplex(yamux::Config::default()).timeout(Duration::from_secs(20)).boxed();
+                Ok(transport)
+            }).unwrap()
+            .with_behaviour(|key| {
+                let gossipsub = gossipsub::Behaviour::new(
+                    gossipsub::MessageAuthenticity::Signed(key.clone()),
+                    gossipsub::Config::default(),
+                ).unwrap();
+                let request_response = request_response::Behaviour::new(
+                    iter::once(("/depin/sync/1", ProtocolSupport::Full)),
+                    request_response::Config::default(),
+                );
+                Ok(OrchestrationBehaviour { gossipsub, request_response })
+            }).unwrap()
+            .build();
+        
+        let topic = gossipsub::IdentTopic::new("blocks");
+        swarm.behaviour_mut().gossipsub.subscribe(&topic).unwrap();
+
+        loop {
+            tokio::select! {
+                event = swarm.select_next_some() => match event {
+                    SwarmEvent::NewListenAddr { address, .. } => { log::info!("Swarm listening on {}", address); }
+                    SwarmEvent::ConnectionEstablished { peer_id, .. } => { event_sender.send(SwarmEventOut::ConnectionEstablished(peer_id)).await.ok(); }
+                    SwarmEvent::ConnectionClosed { peer_id, .. } => { event_sender.send(SwarmEventOut::ConnectionClosed(peer_id)).await.ok(); }
+                    SwarmEvent::Behaviour(event) => match event {
+                        OrchestrationBehaviourEvent::Gossipsub(gossipsub::Event::Message { message, .. }) => {
+                            if let Some(source) = message.source {
+                                event_sender.send(SwarmEventOut::GossipBlock(message.data, source)).await.ok();
+                            }
+                        }
+                        OrchestrationBehaviourEvent::RequestResponse(request_response::Event::Message { peer, message }) => {
+                            match message {
+                                request_response::Message::Request { request, channel, .. } => match request {
+                                    SyncRequest::GetStatus => { event_sender.send(SwarmEventOut::StatusRequest(peer, channel)).await.ok(); }
+                                    SyncRequest::GetBlocks(h) => { event_sender.send(SwarmEventOut::BlocksRequest(peer, h, channel)).await.ok(); }
+                                },
+                                request_response::Message::Response { request_id: _, response } => match response {
+                                    SyncResponse::Status(h) => { event_sender.send(SwarmEventOut::StatusResponse(peer, h)).await.ok(); }
+                                    SyncResponse::Blocks(b) => { event_sender.send(SwarmEventOut::BlocksResponse(peer, b)).await.ok(); }
+                                }
+                            }
+                        }
+                        _ => {}
+                    }
+                    _ => {}
+                },
+                command = command_receiver.recv() => match command {
+                    Some(cmd) => match cmd {
+                        SwarmCommand::Listen(addr) => { swarm.listen_on(addr).ok(); }
+                        SwarmCommand::Dial(addr) => { swarm.dial(addr).ok(); }
+                        SwarmCommand::PublishBlock(data) => {
+                            if let Err(e) = swarm.behaviour_mut().gossipsub.publish(topic.clone(), data) {
+                                log::warn!("Failed to publish block: {:?}", e);
+                            }
+                        }
+                        SwarmCommand::SendStatusRequest(p) => { swarm.behaviour_mut().request_response.send_request(&p, SyncRequest::GetStatus); }
+                        SwarmCommand::SendBlocksRequest(p, h) => { swarm.behaviour_mut().request_response.send_request(&p, SyncRequest::GetBlocks(h)); }
+                        SwarmCommand::SendStatusResponse(c, h) => { swarm.behaviour_mut().request_response.send_response(c, SyncResponse::Status(h)).ok(); }
+                        SwarmCommand::SendBlocksResponse(c, b) => { swarm.behaviour_mut().request_response.send_response(c, SyncResponse::Blocks(b)).ok(); }
+                    },
+                    None => {
+                        log::info!("Swarm command channel closed. Shutting down swarm loop.");
+                        return;
+                    }
+                }
+            }
+        }
     }
 
     async fn run_event_loop(
-        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
+        swarm_commander: Option<mpsc::Sender<SwarmCommand>>,
+        mut event_receiver: mpsc::Receiver<SwarmEventOut>,
         mut shutdown_receiver: watch::Receiver<bool>,
+        chain_cell: Arc<OnceCell<Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>>>,
+        workload_cell: Arc<OnceCell<Arc<WorkloadContainer<ST>>>>,
+        known_peers: Arc<Mutex<HashSet<PeerId>>>,
+        node_state: Arc<Mutex<NodeState>>,
     ) {
+        let chain_ref = chain_cell.get().unwrap().clone();
+        let workload_ref = workload_cell.get().unwrap().clone();
+        
+        let initial_sync_timeout = tokio::time::sleep(Duration::from_secs(7));
+        tokio::pin!(initial_sync_timeout);
+
         loop {
+            let is_syncing = *node_state.lock().await == NodeState::Syncing;
             tokio::select! {
-                biased;
-                _ = shutdown_receiver.changed() => {
-                    if *shutdown_receiver.borrow() {
-                        log::info!("Orchestration event loop received shutdown signal.");
-                        break;
+                _ = shutdown_receiver.changed() => if *shutdown_receiver.borrow() { break; },
+                _ = &mut initial_sync_timeout, if is_syncing => {
+                    if known_peers.lock().await.len() <= 1 {
+                        log::info!("No peers found after timeout. Assuming genesis node. State -> Synced.");
+                        *node_state.lock().await = NodeState::Synced;
                     }
                 },
-                event = async { swarm_ref.lock().await.select_next_some().await } => {
-                     match event {
-                        SwarmEvent::Behaviour(gossipsub::Event::Message { message, .. }) => {
-                            log::info!(
-                                "Received block gossip from peer {:?}: '{}'",
-                                message.source,
-                                String::from_utf8_lossy(&message.data)
-                            );
+                Some(event) = event_receiver.recv() => if let Some(ref commander) = swarm_commander { match event {
+                    SwarmEventOut::ConnectionEstablished(peer_id) => {
+                        known_peers.lock().await.insert(peer_id);
+                        commander.send(SwarmCommand::SendStatusRequest(peer_id)).await.ok();
+                    }
+                    SwarmEventOut::ConnectionClosed(peer_id) => {
+                        known_peers.lock().await.remove(&peer_id);
+                    }
+                    SwarmEventOut::GossipBlock(data, source) => {
+                        if let Ok(block_bytes) = serde_json::from_slice::<Block<serde_bytes::ByteBuf>>(&data) {
+                            let transactions = block_bytes.transactions.into_iter().map(|b| serde_json::from_slice(&b).unwrap()).collect();
+                            let block = Block { header: block_bytes.header, transactions };
+                            log::info!("Received block #{} via gossip from peer {:?}.", block.header.height, source);
+                            let mut chain = chain_ref.lock().await;
+                            if let Err(e) = chain.process_block(block, &workload_ref).await {
+                                log::warn!("Failed to process gossiped block from peer {:?}: {:?}", source, e);
+                            }
                         }
-                        SwarmEvent::NewListenAddr { address, .. } => {
-                            log::info!("OrchestrationContainer now listening on {}", address);
+                    }
+                    SwarmEventOut::StatusRequest(peer, channel) => {
+                        let height = chain_ref.lock().await.status().height;
+                        commander.send(SwarmCommand::SendStatusResponse(channel, height)).await.ok();
+                        log::info!("Responded to GetStatus request from {} with height {}.", peer, height);
+                    }
+                    SwarmEventOut::BlocksRequest(peer, since, channel) => {
+                        let blocks = chain_ref.lock().await.get_blocks_since(since);
+                        let serializable = blocks.into_iter().map(|b| {
+                            let txs = b.transactions.into_iter().map(|tx| serde_bytes::ByteBuf::from(serde_json::to_vec(&tx).unwrap())).collect();
+                            Block { header: b.header, transactions: txs }
+                        }).collect();
+                        commander.send(SwarmCommand::SendBlocksResponse(channel, serializable)).await.ok();
+                        log::info!("Responded to GetBlocks request from {} for blocks since {}.", peer, since);
+                    }
+                    SwarmEventOut::StatusResponse(peer, peer_height) => {
+                        let our_height = chain_ref.lock().await.status().height;
+                        if peer_height > our_height {
+                            log::info!("Peer {} has longer chain ({} vs {}). Requesting blocks.", peer, peer_height, our_height);
+                            commander.send(SwarmCommand::SendBlocksRequest(peer, our_height)).await.ok();
+                        } else {
+                             if *node_state.lock().await == NodeState::Syncing {
+                                 *node_state.lock().await = NodeState::Synced;
+                                 log::info!("Sync complete with {}. State -> Synced.", peer);
+                             }
                         }
-                        SwarmEvent::ConnectionEstablished { peer_id, .. } => {
-                            log::info!("Connection established with peer: {:?}", peer_id);
+                    }
+                    SwarmEventOut::BlocksResponse(peer, blocks) => {
+                        log::info!("Received {} blocks from {} for syncing.", blocks.len(), peer);
+                        let mut chain = chain_ref.lock().await;
+                        for block_bytes in blocks {
+                            let txs = block_bytes.transactions.into_iter().map(|b| serde_json::from_slice(&b).unwrap()).collect();
+                            if let Err(e) = chain.process_block(Block { header: block_bytes.header, transactions: txs }, &workload_ref).await {
+                                log::error!("Error syncing block from {}: {:?}", peer, e);
+                                break;
+                            }
                         }
-                        _ => {}
+                         if *node_state.lock().await == NodeState::Syncing {
+                             *node_state.lock().await = NodeState::Synced;
+                             log::info!("Finished applying blocks from {}. State -> Synced.", peer);
+                         }
                     }
-                }
+                }}
             }
         }
+        log::info!("Orchestration event loop finished.");
     }
-
+    
     async fn run_block_production(
+        local_peer_id: PeerId,
         chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
         workload_ref: Arc<WorkloadContainer<ST>>,
-        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
+        swarm_commander: Option<mpsc::Sender<SwarmCommand>>,
         is_running: Arc<AtomicBool>,
+        known_peers_ref: Arc<Mutex<HashSet<PeerId>>>,
+        node_state_ref: Arc<Mutex<NodeState>>,
     ) {
         let mut interval = time::interval(Duration::from_secs(10));
+        interval.set_missed_tick_behavior(time::MissedTickBehavior::Skip);
+    
         while is_running.load(Ordering::SeqCst) {
             interval.tick().await;
+    
+            // --- NEW: PERIODIC SYNC LOGIC ---
+            // Periodically check status with a random peer to ensure we haven't fallen behind due to
+            // missed gossip messages or transient network issues.
+            if let Some(ref commander) = swarm_commander {
+                let peer_to_ping = {
+                    let peers = known_peers_ref.lock().await;
+                    // Create a list of remote peers (excluding ourselves)
+                    let remote_peers: Vec<_> = peers.iter().filter(|p| **p != local_peer_id).copied().collect();
+                    // Select a peer inside this scope to ensure the non-Send ThreadRng is dropped.
+                    remote_peers.choose(&mut rand::thread_rng()).copied()
+                };
 
-            let new_block;
-            {
-                let mut chain = chain_ref.lock().await;
-                let tm = chain.transaction_model().clone();
-                let coinbase_result = tm
-                    .create_coinbase_transaction(chain.status().height + 1, &[]);
-                
-                let coinbase = match coinbase_result {
-                    Ok(tx) => tx,
+                if let Some(random_peer) = peer_to_ping {
+                    log::info!("[SYNC CHECK] Performing periodic status check with peer {}.", random_peer);
+                    commander.send(SwarmCommand::SendStatusRequest(random_peer)).await.ok();
+                }
+            }
+            // --- END: PERIODIC SYNC LOGIC ---
+
+            if *node_state_ref.lock().await != NodeState::Synced {
+                continue;
+            }
+
+            // --- START INLINED LEADER ELECTION ---
+            let (validator_set, current_height) = {
+                let chain = chain_ref.lock().await;
+                let height = chain.status().height;
+                match chain.get_validator_set(&workload_ref).await {
+                    Ok(vs) => (vs, height),
                     Err(e) => {
-                        log::error!("Failed to create coinbase transaction: {:?}", e);
-                        continue;
+                        log::error!("Could not get validator set for leader check: {:?}", e);
+                        continue; // Skip this tick if we can't get the validator set
                     }
-                };
-
-                new_block = chain.create_block(vec![coinbase], &workload_ref);
+                }
+            };
 
-                if let Err(e) = chain
-                    .process_block(new_block.clone(), &workload_ref)
-                    .await
-                {
-                    log::error!("Failed to process new block: {:?}", e);
-                    continue;
+            let next_height = current_height + 1;
+            let is_me = if validator_set.is_empty() {
+                if current_height == 0 {
+                    log::info!("At genesis, assuming leadership.");
+                    true
+                } else {
+                    log::warn!("Validator set from state is empty at height {}. Assuming leadership to recover.", current_height);
+                    true
+                }
+            } else {
+                let leader_index = (next_height % validator_set.len() as u64) as usize;
+                // This check is important, although it should mathematically never fail if len > 0
+                if leader_index >= validator_set.len() {
+                    log::error!("BUG: Leader index {} is out of bounds for validator set of size {}.", leader_index, validator_set.len());
+                    false
+                } else {
+                    let designated_leader_bytes = &validator_set[leader_index];
+                    designated_leader_bytes == &local_peer_id.to_bytes()
                 }
-                log::info!("Produced and processed new block #{}", new_block.header.height);
+            };
+            
+            log::info!(
+                "[LEADER CHECK] Height: {}, Next: {}, Validators: {}, Designated: {:?}, Me: {:?}, Is Me: {}",
+                current_height,
+                next_height,
+                validator_set.len(),
+                if validator_set.is_empty() { None } else { PeerId::from_bytes(&validator_set[(next_height % validator_set.len() as u64) as usize]).ok() },
+                local_peer_id,
+                is_me
+            );
+            
+            if !is_me {
+                continue;
             }
             
-            let swarm_clone = swarm_ref.clone();
-            tokio::spawn(async move {
-                let mut swarm = swarm_clone.lock().await;
-                let topic = gossipsub::IdentTopic::new("blocks");
-                let message_data = serde_json::to_vec(&new_block.header).unwrap_or_default();
-
-                if let Err(e) = swarm.behaviour_mut().publish(topic, message_data) {
-                    log::warn!("Failed to publish block (likely no peers): {:?}", e);
+            let known_peers = known_peers_ref.lock().await;
+            if !has_quorum(&validator_set, &known_peers, &local_peer_id) {
+                continue;
+            }
+            // --- END INLINED LEADER ELECTION ---
+
+            let height_after_check = chain_ref.lock().await.status().height;
+            if height_after_check >= next_height {
+                log::info!("Block #{} already processed by the time we acquired lock. Aborting production.", next_height);
+                continue;
+            }
+            
+            let tm = chain_ref.lock().await.transaction_model().clone();
+
+            let peers_bytes: Vec<Vec<u8>> = {
+                let mut peers = known_peers.clone();
+                peers.insert(local_peer_id);
+                peers.iter().map(|p| p.to_bytes()).collect()
+            };
+            
+            log::info!("We are the leader, producing block #{}...", next_height);
+            
+            let coinbase = match tm.create_coinbase_transaction(next_height, &local_peer_id.to_bytes()) {
+                Ok(tx) => tx,
+                Err(e) => {
+                    log::error!("Failed to create coinbase transaction: {:?}. Skipping block production.", e);
+                    continue;
                 }
-            });
+            };
+
+            let new_block_template = {
+                let chain = chain_ref.lock().await;
+                chain.create_block(vec![coinbase], &workload_ref, &validator_set, &peers_bytes)
+            };
+
+            // Take the lock on the chain state to process the new block.
+            let mut chain = chain_ref.lock().await;
+
+            // Process the block template. This will execute transactions, update state,
+            // and return the finalized block with the correct state_root in its header.
+            let final_block = match chain.process_block(new_block_template, &workload_ref).await {
+                Ok(b) => b,
+                Err(e) => {
+                    log::error!("Failed to process our own new block: {:?}", e);
+                    continue;
+                }
+            };
+            log::info!("Produced and processed new block #{}", final_block.header.height);
+
+            if let Some(ref commander) = swarm_commander {
+                // Serialize and broadcast the FINALIZED block, not the old template.
+                let message_data = serde_json::to_vec(&final_block).unwrap();
+                commander.send(SwarmCommand::PublishBlock(message_data)).await.ok();
+            }
         }
         log::info!("Orchestration block production loop finished.");
     }
 }
 
+// NOTE: The separate helper functions `check_leader_and_get_vs` and `is_our_turn_to_produce`
+// have been removed, and their logic is now inlined into `run_block_production`.
+
 #[async_trait]
 impl<CS, TM, ST> Container for OrchestrationContainer<CS, TM, ST>
 where
     CS: CommitmentScheme + Send + Sync + 'static,
     TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-    TM::Transaction: Clone + Debug + Send + Sync,
-    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-        + Send
-        + Sync
-        + 'static
-        + Debug,
+    TM::Transaction: Clone + Debug + Send + Sync + for<'de> serde::Deserialize<'de> + serde::Serialize,
+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + StateTree<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
     CS::Commitment: Send + Sync + Debug,
 {
-    fn id(&self) -> &'static str {
-        "orchestration_container"
-    }
-
-    fn is_running(&self) -> bool {
-        self.is_running.load(Ordering::SeqCst)
-    }
+    fn id(&self) -> &'static str { "orchestration_container" }
+    fn is_running(&self) -> bool { self.is_running.load(Ordering::SeqCst) }
 
     async fn start(&self) -> Result<(), ValidatorError> {
-        if self.is_running() {
-            return Err(ValidatorError::AlreadyRunning(self.id().to_string()));
-        }
+        if self.is_running() { return Err(ValidatorError::AlreadyRunning(self.id().to_string())); }
         log::info!("OrchestrationContainer starting...");
+        
+        let command_sender = self.swarm_command_sender.lock().await.clone();
+        if let Some(ref sender) = command_sender {
+            let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0".parse().unwrap();
+            sender.send(SwarmCommand::Listen(listen_addr)).await.ok();
+        } else {
+             return Err(ValidatorError::Other("Swarm command sender is gone before start".to_string()));
+        }
+        
+        let chain = self.chain.get().ok_or_else(|| ValidatorError::Other("Chain ref not initialized before start".to_string()))?.clone();
+        let workload = self.workload.get().ok_or_else(|| ValidatorError::Other("Workload ref not initialized before start".to_string()))?.clone();
 
-        // --- ADDED THIS BLOCK TO START LISTENING ---
-        // Listen on all interfaces on a random OS-assigned TCP port.
-        let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0"
-            .parse()
-            .expect("Invalid listen address format");
-        self.swarm
-            .lock()
-            .await
-            .listen_on(listen_addr)
-            .map_err(|e| ValidatorError::Other(format!("Failed to listen on address: {}", e)))?;
-        // --- END ADDED BLOCK ---
-
-        self.is_running.store(true, Ordering::SeqCst);
+        let known_peers = Arc::new(Mutex::new(HashSet::from([self.local_peer_id])));
+        let node_state = Arc::new(Mutex::new(NodeState::Syncing));
         
         let mut handles = self.task_handles.lock().await;
 
-        let event_loop_receiver = self.shutdown_sender.subscribe();
-        let swarm_clone = self.swarm.clone();
-        handles.push(tokio::spawn(async move {
-            Self::run_event_loop(swarm_clone, event_loop_receiver).await;
-        }));
-
-        let chain_clone = self.chain.get().unwrap().clone();
-        let workload_clone = self.workload.get().unwrap().clone();
-        let swarm_clone_2 = self.swarm.clone();
-        let is_running_clone = self.is_running.clone();
-
-        handles.push(tokio::spawn(async move {
-            Self::run_block_production(
-                chain_clone,
-                workload_clone,
-                swarm_clone_2,
-                is_running_clone,
-            )
-            .await;
-        }));
+        let swarm_event_receiver = self.swarm_event_receiver.lock().await.take()
+            .ok_or_else(|| ValidatorError::Other("Event receiver already taken".to_string()))?;
 
+        handles.push(tokio::spawn(Self::run_event_loop(
+            command_sender.clone(),
+            swarm_event_receiver,
+            self.shutdown_sender.subscribe(),
+            self.chain.clone(),
+            self.workload.clone(),
+            known_peers.clone(),
+            node_state.clone(),
+        )));
+        
+        handles.push(tokio::spawn(Self::run_block_production(
+            self.local_peer_id,
+            chain,
+            workload,
+            command_sender,
+            self.is_running.clone(),
+            known_peers,
+            node_state,
+        )));
+        
+        self.is_running.store(true, Ordering::SeqCst);
         Ok(())
     }
 
     async fn stop(&self) -> Result<(), ValidatorError> {
-        if !self.is_running() {
-            return Ok(());
-        }
+        if !self.is_running() { return Ok(()); }
         log::info!("OrchestrationContainer stopping...");
         self.is_running.store(false, Ordering::SeqCst);
-        
-        self.shutdown_sender.send(true).map_err(|e| {
-            ValidatorError::Other(format!("Failed to send shutdown signal: {}", e))
-        })?;
+        self.shutdown_sender.send(true).ok();
+
+        if let Some(sender) = self.swarm_command_sender.lock().await.take() {
+            drop(sender);
+        }
 
         let mut handles = self.task_handles.lock().await;
         for handle in handles.drain(..) {
-            handle.await.map_err(|e| ValidatorError::Other(format!("Task panicked during shutdown: {}", e)))?;
+            handle.await.map_err(|e| ValidatorError::Other(format!("Task panicked: {}", e)))?;
         }
-
         Ok(())
     }
 }
\ No newline at end of file
diff --git a/output.txt b/output.txt
index 9aa7f07..6b75241 100644
--- a/output.txt
+++ b/output.txt
@@ -1,17886 +0,0 @@
-diff --git a/.gitignore b/.gitignore
-index 1886996..d8a1ea2 100644
---- a/.gitignore
-+++ b/.gitignore
-@@ -6,4 +6,7 @@ Cargo.lock
- codebase_snapshot.md
- keypair.seed
- state1.json
--state2.json
-\ No newline at end of file
-+state2.json
-+output.txt
-+.git
-+.gitignore
-diff --git a/Cargo.lock b/Cargo.lock
-index 35692c6..c64884c 100644
---- a/Cargo.lock
-+++ b/Cargo.lock
-@@ -13,9 +13,9 @@ dependencies = [
- 
- [[package]]
- name = "adler2"
--version = "2.0.0"
-+version = "2.0.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"
-+checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"
- 
- [[package]]
- name = "aead"
-@@ -199,7 +199,7 @@ checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -228,15 +228,15 @@ dependencies = [
- 
- [[package]]
- name = "autocfg"
--version = "1.4.0"
-+version = "1.5.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
-+checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"
- 
- [[package]]
- name = "backtrace"
--version = "0.3.74"
-+version = "0.3.75"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a"
-+checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
- dependencies = [
-  "addr2line",
-  "cfg-if",
-@@ -273,9 +273,9 @@ checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"
- 
- [[package]]
- name = "base64ct"
--version = "1.7.3"
-+version = "1.8.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "89e25b6adfb930f02d1981565a6e5d9c547ac15a96606256d3b59040e5cd4ca3"
-+checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"
- 
- [[package]]
- name = "bitflags"
-@@ -285,9 +285,9 @@ checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
- 
- [[package]]
- name = "bitflags"
--version = "2.9.0"
-+version = "2.9.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "5c8214115b7bf84099f1309324e63141d4c5d7cc26862f97a0a857dbefe165bd"
-+checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
- 
- [[package]]
- name = "blake2"
-@@ -345,9 +345,9 @@ dependencies = [
- 
- [[package]]
- name = "cfg-if"
--version = "1.0.0"
-+version = "1.0.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
-+checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"
- 
- [[package]]
- name = "chacha20"
-@@ -415,7 +415,7 @@ dependencies = [
-  "heck 0.5.0",
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -529,7 +529,7 @@ checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -555,7 +555,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "8d162beedaa69905488a8da94f5ac3edb4dd4788b732fadb7bd120b2625c1976"
- dependencies = [
-  "data-encoding",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -741,11 +741,11 @@ name = "depin-sdk-chain"
- version = "0.1.0"
- dependencies = [
-  "anyhow",
-+ "async-trait",
-  "clap",
-  "depin-sdk-commitment-schemes",
-  "depin-sdk-consensus",
-  "depin-sdk-core",
-- "depin-sdk-crypto",
-  "depin-sdk-state-trees",
-  "depin-sdk-transaction-models",
-  "depin-sdk-validator",
-@@ -765,12 +765,12 @@ name = "depin-sdk-commitment-schemes"
- version = "0.1.0"
- dependencies = [
-  "bytes",
-- "curve25519-dalek",
-+ "dcrypt",
-  "depin-sdk-core",
-+ "depin-sdk-crypto",
-  "log",
-  "rand",
-  "serde",
-- "sha2",
-  "thiserror 1.0.69",
- ]
- 
-@@ -789,11 +789,13 @@ dependencies = [
- name = "depin-sdk-core"
- version = "0.1.0"
- dependencies = [
-- "anyhow",
-+ "async-trait",
-  "bytes",
-  "log",
-  "serde",
-+ "serde_json",
-  "thiserror 1.0.69",
-+ "tokio",
- ]
- 
- [[package]]
-@@ -813,13 +815,10 @@ dependencies = [
- name = "depin-sdk-homomorphic"
- version = "0.1.0"
- dependencies = [
-- "curve25519-dalek",
-  "depin-sdk-commitment-schemes",
-  "depin-sdk-core",
-  "log",
-- "rand",
-  "serde",
-- "sha2",
-  "thiserror 1.0.69",
- ]
- 
-@@ -861,12 +860,12 @@ dependencies = [
- name = "depin-sdk-transaction-models"
- version = "0.1.0"
- dependencies = [
-- "anyhow",
-- "bytes",
-  "depin-sdk-core",
-- "depin-sdk-crypto",
-+ "hex",
-  "log",
-  "serde",
-+ "serde_json",
-+ "sha2",
-  "thiserror 1.0.69",
- ]
- 
-@@ -875,11 +874,17 @@ name = "depin-sdk-validator"
- version = "0.1.0"
- dependencies = [
-  "anyhow",
-- "bytes",
-+ "async-trait",
-+ "clap",
-+ "depin-sdk-commitment-schemes",
-  "depin-sdk-core",
-+ "depin-sdk-state-trees",
-+ "env_logger",
-+ "futures",
-+ "libp2p",
-  "log",
-  "serde",
-- "thiserror 1.0.69",
-+ "serde_json",
-  "tokio",
-  "toml",
- ]
-@@ -936,7 +941,7 @@ checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -996,7 +1001,7 @@ dependencies = [
-  "heck 0.5.0",
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -1025,7 +1030,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "778e2ac28f6c47af28e4907f13ffd1e1ddbd400980a9abd7c8df189bf578a5ad"
- dependencies = [
-  "libc",
-- "windows-sys 0.52.0",
-+ "windows-sys 0.60.2",
- ]
- 
- [[package]]
-@@ -1137,7 +1142,7 @@ checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -1209,9 +1214,9 @@ dependencies = [
- 
- [[package]]
- name = "getrandom"
--version = "0.2.15"
-+version = "0.2.16"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
-+checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
- dependencies = [
-  "cfg-if",
-  "libc",
-@@ -1255,9 +1260,9 @@ dependencies = [
- 
- [[package]]
- name = "hashbrown"
--version = "0.15.2"
-+version = "0.15.4"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
-+checksum = "5971ac85611da7067dbfcabef3c70ebb5606018acd9e2a3903a0da507521e0d5"
- 
- [[package]]
- name = "heck"
-@@ -1364,7 +1369,7 @@ dependencies = [
-  "httpdate",
-  "itoa",
-  "pin-project-lite",
-- "socket2 0.5.9",
-+ "socket2 0.5.10",
-  "tokio",
-  "tower-service",
-  "tracing",
-@@ -1553,9 +1558,9 @@ dependencies = [
- 
- [[package]]
- name = "indexmap"
--version = "2.9.0"
-+version = "2.10.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
-+checksum = "fe4cd85333e22411419a0bcae1297d25e58c9443848b11dc6a86fefe8c78a661"
- dependencies = [
-  "equivalent",
-  "hashbrown",
-@@ -1579,13 +1584,24 @@ dependencies = [
-  "cfg-if",
- ]
- 
-+[[package]]
-+name = "io-uring"
-+version = "0.7.9"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "d93587f37623a1a17d94ef2bc9ada592f5465fe7732084ab7beefabe5c77c0c4"
-+dependencies = [
-+ "bitflags 2.9.1",
-+ "cfg-if",
-+ "libc",
-+]
-+
- [[package]]
- name = "ipconfig"
- version = "0.3.2"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "b58db92f96b720de98181bbbe63c831e87005ab460c1bf306eb2622b4707997f"
- dependencies = [
-- "socket2 0.5.9",
-+ "socket2 0.5.10",
-  "widestring",
-  "windows-sys 0.48.0",
-  "winreg",
-@@ -1605,7 +1621,7 @@ checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
- dependencies = [
-  "hermit-abi",
-  "libc",
-- "windows-sys 0.52.0",
-+ "windows-sys 0.59.0",
- ]
- 
- [[package]]
-@@ -1638,9 +1654,9 @@ checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
- 
- [[package]]
- name = "libc"
--version = "0.2.171"
-+version = "0.2.174"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6"
-+checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"
- 
- [[package]]
- name = "libp2p"
-@@ -1666,6 +1682,7 @@ dependencies = [
-  "libp2p-quic",
-  "libp2p-swarm",
-  "libp2p-tcp",
-+ "libp2p-tls",
-  "libp2p-upnp",
-  "libp2p-yamux",
-  "multiaddr",
-@@ -1807,7 +1824,7 @@ dependencies = [
-  "log",
-  "rand",
-  "smallvec",
-- "socket2 0.5.9",
-+ "socket2 0.5.10",
-  "tokio",
-  "trust-dns-proto 0.22.0",
-  "void",
-@@ -1872,7 +1889,7 @@ dependencies = [
-  "rand",
-  "ring 0.16.20",
-  "rustls",
-- "socket2 0.5.9",
-+ "socket2 0.5.10",
-  "thiserror 1.0.69",
-  "tokio",
- ]
-@@ -1890,7 +1907,6 @@ dependencies = [
-  "instant",
-  "libp2p-core",
-  "libp2p-identity",
-- "libp2p-swarm-derive",
-  "log",
-  "multistream-select",
-  "once_cell",
-@@ -1900,19 +1916,6 @@ dependencies = [
-  "void",
- ]
- 
--[[package]]
--name = "libp2p-swarm-derive"
--version = "0.33.0"
--source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "c4d5ec2a3df00c7836d7696c136274c9c59705bac69133253696a6c932cd1d74"
--dependencies = [
-- "heck 0.4.1",
-- "proc-macro-warning",
-- "proc-macro2",
-- "quote",
-- "syn 2.0.100",
--]
--
- [[package]]
- name = "libp2p-tcp"
- version = "0.40.1"
-@@ -1926,7 +1929,7 @@ dependencies = [
-  "libp2p-core",
-  "libp2p-identity",
-  "log",
-- "socket2 0.5.9",
-+ "socket2 0.5.10",
-  "tokio",
- ]
- 
-@@ -1998,9 +2001,9 @@ checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"
- 
- [[package]]
- name = "lock_api"
--version = "0.4.12"
-+version = "0.4.13"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
-+checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
- dependencies = [
-  "autocfg",
-  "scopeguard",
-@@ -2029,9 +2032,9 @@ checksum = "2532096657941c2fea9c289d370a250971c689d4f143798ff67113ec042024a5"
- 
- [[package]]
- name = "memchr"
--version = "2.7.4"
-+version = "2.7.5"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
-+checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
- 
- [[package]]
- name = "minimal-lexical"
-@@ -2041,22 +2044,22 @@ checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"
- 
- [[package]]
- name = "miniz_oxide"
--version = "0.8.8"
-+version = "0.8.9"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "3be647b768db090acb35d5ec5db2b0e1f1de11133ca123b9eacf5137868f892a"
-+checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
- dependencies = [
-  "adler2",
- ]
- 
- [[package]]
- name = "mio"
--version = "1.0.3"
-+version = "1.0.4"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "2886843bf800fba2e3377cff24abf6379b4c4d5c6681eaf9ea5b0d15090450bd"
-+checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
- dependencies = [
-  "libc",
-  "wasi",
-- "windows-sys 0.52.0",
-+ "windows-sys 0.59.0",
- ]
- 
- [[package]]
-@@ -2292,9 +2295,9 @@ checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"
- 
- [[package]]
- name = "parking_lot"
--version = "0.12.3"
-+version = "0.12.4"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
-+checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
- dependencies = [
-  "lock_api",
-  "parking_lot_core",
-@@ -2302,9 +2305,9 @@ dependencies = [
- 
- [[package]]
- name = "parking_lot_core"
--version = "0.9.10"
-+version = "0.9.11"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
-+checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
- dependencies = [
-  "cfg-if",
-  "libc",
-@@ -2374,7 +2377,7 @@ checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -2466,22 +2469,11 @@ dependencies = [
-  "zerocopy",
- ]
- 
--[[package]]
--name = "proc-macro-warning"
--version = "0.4.2"
--source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "3d1eaa7fa0aa1929ffdf7eeb6eac234dde6268914a14ad44d23521ab6a9b258e"
--dependencies = [
-- "proc-macro2",
-- "quote",
-- "syn 2.0.100",
--]
--
- [[package]]
- name = "proc-macro2"
--version = "1.0.94"
-+version = "1.0.95"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
-+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
- dependencies = [
-  "unicode-ident",
- ]
-@@ -2506,7 +2498,7 @@ checksum = "440f724eba9f6996b75d63681b0a92b06947f1457076d503a4d2e2c8f56442b8"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -2574,7 +2566,7 @@ checksum = "055b4e778e8feb9f93c4e439f71dc2156ef13360b432b799e179a8c4cdf0b1d7"
- dependencies = [
-  "bytes",
-  "libc",
-- "socket2 0.5.9",
-+ "socket2 0.5.10",
-  "tracing",
-  "windows-sys 0.48.0",
- ]
-@@ -2632,11 +2624,11 @@ dependencies = [
- 
- [[package]]
- name = "redox_syscall"
--version = "0.5.11"
-+version = "0.5.17"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "d2f103c6d277498fbceb16e84d317e2a400f160f46904d5f5410848c829511a3"
-+checksum = "5407465600fb0548f1442edf71dd20683c6ed326200ace4b1ef0763521bb3b77"
- dependencies = [
-- "bitflags 2.9.0",
-+ "bitflags 2.9.1",
- ]
- 
- [[package]]
-@@ -2723,9 +2715,9 @@ dependencies = [
- 
- [[package]]
- name = "rustc-demangle"
--version = "0.1.24"
-+version = "0.1.26"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
-+checksum = "56f7d92ca342cea22a06f2121d944b4fd82af56988c270852495420f961d4ace"
- 
- [[package]]
- name = "rustc-hash"
-@@ -2757,11 +2749,11 @@ version = "1.0.8"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "11181fbabf243db407ef8df94a6ce0b2f9a733bd8be4ad02b4eda9602296cac8"
- dependencies = [
-- "bitflags 2.9.0",
-+ "bitflags 2.9.1",
-  "errno",
-  "libc",
-  "linux-raw-sys",
-- "windows-sys 0.52.0",
-+ "windows-sys 0.60.2",
- ]
- 
- [[package]]
-@@ -2842,7 +2834,7 @@ checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -2859,18 +2851,18 @@ dependencies = [
- 
- [[package]]
- name = "serde_spanned"
--version = "0.6.8"
-+version = "0.6.9"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "87607cb1398ed59d48732e575a4c28a7a8ebf2454b964fe3f224f2afc07909e1"
-+checksum = "bf41e0cfaf7226dca15e8197172c295a782857fcb97fad1808a166870dee75a3"
- dependencies = [
-  "serde",
- ]
- 
- [[package]]
- name = "sha2"
--version = "0.10.8"
-+version = "0.10.9"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
-+checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
- dependencies = [
-  "cfg-if",
-  "cpufeatures",
-@@ -2885,9 +2877,9 @@ checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"
- 
- [[package]]
- name = "signal-hook-registry"
--version = "1.4.2"
-+version = "1.4.5"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
-+checksum = "9203b8055f63a2a00e2f593bb0510367fe707d7ff1e5c872de2f537b339e5410"
- dependencies = [
-  "libc",
- ]
-@@ -2909,9 +2901,9 @@ checksum = "04dc19736151f35336d325007ac991178d504a119863a2fcb3758cdb5e52c50d"
- 
- [[package]]
- name = "smallvec"
--version = "1.15.0"
-+version = "1.15.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "8917285742e9f3e1683f0a9c4e6b57960b7314d0b08d30d1ecd426713ee2eee9"
-+checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"
- 
- [[package]]
- name = "snow"
-@@ -2942,14 +2934,24 @@ dependencies = [
- 
- [[package]]
- name = "socket2"
--version = "0.5.9"
-+version = "0.5.10"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "4f5fd57c80058a56cf5c777ab8a126398ece8e442983605d280a44ce79d0edef"
-+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
- dependencies = [
-  "libc",
-  "windows-sys 0.52.0",
- ]
- 
-+[[package]]
-+name = "socket2"
-+version = "0.6.0"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "233504af464074f9d066d7b5416c5f9b894a5862a6506e306f7b816cdd6f1807"
-+dependencies = [
-+ "libc",
-+ "windows-sys 0.59.0",
-+]
-+
- [[package]]
- name = "spin"
- version = "0.5.2"
-@@ -3003,9 +3005,9 @@ dependencies = [
- 
- [[package]]
- name = "syn"
--version = "2.0.100"
-+version = "2.0.104"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
-+checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
- dependencies = [
-  "proc-macro2",
-  "quote",
-@@ -3032,7 +3034,7 @@ checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -3041,7 +3043,7 @@ version = "0.6.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "3c879d448e9d986b661742763247d3693ed13609438cf3d006f51f5368a5ba6b"
- dependencies = [
-- "bitflags 2.9.0",
-+ "bitflags 2.9.1",
-  "core-foundation",
-  "system-configuration-sys",
- ]
-@@ -3091,7 +3093,7 @@ checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -3102,7 +3104,7 @@ checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -3163,20 +3165,22 @@ checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
- 
- [[package]]
- name = "tokio"
--version = "1.44.2"
-+version = "1.47.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "e6b88822cbe49de4185e3a4cbf8321dd487cf5fe0c5c65695fef6346371e9c48"
-+checksum = "43864ed400b6043a4757a25c7a64a8efde741aed79a056a2fb348a406701bb35"
- dependencies = [
-  "backtrace",
-  "bytes",
-+ "io-uring",
-  "libc",
-  "mio",
-  "parking_lot",
-  "pin-project-lite",
-  "signal-hook-registry",
-- "socket2 0.5.9",
-+ "slab",
-+ "socket2 0.6.0",
-  "tokio-macros",
-- "windows-sys 0.52.0",
-+ "windows-sys 0.59.0",
- ]
- 
- [[package]]
-@@ -3187,7 +3191,7 @@ checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -3205,9 +3209,9 @@ dependencies = [
- 
- [[package]]
- name = "toml"
--version = "0.7.8"
-+version = "0.8.23"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "dd79e69d3b627db300ff956027cc6c3798cef26d22526befdfcd12feeb6d2257"
-+checksum = "dc1beb996b9d83529a9e75c17a1686767d148d70663143c7854d8b4a09ced362"
- dependencies = [
-  "serde",
-  "serde_spanned",
-@@ -3217,26 +3221,33 @@ dependencies = [
- 
- [[package]]
- name = "toml_datetime"
--version = "0.6.8"
-+version = "0.6.11"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"
-+checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
- dependencies = [
-  "serde",
- ]
- 
- [[package]]
- name = "toml_edit"
--version = "0.19.15"
-+version = "0.22.27"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
-+checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
- dependencies = [
-  "indexmap",
-  "serde",
-  "serde_spanned",
-  "toml_datetime",
-+ "toml_write",
-  "winnow",
- ]
- 
-+[[package]]
-+name = "toml_write"
-+version = "0.1.2"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "5d99f8c9a7727884afe522e9bd5edbfc91a3312b36a77b5fb8926e4c31a41801"
-+
- [[package]]
- name = "tower-service"
- version = "0.3.3"
-@@ -3262,7 +3273,7 @@ checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -3469,9 +3480,9 @@ dependencies = [
- 
- [[package]]
- name = "wasi"
--version = "0.11.0+wasi-snapshot-preview1"
-+version = "0.11.1+wasi-snapshot-preview1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
-+checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"
- 
- [[package]]
- name = "wasm-bindgen"
-@@ -3494,7 +3505,7 @@ dependencies = [
-  "log",
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
-  "wasm-bindgen-shared",
- ]
- 
-@@ -3516,7 +3527,7 @@ checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
-  "wasm-bindgen-backend",
-  "wasm-bindgen-shared",
- ]
-@@ -3568,7 +3579,7 @@ version = "0.1.9"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
- dependencies = [
-- "windows-sys 0.52.0",
-+ "windows-sys 0.59.0",
- ]
- 
- [[package]]
-@@ -3597,6 +3608,12 @@ dependencies = [
-  "windows-targets 0.52.6",
- ]
- 
-+[[package]]
-+name = "windows-link"
-+version = "0.1.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"
-+
- [[package]]
- name = "windows-result"
- version = "0.1.2"
-@@ -3639,7 +3656,7 @@ version = "0.60.2"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
- dependencies = [
-- "windows-targets 0.53.2",
-+ "windows-targets 0.53.3",
- ]
- 
- [[package]]
-@@ -3675,10 +3692,11 @@ dependencies = [
- 
- [[package]]
- name = "windows-targets"
--version = "0.53.2"
-+version = "0.53.3"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "c66f69fcc9ce11da9966ddb31a40968cad001c5bedeb5c2b82ede4253ab48aef"
-+checksum = "d5fe6031c4041849d7c496a8ded650796e7b6ecc19df1a431c1a363342e5dc91"
- dependencies = [
-+ "windows-link",
-  "windows_aarch64_gnullvm 0.53.0",
-  "windows_aarch64_msvc 0.53.0",
-  "windows_i686_gnu 0.53.0",
-@@ -3829,9 +3847,9 @@ checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"
- 
- [[package]]
- name = "winnow"
--version = "0.5.40"
-+version = "0.7.12"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
-+checksum = "f3edebf492c8125044983378ecb5766203ad3b4c2f7a922bd7dd207f6d443e95"
- dependencies = [
-  "memchr",
- ]
-@@ -3940,28 +3958,28 @@ checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
-  "synstructure 0.13.2",
- ]
- 
- [[package]]
- name = "zerocopy"
--version = "0.8.24"
-+version = "0.8.26"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "2586fea28e186957ef732a5f8b3be2da217d65c5969d4b1e17f973ebbe876879"
-+checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
- dependencies = [
-  "zerocopy-derive",
- ]
- 
- [[package]]
- name = "zerocopy-derive"
--version = "0.8.24"
-+version = "0.8.26"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "a996a8f63c5c4448cd959ac1bab0aaa3306ccfd060472f85943ee0750f0169be"
-+checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -3981,7 +3999,7 @@ checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
-  "synstructure 0.13.2",
- ]
- 
-@@ -4002,7 +4020,7 @@ checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
- 
- [[package]]
-@@ -4035,5 +4053,5 @@ checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
- dependencies = [
-  "proc-macro2",
-  "quote",
-- "syn 2.0.100",
-+ "syn 2.0.104",
- ]
-diff --git a/Cargo.toml b/Cargo.toml
-index 934a8f5..f83628b 100644
---- a/Cargo.toml
-+++ b/Cargo.toml
-@@ -1,39 +1,56 @@
-+# Path: Cargo.toml
-+
- [workspace]
- resolver = "2"
- members = [
--    "crates/core",
-+    "crates/chain",
-     "crates/commitment_schemes",
--    "crates/state_trees",
--    "crates/transaction_models",
--    "crates/validator",
-+    "crates/consensus",
-+    "crates/core",
-     "crates/crypto",
-     "crates/homomorphic",
--    "crates/chain",
-     "crates/services",
--    "crates/consensus",
-+    "crates/state_trees",
-     "crates/test_utils",
-+    "crates/transaction_models",
-+    "crates/validator",
- ]
- 
- [workspace.dependencies]
--log = "0.4"
-+# Networking
-+libp2p = { version = "0.52.4", features = [
-+    "tokio",
-+    "tcp",
-+    "tls",
-+    "noise",
-+    "yamux",
-+    "gossipsub",
-+] }
-+
-+
-+# Async
-+tokio = { version = "1", features = ["full"] }
-+futures = "0.3"
-+async-trait = "0.1"
-+
-+# Serialization & Data Formats
- serde = { version = "1.0", features = ["derive"] }
--thiserror = "1.0"
--anyhow = "1.0"
--tokio = { version = "1.0", features = ["full"] }
- serde_json = "1.0"
--futures = "0.3"
-+toml = "0.8"
-+bytes = "1"
-+hex = "0.4"
- 
- # Cryptography
- sha2 = "0.10"
--ed25519-dalek = "2.0"
--curve25519-dalek = "4.1"
--
--# Utils
--bytes = "1.4"
- rand = "0.8"
--hex = "0.4"
-+curve2f519-dalek = "4.0"
-+dcrypt = { version = "0.12.0-beta.1", features = ["full"] }
- 
--[profile.release]
--opt-level = 3
--lto = true
--codegen-units = 1
-+# CLI & Logging
-+clap = { version = "4", features = ["derive"] }
-+log = "0.4"
-+env_logger = "0.10"
-+
-+# Error Handling
-+thiserror = "1.0"
-+anyhow = "1.0"
-diff --git a/TESTING.md b/TESTING.md
-deleted file mode 100644
-index 16ad199..0000000
---- a/TESTING.md
-+++ /dev/null
-@@ -1,4 +0,0 @@
--cargo build --release --features="depin-sdk-chain/mvsc-bin"
--
--./target/release/mvsc --state-file node1.json --config-dir ./config
--./target/release/mvsc --state-file node2.json --config-dir ./config
-\ No newline at end of file
-diff --git a/codebase_snapshot.md b/codebase_snapshot.md
-index 930eaaf..142dd82 100644
---- a/codebase_snapshot.md
-+++ b/codebase_snapshot.md
-@@ -1,12 +1,12 @@
- # Codebase Snapshot: crates
--Created: Sun Jul 27 10:33:24 PM UTC 2025
-+Created: Tue Jul 29 02:25:53 AM UTC 2025
- Target: /workspaces/depin-sdk/crates
- Line threshold for included files: 1500
- 
- ## Summary Statistics
- 
--* Total files: 150
--* Total directories: 111
-+* Total files: 152
-+* Total directories: 117
- 
- ### Directory: /workspaces/depin-sdk/crates
- 
-@@ -16,1353 +16,423 @@ Line threshold for included files: 1500
- 
- ###### Directory: chain/src/app
- 
--####### Directory: chain/src/app/tests
--
--######## File: chain/src/app/tests/mod.rs
--#####*Size: 12K, Lines: 353, Type: C source, ASCII text*
-+####### File: chain/src/app/mod.rs
-+####*Size: 12K, Lines: 225, Type: ASCII text*
- 
- ```rust
--use crate::app::*;
--use depin_sdk_commitment_schemes::merkle::MerkleCommitmentScheme;
--use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::{StateError, TransactionError};
--use depin_sdk_core::services::{ServiceType, UpgradableService};
--use depin_sdk_core::state::{StateManager, StateTree};
--use depin_sdk_core::transaction::TransactionModel;
--use depin_sdk_core::validator::{ValidatorModel, ValidatorType};
--use std::sync::Arc;
--use std::collections::HashMap;
--
--// Mock state tree implementation for testing
--struct MockStateTree {
--    data: HashMap<Vec<u8>, Vec<u8>>,
--    commitment_scheme: MerkleCommitmentScheme,
--}
--
--impl MockStateTree {
--    fn new(commitment_scheme: MerkleCommitmentScheme) -> Self {
--        Self {
--            data: HashMap::new(),
--            commitment_scheme,
--        }
--    }
--}
--
--impl StateTree for MockStateTree {
--    type Commitment = <MerkleCommitmentScheme as CommitmentScheme>::Commitment;
--    type Proof = <MerkleCommitmentScheme as CommitmentScheme>::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        Ok(self.data.get(key).cloned())
--    }
--
--    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        self.data.insert(key.to_vec(), value.to_vec());
--        Ok(())
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        self.data.remove(key);
--        Ok(())
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        // Simple implementation for testing
--        let values: Vec<Option<Vec<u8>>> = self.data.values()
--            .map(|v| Some(v.clone()))
--            .collect();
--        self.commitment_scheme.commit(&values)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        None // Simplified for testing
--    }
--
--    fn verify_proof(
--        &self,
--        _commitment: &Self::Commitment,
--        _proof: &Self::Proof,
--        _key: &[u8],
--        _value: &[u8],
--    ) -> bool {
--        true // Simplified for testing
--    }
--}
--
--impl StateManager for MockStateTree {
--    type Commitment = <MerkleCommitmentScheme as CommitmentScheme>::Commitment;
--    type Proof = <MerkleCommitmentScheme as CommitmentScheme>::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        <Self as StateTree>::get(self, key)
--    }
--
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::insert(self, key, value)
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::delete(self, key)
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        <Self as StateTree>::root_commitment(self)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        <Self as StateTree>::create_proof(self, key)
--    }
--
--    fn verify_proof(
--        &self,
--        commitment: &Self::Commitment,
--        proof: &Self::Proof,
--        key: &[u8],
--        value: &[u8],
--    ) -> bool {
--        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
--    }
--}
--
--// Mock transaction model for testing
--struct MockTransactionModel {
--    commitment_scheme: MerkleCommitmentScheme,
--}
--
--impl MockTransactionModel {
--    fn new(commitment_scheme: MerkleCommitmentScheme) -> Self {
--        Self { commitment_scheme }
--    }
--}
--
--#[derive(Clone)]
--struct MockTransaction {
--    id: Vec<u8>,
--}
--
--struct MockProof;
--
--impl TransactionModel for MockTransactionModel {
--    type Transaction = MockTransaction;
--    type Proof = MockProof;
--    type CommitmentScheme = MerkleCommitmentScheme;
--
--    fn validate<S>(&self, _tx: &Self::Transaction, _state: &S) -> Result<bool, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(true) // Always valid for testing
--    }
--
--    fn apply<S>(&self, _tx: &Self::Transaction, _state: &mut S) -> Result<(), TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(()) // No-op for testing
--    }
--
--    fn generate_proof<S>(&self, _tx: &Self::Transaction, _state: &S) -> Result<Self::Proof, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(MockProof)
--    }
--
--    fn verify_proof<S>(&self, _proof: &Self::Proof, _state: &S) -> Result<bool, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(true)
--    }
--
--    fn serialize_transaction(&self, _tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        Ok(vec![])
--    }
-+// Path: crates/chain/src/app/mod.rs
- 
--    fn deserialize_transaction(&self, _data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        Ok(MockTransaction { id: vec![] })
--    }
--}
--
--// Mock validator model for testing
--struct MockValidatorModel {
--    running: std::cell::RefCell<bool>,
--}
--
--impl MockValidatorModel {
--    fn new() -> Self {
--        Self {
--            running: std::cell::RefCell::new(false),
--        }
--    }
--}
--
--impl ValidatorModel for MockValidatorModel {
--    fn start(&self) -> Result<(), String> {
--        *self.running.borrow_mut() = true;
--        Ok(())
--    }
--
--    fn stop(&self) -> Result<(), String> {
--        *self.running.borrow_mut() = false;
--        Ok(())
--    }
--
--    fn is_running(&self) -> bool {
--        *self.running.borrow()
--    }
--
--    fn validator_type(&self) -> ValidatorType {
--        ValidatorType::Standard
--    }
--}
--
--// Helper function to create a test chain
--fn create_test_chain() -> SovereignAppChain<
--    MerkleCommitmentScheme,
--    MockStateTree,
--    MockTransactionModel,
--    MockValidatorModel,
--> {
--    let commitment_scheme = MerkleCommitmentScheme;
--    let state_tree = MockStateTree::new(commitment_scheme.clone());
--    let transaction_model = MockTransactionModel::new(commitment_scheme.clone());
--    let validator_model = MockValidatorModel::new();
--
--    SovereignAppChain::new(
--        commitment_scheme,
--        state_tree,
--        transaction_model,
--        validator_model,
--        "test-chain",
--        vec![], // No initial services for testing
--    )
--}
--
--// Helper function to create a sample transaction
--fn create_sample_transaction() -> MockTransaction {
--    MockTransaction {
--        id: vec![1, 2, 3],
--    }
--}
--
--#[test]
--fn test_chain_initialization() {
--    let chain = create_test_chain();
--
--    assert_eq!(chain.chain_id(), "test-chain");
--    assert_eq!(chain.status().height, 0);
--    assert_eq!(chain.status().total_transactions, 0);
--    assert_eq!(chain.status().is_running, false);
--}
-+//! The private implementation for the `SovereignChain` trait.
- 
--#[test]
--fn test_state_operations() {
--    let mut chain = create_test_chain();
--
--    // Test state update
--    let key = b"test-key";
--    let value = b"test-value";
--    chain.update_state(key, value).unwrap();
--
--    // Test state query
--    let retrieved = chain.query_state(key).unwrap();
--    assert_eq!(retrieved.unwrap(), value);
--
--    // Test state deletion
--    chain.delete_state(key).unwrap();
--    assert!(chain.query_state(key).is_none());
--}
--
--#[test]
--fn test_transaction_processing() {
--    let mut chain = create_test_chain();
--
--    let tx = create_sample_transaction();
--
--    // Test processing a single transaction
--    assert!(chain.process_transaction(&tx).is_ok());
--
--    // Test processing a batch of transactions
--    let txs = vec![tx.clone(), tx.clone()];
--    let results = chain.process_transactions(&txs).unwrap();
--
--    assert_eq!(results.len(), 2);
--    for result in results {
--        assert_eq!(result, "Success");
--    }
--}
--
--#[test]
--fn test_block_processing() {
--    let mut chain = create_test_chain();
--
--    // Start the chain
--    chain.start().unwrap();
--
--    // Create a block with transactions
--    let txs = vec![create_sample_transaction(), create_sample_transaction()];
--    let block = chain.create_block(txs);
--
--    // Verify the block height is correct
--    assert_eq!(block.header.height, 1);
--
--    // Process the block
--    assert!(chain.process_block(block).is_ok());
--
--    // Verify chain height increased
--    assert_eq!(chain.status().height, 1);
--
--    // Verify the block is in recent blocks
--    let retrieved_block = chain.get_block(1).unwrap();
--    assert_eq!(retrieved_block.header.height, 1);
--
--    // Verify latest block is accessible
--    let latest = chain.get_latest_block().unwrap();
--    assert_eq!(latest.header.height, 1);
--}
--
--#[test]
--fn test_chain_lifecycle() {
--    let mut chain = create_test_chain();
--
--    // Test start
--    chain.start().unwrap();
--    assert!(chain.status().is_running);
--
--    // Test stop
--    chain.stop().unwrap();
--    assert!(!chain.status().is_running);
--
--    // Test reset
--    chain.update_state(b"key", b"value").unwrap();
--    chain.reset().unwrap();
--    assert_eq!(chain.status().height, 0);
--    assert_eq!(chain.status().total_transactions, 0);
--    assert!(!chain.status().is_running);
--}
--
--#[test]
--fn test_max_recent_blocks() {
--    let mut chain = create_test_chain();
--
--    // Set a small limit
--    chain.set_max_recent_blocks(2);
--
--    // Start the chain
--    chain.start().unwrap();
--
--    // Process several blocks
--    for _ in 0..3 {
--        let txs = vec![create_sample_transaction()];
--        let block = chain.create_block(txs);
--        chain.process_block(block).unwrap();
--    }
--
--    // Verify we only have the latest 2 blocks
--    assert!(chain.get_block(1).is_none()); // Should be removed
--    assert!(chain.get_block(2).is_some()); // Should be present
--    assert!(chain.get_block(3).is_some()); // Should be present
--}```
--
--####### File: chain/src/app/mod.rs
--####*Size: 20K, Lines: 569, Type: ASCII text*
--
--```rust
-+use crate::upgrade_manager::ModuleUpgradeManager;
-+use async_trait::async_trait;
-+use depin_sdk_core::app::{Block, BlockHeader, ChainError, ChainStatus, SovereignAppChain};
-+use depin_sdk_core::chain::SovereignChain;
- use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::CoreError;
--use depin_sdk_core::services::{ServiceType, UpgradableService};
--use depin_sdk_core::state::{StateManager, StateTree};
-+// REMOVED: Unused import `StateError`
-+use depin_sdk_core::services::UpgradableService;
-+// REMOVED: Unused import `StateTree`
-+use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use depin_sdk_core::validator::ValidatorModel;
--use crate::upgrade_manager::ModuleUpgradeManager;
--use depin_sdk_state_trees::file::FileStateTree;
--use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
--
-+use depin_sdk_core::validator::WorkloadContainer;
-+use depin_sdk_validator::traits::WorkloadLogic;
-+use std::fmt::Debug;
- use std::sync::Arc;
--use std::time::{Duration, SystemTime, UNIX_EPOCH};
--
--/// Block header containing metadata
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct BlockHeader {
--    /// Block height
--    pub height: u64,
--    /// Previous block hash
--    pub prev_hash: Vec<u8>,
--    /// State root commitment
--    pub state_root: Vec<u8>,
--    /// Transactions root (e.g., Merkle root of transactions)
--    pub transactions_root: Vec<u8>,
--    /// Block timestamp (Unix timestamp in seconds)
--    pub timestamp: u64,
--}
-+use std::time::{SystemTime, UNIX_EPOCH};
- 
--/// Block structure containing transactions
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct Block<T> {
--    /// Block header
--    pub header: BlockHeader,
--    /// Transactions included in this block
--    pub transactions: Vec<T>,
--}
-+// Define a well-known key for storing the chain status in the state tree.
-+const STATUS_KEY: &[u8] = b"chain::status";
- 
--/// Chain status information
--#[derive(Debug, Clone)]
--pub struct ChainStatus {
--    /// Current block height
--    pub height: u64,
--    /// Latest block timestamp
--    pub latest_timestamp: u64,
--    /// Number of transactions processed
--    pub total_transactions: u64,
--    /// Chain running status
--    pub is_running: bool,
--}
--
--/// Implementation of sovereign app chain with runtime-swappable modules
--pub struct SovereignAppChain<CS, ST, TM, VM>
--where
--    CS: CommitmentScheme,
--    // Specify that ST implements both StateTree and StateManager with the specific commitment types
--    ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
--        + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>,
--    TM: TransactionModel,
--    VM: ValidatorModel,
--    // Ensure the transaction model's commitment scheme uses the same types
--    TM::CommitmentScheme: CommitmentScheme<Commitment = CS::Commitment, Proof = CS::Proof>,
--{
--    /// Commitment scheme
--    commitment_scheme: CS,
--    /// State tree
--    state_tree: ST,
--    /// Transaction model
--    transaction_model: TM,
--    /// Validator model
--    validator_model: VM,
--    /// Module upgrade manager for runtime-swappable services
-+/// A container struct that holds the chain's data (`SovereignAppChain`) and its
-+/// associated logic managers (`ModuleUpgradeManager`).
-+/// This struct implements the `SovereignChain` trait.
-+#[derive(Debug)]
-+pub struct ChainLogic<CS, TM: TransactionModel> {
-+    app_chain: SovereignAppChain<CS, TM>,
-+    #[allow(dead_code)]
-     service_manager: ModuleUpgradeManager,
--    /// Chain ID
--    chain_id: String,
--    /// Current status
--    status: ChainStatus,
--    /// Latest blocks (limited cache)
--    recent_blocks: Vec<Block<TM::Transaction>>,
--    /// Maximum blocks to keep in memory
--    max_recent_blocks: usize,
- }
- 
--impl<CS, ST, TM, VM> SovereignAppChain<CS, ST, TM, VM>
-+impl<CS, TM> ChainLogic<CS, TM>
- where
-     CS: CommitmentScheme,
--    ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
--        + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>,
--    TM: TransactionModel,
--    VM: ValidatorModel,
--    TM::CommitmentScheme: CommitmentScheme<Commitment = CS::Commitment, Proof = CS::Proof>,
-+    TM: TransactionModel<CommitmentScheme = CS>,
- {
--    /// Create a new sovereign app chain with runtime-swappable services
-+    /// The `new` constructor is an inherent method on the logic struct,
-+    /// which allows the `SovereignChain` trait to be object-safe.
-     pub fn new(
-         commitment_scheme: CS,
--        state_tree: ST,
-         transaction_model: TM,
--        validator_model: VM,
-         chain_id: &str,
-         initial_services: Vec<Arc<dyn UpgradableService>>,
-     ) -> Self {
-+        // This now creates a default/genesis status, which will be overwritten
-+        // by load_or_initialize_status if state exists.
-         let status = ChainStatus {
-             height: 0,
-             latest_timestamp: SystemTime::now()
-                 .duration_since(UNIX_EPOCH)
--                .unwrap_or(Duration::from_secs(0))
-+                .unwrap()
-                 .as_secs(),
-             total_transactions: 0,
-             is_running: false,
-         };
- 
--        // Initialize the module upgrade manager with initial services
-         let mut service_manager = ModuleUpgradeManager::new();
-         for service in initial_services {
-             service_manager.register_service(service);
-         }
- 
--        Self {
-+        let app_chain = SovereignAppChain {
-             commitment_scheme,
--            state_tree,
-             transaction_model,
--            validator_model,
--            service_manager,
-             chain_id: chain_id.to_string(),
-             status,
-             recent_blocks: Vec::new(),
--            max_recent_blocks: 100, // Default to storing last 100 blocks
--        }
--    }
--
--    /// Get the chain ID
--    pub fn chain_id(&self) -> &str {
--        &self.chain_id
--    }
--
--    /// Get the current chain status
--    pub fn status(&self) -> &ChainStatus {
--        &self.status
--    }
--
--    /// Get a reference to the service manager
--    pub fn service_manager(&self) -> &ModuleUpgradeManager {
--        &self.service_manager
--    }
--
--    /// Get a mutable reference to the service manager
--    pub fn service_manager_mut(&mut self) -> &mut ModuleUpgradeManager {
--        &mut self.service_manager
--    }
--
--    //
--    // Service Interaction Methods
--    //
--
--    /// Get a service by type
--    pub fn get_service(&self, service_type: &ServiceType) -> Option<Arc<dyn UpgradableService>> {
--        self.service_manager.get_service(service_type)
--    }
--
--    /// Submit a governance proposal (if governance service is available)
--    pub fn submit_governance_proposal(&self, proposal_data: &[u8]) -> Result<(), CoreError> {
--        let governance = self
--            .service_manager
--            .get_service(&ServiceType::Governance)
--            .ok_or(CoreError::ServiceNotFound("Governance".to_string()))?;
--
--        // Call the governance service's proposal submission method
--        // Note: This assumes a GovernanceService trait with submit_proposal method
--        // governance.submit_proposal(proposal_data)
--
--        // For now, return Ok as we don't have the actual trait definition
--        Ok(())
--    }
--
--    /// Query external data (if external data service is available)
--    pub fn query_external_data(&self, query: &str) -> Result<Vec<u8>, CoreError> {
--        let external_data = self
--            .service_manager
--            .get_service(&ServiceType::ExternalData)
--            .ok_or(CoreError::ServiceNotFound("ExternalData".to_string()))?;
--
--        // Call the external data service's query method
--        // external_data.fetch_data(query)
--
--        // For now, return placeholder
--        Ok(vec![])
--    }
--
--    /// Execute semantic interpretation (if semantic service is available)
--    pub fn interpret_semantic(&self, input: &str) -> Result<String, CoreError> {
--        let semantic = self
--            .service_manager
--            .get_service(&ServiceType::Semantic)
--            .ok_or(CoreError::ServiceNotFound("Semantic".to_string()))?;
--
--        // Call the semantic service's interpretation method
--        // semantic.interpret(input)
--
--        // For now, return placeholder
--        Ok("Interpretation not implemented".to_string())
--    }
--
--    //
--    // 1. State Management Methods
--    //
--
--    /// Query a value from the state tree
--    pub fn query_state(&self, key: &[u8]) -> Option<Vec<u8>> {
--        // Use expect to handle the Result and extract the Option
--        <ST as StateTree>::get(&self.state_tree, key).expect("State access error")
--    }
--
--    /// Get the current state root commitment
--    pub fn get_state_commitment(&self) -> CS::Commitment {
--        <ST as StateTree>::root_commitment(&self.state_tree)
--    }
--
--    /// Create a proof for a key
--    pub fn create_state_proof(&self, key: &[u8]) -> Option<CS::Proof> {
--        <ST as StateTree>::create_proof(&self.state_tree, key)
--    }
--
--    /// Verify a state proof
--    pub fn verify_state_proof(
--        &self,
--        commitment: &CS::Commitment,
--        proof: &CS::Proof,
--        key: &[u8],
--        value: &[u8],
--    ) -> bool {
--        <ST as StateTree>::verify_proof(&self.state_tree, commitment, proof, key, value)
--    }
--
--    /// Update state directly (administrative function)
--    pub fn update_state(&mut self, key: &[u8], value: &[u8]) -> Result<(), String> {
--        <ST as StateTree>::insert(&mut self.state_tree, key, value)
--            .map_err(|e| format!("State error: {}", e))
--    }
--
--    /// Delete a key from state (administrative function)
--    pub fn delete_state(&mut self, key: &[u8]) -> Result<(), String> {
--        <ST as StateTree>::delete(&mut self.state_tree, key)
--            .map_err(|e| format!("State error: {}", e))
--    }
--
--    //
--    // 2. Transaction Processing Methods
--    //
--
--    /// Process a transaction
--    pub fn process_transaction(&mut self, tx: &TM::Transaction) -> Result<(), String> {
--        // Validate the transaction against current state
--        // Pass the state_tree itself, not just the commitment
--        match self.transaction_model.validate(tx, &self.state_tree) {
--            Ok(valid) => {
--                if !valid {
--                    return Err("Transaction validation failed".to_string());
--                }
--            }
--            Err(e) => return Err(format!("Validation error: {}", e)),
--        }
--
--        // Apply the transaction to state - map error to String
--        match self.transaction_model.apply(tx, &mut self.state_tree) {
--            Ok(_) => {
--                // Update statistics on success
--                self.status.total_transactions += 1;
--                Ok(())
--            }
--            Err(e) => Err(format!("Transaction application failed: {}", e)),
--        }
--    }
--
--    /// Process a batch of transactions
--    pub fn process_transactions(&mut self, txs: &[TM::Transaction]) -> Result<Vec<String>, String> {
--        let mut results = Vec::with_capacity(txs.len());
-+            max_recent_blocks: 100,
-+        };
- 
--        for tx in txs {
--            match self.process_transaction(tx) {
--                Ok(()) => results.push("Success".to_string()),
--                Err(e) => results.push(e),
--            }
-+        Self {
-+            app_chain,
-+            service_manager,
-         }
--
--        Ok(results)
-     }
- 
--    //
--    // 3. Block Processing Methods
--    //
--
--    /// Process a block
--    pub fn process_block(&mut self, mut block: Block<TM::Transaction>) -> Result<(), String>
-+    /// [NEW METHOD] Loads chain status from the state manager, or initializes it if not found.
-+    pub async fn load_or_initialize_status<ST>(
-+        &mut self,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError>
-     where
--        CS: Clone,
--        CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+        ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
-     {
--        // Ensure block is built on current chain state
--        if block.header.height != self.status.height + 1 {
--            return Err(format!(
--                "Invalid block height: expected {}, got {}",
--                self.status.height + 1,
--                block.header.height
--            ));
--        }
--
--        // Verify block timestamp is reasonable
--        let now = SystemTime::now()
--            .duration_since(UNIX_EPOCH)
--            .unwrap_or(Duration::from_secs(0))
--            .as_secs();
--
--        if block.header.timestamp > now + 60 {
--            // Allow 1 minute clock drift
--            return Err("Block timestamp is in the future".to_string());
--        }
--
--        // Validate block using validator_model
--        if !self.validator_model.is_running() {
--            self.validator_model
--                .start()
--                .map_err(|e| format!("Failed to start validator: {}", e))?;
--        }
--
--        // Process all transactions
--        let mut tx_results = Vec::new();
--        for tx in &block.transactions {
--            match self.process_transaction(tx) {
--                Ok(()) => tx_results.push(true),
--                Err(e) => {
--                    tx_results.push(false);
--                    return Err(format!("Transaction processing failed: {}", e));
--                }
--            }
--        }
--
--        // Update state root in block header to match current state
--        let current_state_root = <ST as StateTree>::root_commitment(&self.state_tree);
--        block.header.state_root = current_state_root.as_ref().to_vec();
--
--        // Check for and apply any module upgrades scheduled for this block height
--        // This happens after transaction processing but before finalizing the block
--        match self
--            .service_manager
--            .apply_upgrades_at_height(block.header.height)
--        {
--            Ok(upgrades_applied) => {
--                if upgrades_applied > 0 {
--                    println!(
--                        "Applied {} module upgrades at height {}",
--                        upgrades_applied, block.header.height
--                    );
--                }
--            }
--            Err(e) => {
--                return Err(format!("Failed to apply module upgrades: {}", e));
--            }
--        }
--
--        // Update chain status
--        self.status.height = block.header.height;
--        self.status.latest_timestamp = block.header.timestamp;
--
--        // Add block to recent blocks cache
--        self.recent_blocks.push(block);
--        if self.recent_blocks.len() > self.max_recent_blocks {
--            self.recent_blocks.remove(0); // Remove oldest block
--        }
--
--        // Periodically save state if the state tree supports it (e.g., FileStateTree)
--        if self.status.height % 10 == 0 {
--            // This uses `as_any()` and `downcast_ref` to check if the state tree is a `FileStateTree`
--            // without breaking the generic `ST` constraint. This is a common pattern for
--            // accessing concrete type features from generic code.
--            if let Some(persistable_tree) = self.state_tree.as_any().downcast_ref::<FileStateTree<CS>>() {
--                // Now valid because of the `where` clause on this method
--                if let Err(e) = persistable_tree.save() {
--                    eprintln!("[Warning] Periodic state save failed at height {}: {}", self.status.height, e);
--                } else {
--                    println!("State periodically saved at height {}", self.status.height);
--                }
-+        // FIX: Create a longer-lived binding for the Arc<Mutex> to solve the lifetime error.
-+        let state_tree = workload.state_tree();
-+        let mut state = state_tree.lock().await;
-+
-+        match state.get(STATUS_KEY) {
-+            Ok(Some(status_bytes)) => {
-+                let status: ChainStatus = serde_json::from_slice(&status_bytes)
-+                    .map_err(|e| ChainError::Transaction(format!("Failed to deserialize status: {}", e)))?;
-+                log::info!("Loaded chain status: height {}", status.height);
-+                self.app_chain.status = status;
-+            }
-+            Ok(None) => {
-+                log::info!("No existing chain status found. Initializing and saving genesis status.");
-+                let status_bytes = serde_json::to_vec(&self.app_chain.status).unwrap();
-+                state
-+                    .insert(STATUS_KEY, &status_bytes)
-+                    .map_err(|e| ChainError::Transaction(e.to_string()))?;
-             }
-+            Err(e) => return Err(ChainError::Transaction(e.to_string())),
-         }
--
--
-         Ok(())
-     }
-+}
- 
--    /// Create a new block (for validators/block producers)
--    pub fn create_block(&self, transactions: Vec<TM::Transaction>) -> Block<TM::Transaction> {
--        let prev_hash = if self.recent_blocks.is_empty() {
--            vec![0; 32] // Genesis block
--        } else {
--            // In a real implementation, this would be the hash of the latest block
--            // For simplicity, we'll use the serialized state root as the prev hash
--            <ST as StateTree>::root_commitment(&self.state_tree)
--                .as_ref()
--                .to_vec()
--        };
--
--        let header = BlockHeader {
--            height: self.status.height + 1,
--            prev_hash,
--            state_root: <ST as StateTree>::root_commitment(&self.state_tree)
--                .as_ref()
--                .to_vec(),
--            transactions_root: vec![0; 32], // Simplified - would compute actual Merkle root
--            timestamp: SystemTime::now()
--                .duration_since(UNIX_EPOCH)
--                .unwrap_or(Duration::from_secs(0))
--                .as_secs(),
--        };
--
--        Block {
--            header,
--            transactions,
--        }
--    }
--
--    /// Get a recent block by height
--    pub fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>> {
--        self.recent_blocks
--            .iter()
--            .find(|block| block.header.height == height)
-+/// Implements the `dyn`-safe `SovereignChain` trait for the `ChainLogic` struct.
-+#[async_trait]
-+impl<CS, TM, ST> SovereignChain<CS, TM, ST> for ChainLogic<CS, TM>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static + Debug,
-+    TM::Transaction: Clone + Send + Sync + Debug,
-+    CS::Commitment: Send + Sync + Debug,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
-+{
-+    fn status(&self) -> &ChainStatus {
-+        &self.app_chain.status
-     }
- 
--    /// Get the latest block
--    pub fn get_latest_block(&self) -> Option<&Block<TM::Transaction>> {
--        self.recent_blocks.last()
-+    fn transaction_model(&self) -> &TM {
-+        &self.app_chain.transaction_model
-     }
- 
--    //
--    // 4. Enhanced Start/Stop Methods
--    //
--
--    /// Start the chain with proper initialization
--    pub fn start(&mut self) -> Result<(), String> {
--        println!("Starting sovereign app chain: {}", self.chain_id);
--
--        // Initialize validator
--        self.validator_model
--            .start()
--            .map_err(|e| format!("Failed to start validator: {}", e))?;
--
--        // Start all registered services
--        self.service_manager
--            .start_all_services()
--            .map_err(|e| format!("Failed to start services: {}", e))?;
--
--        // Initialize state (in a real implementation, would load from persistent storage)
--        // For now, we'll just use the existing state
--
--        // Update status
--        self.status.is_running = true;
--        self.status.latest_timestamp = SystemTime::now()
--            .duration_since(UNIX_EPOCH)
--            .unwrap_or(Duration::from_secs(0))
--            .as_secs();
--
--        println!(
--            "Sovereign app chain started successfully: {}",
--            self.chain_id
--        );
--
--        Ok(())
--    }
--
--    /// Stop the chain
--    pub fn stop(&mut self) -> Result<(), String> {
--        println!("Stopping sovereign app chain: {}", self.chain_id);
--
--        // Stop all services
--        self.service_manager
--            .stop_all_services()
--            .map_err(|e| format!("Failed to stop services: {}", e))?;
--
--        // Stop the validator
--        self.validator_model
--            .stop()
--            .map_err(|e| format!("Failed to stop validator: {}", e))?;
--
--        // In a real implementation, we would:
--        // 1. Persist state to storage
--        // 2. Close connections
--        // 3. Shutdown properly
--
--        // Update status
--        self.status.is_running = false;
--
--        println!(
--            "Sovereign app chain stopped successfully: {}",
--            self.chain_id
--        );
-+    /// Processes a transaction by delegating execution to the WorkloadContainer.
-+    async fn process_transaction(
-+        &mut self,
-+        tx: &TM::Transaction,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError> {
-+        workload
-+            .execute_transaction(
-+                tx,
-+                <Self as SovereignChain<CS, TM, ST>>::transaction_model(self),
-+            )
-+            .await
-+            .map_err(|e| ChainError::Transaction(e.to_string()))?;
- 
-+        self.app_chain.status.total_transactions += 1;
-         Ok(())
-     }
- 
--    /// Reset the chain (for testing purposes)
--    pub fn reset(&mut self) -> Result<(), String> {
--        // Stop the chain if running
--        if self.status.is_running {
--            self.stop()?;
-+    /// Processes a full block by iterating through its transactions and delegating
-+    /// each one to the WorkloadContainer for execution.
-+    async fn process_block(
-+        &mut self,
-+        mut block: Block<TM::Transaction>,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError> {
-+        if block.header.height != self.app_chain.status.height + 1 {
-+            return Err(ChainError::Block("Invalid block height".to_string()));
-         }
- 
--        // Reset service manager
--        self.service_manager.reset()
--            .map_err(|e| format!("Failed to reset service manager: {}", e))?;
--
--        // Reset state (implementation would depend on how ST can be reset)
--        // For demonstration purposes, assuming ST has no reset method
--
--        // Reset chain status
--        self.status = ChainStatus {
--            height: 0,
--            latest_timestamp: SystemTime::now()
--                .duration_since(UNIX_EPOCH)
--                .unwrap_or(Duration::from_secs(0))
--                .as_secs(),
--            total_transactions: 0,
--            is_running: false,
--        };
--
--        // Clear recent blocks
--        self.recent_blocks.clear();
--
--        Ok(())
--    }
-+        for tx in &block.transactions {
-+            self.process_transaction(tx, workload).await?;
-+        }
- 
--    /// Configure the maximum number of recent blocks to keep in memory
--    pub fn set_max_recent_blocks(&mut self, count: usize) {
--        self.max_recent_blocks = count;
-+        // After all transactions are processed, get the final state root from the workload container.
-+        let state_root =
-+            workload.state_tree().lock().await.root_commitment();
-+        block.header.state_root = state_root.as_ref().to_vec();
- 
--        // Trim if needed
--        while self.recent_blocks.len() > self.max_recent_blocks {
--            self.recent_blocks.remove(0);
-+        self.app_chain.status.height = block.header.height;
-+        self.app_chain.status.latest_timestamp = block.header.timestamp;
-+        self.app_chain.recent_blocks.push(block);
-+        if self.app_chain.recent_blocks.len() > self.app_chain.max_recent_blocks {
-+            self.app_chain.recent_blocks.remove(0);
-         }
--    }
--
--    /// Get the commitment scheme
--    pub fn commitment_scheme(&self) -> &CS {
--        &self.commitment_scheme
--    }
- 
--    /// Get the state tree
--    pub fn state_tree(&self) -> &ST {
--        &self.state_tree
--    }
-+        // [MODIFIED] Persist the updated status to the state tree.
-+        let status_bytes = serde_json::to_vec(&self.app_chain.status)
-+            .map_err(|e| ChainError::Transaction(format!("Failed to serialize status: {}", e)))?;
-+        workload
-+            .state_tree()
-+            .lock()
-+            .await
-+            .insert(STATUS_KEY, &status_bytes)
-+            .map_err(|e| ChainError::Transaction(e.to_string()))?;
- 
--    /// Get the transaction model
--    pub fn transaction_model(&self) -> &TM {
--        &self.transaction_model
-+        Ok(())
-     }
- 
--    /// Get the validator model
--    pub fn validator_model(&self) -> &VM {
--        &self.validator_model
--    }
-+    /// Creates a new block template to be filled by a block producer.
-+    fn create_block(
-+        &self,
-+        transactions: Vec<TM::Transaction>,
-+        _workload: &WorkloadContainer<ST>,
-+    ) -> Block<TM::Transaction> {
-+        let prev_hash = self
-+            .app_chain
-+            .recent_blocks
-+            .last()
-+            .map_or(vec![0; 32], |b| b.header.state_root.clone());
-+
-+        // FIX: The state_root here is just a placeholder. The real root is calculated
-+        // and overwritten in `process_block` after all transactions are executed.
-+        // We remove the illegal `block_on` call and just use the previous hash as the initial value.
-+        let state_root = prev_hash.clone();
- 
--    /// Check service health
--    pub fn check_service_health(&self) -> Vec<(ServiceType, bool)> {
--        self.service_manager.check_all_health()
-+        let header = BlockHeader {
-+            height: self.app_chain.status.height + 1,
-+            prev_hash,
-+            state_root,
-+            transactions_root: vec![0; 32],
-+            timestamp: SystemTime::now()
-+                .duration_since(UNIX_EPOCH)
-+                .unwrap()
-+                .as_secs(),
-+        };
-+        Block {
-+            header,
-+            transactions,
-+        }
-     }
- 
--    /// Get upgrade history for a service
--    pub fn get_service_history(&self, service_type: &ServiceType) -> Vec<u64> {
--        self.service_manager.get_upgrade_history(service_type)
-+    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>> {
-+        self.app_chain
-+            .recent_blocks
-+            .iter()
-+            .find(|b| b.header.height == height)
-     }
--}
--
--#[cfg(test)]
--mod tests;```
-+}```
- 
- ###### Directory: chain/src/bin
- 
- ####### File: chain/src/bin/mvsc.rs
--####*Size: 16K, Lines: 376, Type: C source, ASCII text*
-+####*Size: 8.0K, Lines: 104, Type: C source, ASCII text*
- 
- ```rust
-+// Path: crates/chain/src/bin/mvsc.rs
-+
- //! # Minimum Viable Single-Node Chain (MVSC)
- //!
--//! Now with persistence and P2P networking!
--//!
--//! This binary runs a blockchain node that can:
--//! 1. Persist its state to `state.json` and resume after a restart.
--//! 2. Discover other nodes on the local network using mDNS.
--//! 3. Gossip new blocks to peers using libp2p.
--//! 4. Process blocks received from peers.
-+//! This binary acts as the composition root for the validator node. It initializes
-+//! all core components (chain logic, state, containers) and wires them together.
- 
-+use anyhow::anyhow;
- use clap::Parser;
--use depin_sdk_chain::app::{Block, SovereignAppChain};
-+use depin_sdk_chain::ChainLogic;
- use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
--use depin_sdk_core::crypto::{SerializableKey, SigningKeyPair, SigningKey};
--use depin_sdk_core::validator::{ValidatorModel, ValidatorType};
--use depin_sdk_crypto::algorithms::hash::sha256;
--use depin_sdk_crypto::sign::eddsa::{Ed25519KeyPair, Ed25519PrivateKey};
--use depin_sdk_state_trees::file::FileStateTree; // Use our new FileStateTree
--use depin_sdk_transaction_models::utxo::{UTXOInput, UTXOOutput, UTXOTransaction, UTXOModel, UTXOOperations};
--use std::fs;
--
--use futures::stream::StreamExt;
--use libp2p::{gossipsub, mdns, swarm::SwarmEvent};
--use std::hash::{Hash, Hasher};
--use std::sync::{atomic::{AtomicU64, Ordering}, Arc};
--use std::time::Duration;
--use tokio::sync::{mpsc, Mutex, Notify};
--
--
--// --- LIBP2P NETWORKING SETUP ---
--
--// We create a custom network behaviour that combines Gossipsub and Mdns.
--#[derive(libp2p::swarm::NetworkBehaviour)]
--struct MyBehaviour {
--    gossipsub: gossipsub::Behaviour,
--    mdns: mdns::tokio::Behaviour,
--}
--
--const BLOCK_TOPIC: &str = "blocks";
--const KEYPAIR_SEED_FILE: &str = "keypair.seed";
--
--// --- COMMAND LINE ARGUMENTS ---
-+// FIX: Import the Container trait to bring start() and stop() methods into scope.
-+use depin_sdk_core::app::ChainError;
-+use depin_sdk_core::Container;
-+use depin_sdk_core::config::WorkloadConfig;
-+use depin_sdk_core::validator::WorkloadContainer;
-+use depin_sdk_state_trees::file::FileStateTree;
-+use depin_sdk_transaction_models::utxo::UTXOModel;
-+// FIXME: The following components must be made public in the `depin-sdk-validator` crate
-+// for this binary to compile. This requires editing `crates/validator/src/common/mod.rs`
-+// and `crates/validator/src/standard/mod.rs`.
-+use depin_sdk_validator::common::GuardianContainer;
-+use depin_sdk_validator::standard::OrchestrationContainer;
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
- 
- #[derive(Parser, Debug)]
- #[clap(name = "mvsc", about = "A minimum viable sovereign chain node.")]
- struct Opts {
--    /// Listening port for the p2p network.
--    #[clap(long, default_value = "0")]
--    listen_port: u16,
--
--    /// Flag to indicate if this node should produce blocks.
--    #[clap(long)]
--    is_producer: bool,
--
--    /// Path to the state file.
-     #[clap(long, default_value = "state.json")]
-     state_file: String,
--
--    /// Path to the keypair seed file.
--    #[clap(long, default_value = "keypair.seed")]
--    keypair_file: String,
--}
--
--
--// --- MOCK VALIDATOR MODEL ---
--// A simple validator model implementation for the in-memory chain.
--struct MockValidatorModel {
--    running: std::cell::RefCell<bool>,
--}
--
--impl MockValidatorModel {
--    fn new() -> Self { Self { running: std::cell::RefCell::new(false) } }
--}
--
--impl ValidatorModel for MockValidatorModel {
--    fn start(&self) -> Result<(), String> { *self.running.borrow_mut() = true; Ok(()) }
--    fn stop(&self) -> Result<(), String> { *self.running.borrow_mut() = false; Ok(()) }
--    fn is_running(&self) -> bool { *self.running.borrow() }
--    fn validator_type(&self) -> ValidatorType { ValidatorType::Standard }
--}
--
--// --- TRANSACTION CREATION HELPERS ---
--fn create_dummy_transaction(
--    keypair: &Ed25519KeyPair,
--    nonce: u64,
--    prev_txid: Vec<u8>,
--) -> UTXOTransaction {
--    let mut tx = UTXOTransaction {
--        txid: Vec::new(),
--        inputs: vec![UTXOInput {
--            prev_txid,
--            prev_index: 0,
--            signature: Vec::new(),
--        }],
--        outputs: vec![UTXOOutput {
--            value: 100,
--            lock_script: keypair.public_key().to_bytes(),
--        }],
--    };
--    let mut digest_data = Vec::new();
--    digest_data.extend_from_slice(&tx.inputs[0].prev_txid);
--    
--    let digest = sha256(&digest_data);
--    let signature = keypair.sign(&digest);
--    tx.inputs[0].signature = signature.to_bytes();
--    let mut txid_data = Vec::new();
--    txid_data.extend_from_slice(&digest);
--    txid_data.extend_from_slice(&tx.inputs[0].signature);
--    tx.txid = sha256(&txid_data);
--    tx
--}
--
--fn create_genesis_transaction(keypair: &Ed25519KeyPair) -> UTXOTransaction {
--    let mut tx = UTXOTransaction {
--        txid: Vec::new(),
--        inputs: vec![],
--        outputs: vec![UTXOOutput {
--            value: 1_000_000,
--            lock_script: keypair.public_key().to_bytes(),
--        }],
--    };
--    let mut digest_data = Vec::new();
--    digest_data.extend_from_slice(b"GENESIS");
--    digest_data.extend_from_slice(&tx.outputs[0].value.to_le_bytes());
--    digest_data.extend_from_slice(&tx.outputs[0].lock_script);
--    tx.txid = sha256(&digest_data);
--    tx
--}
--
--/// Loads a keypair from a seed file, or creates a new one if it doesn't exist.
--fn load_or_create_keypair(path: &str) -> Ed25519KeyPair {
--    match fs::read(path) {
--        Ok(seed_bytes) => {
--            log::info!("Loading persistent keypair from {}", path);
--            let private_key = Ed25519PrivateKey::from_bytes(&seed_bytes)
--                .expect("Failed to create private key from seed file");
--            Ed25519KeyPair::from_private_key(&private_key)
--        }
--        Err(_) => {
--            log::info!("No keypair found at {}, creating a new one.", path);
--            let keypair = Ed25519KeyPair::generate();
--            fs::write(path, keypair.private_key().to_bytes())
--                .expect("Failed to write new keypair seed to file");
--            keypair
--        }
--    }
-+    #[clap(long, default_value = "./config")]
-+    config_dir: String,
- }
- 
--
--// --- MAIN APPLICATION ---
- #[tokio::main]
- async fn main() -> anyhow::Result<()> {
-     env_logger::builder().filter_level(log::LevelFilter::Info).init();
-     let opts = Opts::parse();
-+    log::info!("Initializing DePIN SDK Node...");
- 
--    // --- CHAIN SETUP ---
--    log::info!("Starting Minimum Viable Sovereign Chain (MVSC)...");
-+    // --- 1. Initialize Independent Components ---
-     let commitment_scheme = HashCommitmentScheme::new();
--    let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
-     let transaction_model = UTXOModel::new(commitment_scheme.clone());
--    let validator_model = MockValidatorModel::new();
--
--    let chain = Arc::new(Mutex::new(SovereignAppChain::new(
--        commitment_scheme,
--        state_tree,
-+    let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
-+    let workload_config = WorkloadConfig { enabled_vms: vec!["WASM".to_string()] };
-+
-+    // --- 2. Build the Validator Containers ---
-+    let workload_container = Arc::new(WorkloadContainer::new(workload_config, state_tree));
-+
-+    // FIX: Correctly construct PathBuf from String and borrow it.
-+    let config_path = PathBuf::from(&opts.config_dir);
-+    let orchestration_container = Arc::new(
-+        OrchestrationContainer::<
-+            HashCommitmentScheme,
-+            UTXOModel<HashCommitmentScheme>,
-+            FileStateTree<HashCommitmentScheme>,
-+        >::new(&config_path.join("orchestration.toml"))
-+        .await?,
-+    );
-+    let guardian_container = GuardianContainer::new(
-+        &config_path.join("guardian.toml"),
-+    )?;
-+
-+    // --- 3. Create and Initialize the SovereignChain Logic ---
-+    // FIX: Move `transaction_model` instead of cloning it, as it's no longer needed here.
-+    let mut chain_logic = ChainLogic::new(
-+        commitment_scheme.clone(),
-         transaction_model,
--        validator_model,
-         "mvsc-chain-1",
-         vec![],
--    )));
--
--    // --- P2P NETWORK SETUP ---
--    let mut swarm = libp2p::SwarmBuilder::with_new_identity()
--        .with_tokio()
--        .with_tcp(
--            libp2p::tcp::Config::default(),
--            libp2p::noise::Config::new,
--            libp2p::yamux::Config::default,
--        )?
--        .with_behaviour(|key| {
--            let message_id_fn = |message: &gossipsub::Message| {
--                let mut s = std::collections::hash_map::DefaultHasher::new();
--                message.data.hash(&mut s);
--                gossipsub::MessageId::from(s.finish().to_string())
--            };
--            let gossipsub_config = gossipsub::ConfigBuilder::default()
--                .message_id_fn(message_id_fn)
--                // For a small test network, we don't need to wait for a mesh to form to publish.
--                .mesh_outbound_min(1)
--                .build()?;
--            Ok(MyBehaviour {
--                gossipsub: gossipsub::Behaviour::new(
--                    gossipsub::MessageAuthenticity::Signed(key.clone()),
--                    gossipsub_config,
--                )?,
--                mdns: mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?,
--            })
--        })?
--        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
--        .build();
--    
--    let topic = gossipsub::IdentTopic::new(BLOCK_TOPIC);
--    swarm.behaviour_mut().gossipsub.subscribe(&topic)?;
--
--    let listen_addr = format!("/ip4/0.0.0.0/tcp/{}", opts.listen_port);
--    swarm.listen_on(listen_addr.parse()?)?;
--    log::info!("Local Peer ID: {}", swarm.local_peer_id());
--
--    // Channel for the block producer to send new blocks to the main event loop.
--    let (block_tx, mut block_rx) = mpsc::channel::<Vec<u8>>(32);
--
--    // Notifier to signal the producer task when it's okay to start.
--    let producer_start_signal = Arc::new(Notify::new());
--
--    // --- BLOCK PRODUCTION (if enabled) ---
--    if opts.is_producer {
--        let chain_clone = Arc::clone(&chain);
--        let start_signal_clone = Arc::clone(&producer_start_signal);
--        let keypair_file = opts.keypair_file.clone();
--        tokio::spawn(async move {
--            let keypair = load_or_create_keypair(&keypair_file);
--            let nonce = AtomicU64::new(0);
--            let mut last_txid: Vec<u8>;
--
--            // Create and process genesis block if chain is new
--            {
--                let mut chain_lock = chain_clone.lock().await;
--                if chain_lock.status().height == 0 {
--                    log::info!("Block producer is waiting for the first peer to connect...");
--                    start_signal_clone.notified().await;
--                    
--                    // Give gossipsub a moment to establish the connection fully.
--                    tokio::time::sleep(Duration::from_secs(2)).await;
--                    log::info!("Peer connected! Creating and gossiping genesis block.");
--
--                    log::info!("Chain is at genesis height, creating genesis block...");
--                    let genesis_tx = create_genesis_transaction(&keypair);
--                    last_txid = genesis_tx.txid.clone();
--                    let genesis_block = chain_lock.create_block(vec![genesis_tx]);
--                    chain_lock.process_block(genesis_block.clone()).expect("Failed to process genesis block");
--                    
--                    let block_bytes = serde_json::to_vec(&genesis_block).unwrap();
--                    if let Err(e) = block_tx.send(block_bytes).await {
--                         log::error!("Failed to send genesis block to main loop: {:?}", e);
--                    }
--                } else {
--                    log::info!("Chain is at height {}, resuming block production.", chain_lock.status().height);
--                    // Find the last UTXO owned by this keypair to continue the transaction chain.
--                    // This is a naive scan; a real wallet would use an index.
--                    let tm = chain_lock.transaction_model();
--                    let pk_bytes = keypair.public_key().to_bytes();
--                    
--                    // This is a placeholder for finding the last txid.
--                    // For this demo, we'll restart with a new "coinbase" tx in the next block.
--                    // A proper implementation would require iterating through the state.
--                    let coinbase_tx = create_genesis_transaction(&keypair);
--                    last_txid = coinbase_tx.txid.clone();
--                    let block = chain_lock.create_block(vec![coinbase_tx]);
--                    chain_lock.process_block(block).expect("Failed to create resumption block");
--                }
--            }
--
-+    );
-+    // [MODIFIED] Load status from state or initialize it.
-+    chain_logic
-+        .load_or_initialize_status(&workload_container)
-+        .await
-+        .map_err(|e| anyhow!("Failed to load or initialize chain status: {:?}", e))?;
-+    let chain_ref: Arc<Mutex<ChainLogic<HashCommitmentScheme, UTXOModel<HashCommitmentScheme>>>> = Arc::new(Mutex::new(chain_logic));
-+
-+    // --- 4. Wire Up the Components (Inversion of Control) ---
-+    orchestration_container.set_chain_and_workload_ref(
-+        chain_ref.clone(),
-+        workload_container.clone(),
-+    );
- 
--            let mut interval = tokio::time::interval(Duration::from_secs(5));
--            loop {
--                interval.tick().await;
--                let current_nonce = nonce.fetch_add(1, Ordering::SeqCst);
--                let dummy_tx = create_dummy_transaction(&keypair, current_nonce, last_txid.clone());
--                last_txid = dummy_tx.txid.clone();
-+    // --- 5. Start the Validator Services ---
-+    // FIX: Add .await to all async start/stop calls.
-+    guardian_container.start().await.map_err(|e| anyhow!(e))?;
-+    orchestration_container.start().await.map_err(|e| anyhow!(e))?;
-+    workload_container.start().await.map_err(|e| anyhow!(e))?;
- 
--                let mut chain_lock = chain_clone.lock().await;
--                let block = chain_lock.create_block(vec![dummy_tx]);
--                
--                log::info!("Producing Block #{}", block.header.height);
--
--                match chain_lock.process_block(block.clone()) {
--                    Ok(_) => {
--                        let status = chain_lock.status();
--                        let state_commitment = chain_lock.get_state_commitment();
--                        let state_root: &[u8] = state_commitment.as_ref();
--                        log::info!(
--                            "Locally processed Block #{}. New State Root: 0x{}",
--                            status.height,
--                            hex::encode(state_root)
--                        );
--
--                        let block_bytes = serde_json::to_vec(&block).unwrap();
--                        if let Err(e) = block_tx.send(block_bytes).await {
--                            log::error!("Failed to send block to main loop: {:?}", e);
--                        }
--                    }
--                    Err(e) => {
--                        log::error!("Error processing locally produced block: {}", e);
--                    }
--                }
--            }
--        });
--    }
-+    log::info!("Node successfully started. Running indefinitely...");
- 
--    // --- MAIN EVENT LOOP ---
--    loop {
--        tokio::select! {
--            // Handle events from the p2p network
--            event = swarm.select_next_some() => {
--                match event {
--                    SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {
--                        for (peer_id, _multiaddr) in list {
--                            log::info!("mDNS discovered a new peer: {}", peer_id);
--                            swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
-+    // 6. Keep the main thread alive.
-+    tokio::signal::ctrl_c().await?;
- 
--                            producer_start_signal.notify_one();
--                        }
--                    }
--                    SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
--                        for (peer_id, _multiaddr) in list {
--                            log::info!("mDNS discover peer has expired: {}", peer_id);
--                            swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);
--                        }
--                    }
--                    SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {
--                        propagation_source: peer_id,
--                        message_id: id,
--                        message,
--                    })) => {
--                        log::info!(
--                            "Got new gossip message with id: {} from peer: {}",
--                            id,
--                            peer_id
--                        );
--                        
--                        type AppBlock = Block<UTXOTransaction>;
--                        match serde_json::from_slice::<AppBlock>(&message.data) {
--                            Ok(block) => {
--                                let mut chain_lock = chain.lock().await;
--                                log::info!("Received Block #{} from network.", block.header.height);
--
--                                if block.header.height <= chain_lock.status().height {
--                                    log::info!("Ignoring old or duplicate block (height {}). Current height is {}.", block.header.height, chain_lock.status().height);
--                                    continue;
--                                }
-+    log::info!("Shutdown signal received. Stopping node...");
-+    orchestration_container.stop().await.map_err(|e| anyhow!(e))?;
-+    workload_container.stop().await.map_err(|e| anyhow!(e))?;
-+    guardian_container.stop().await.map_err(|e| anyhow!(e))?;
-+    log::info!("Node stopped gracefully.");
- 
--                                match chain_lock.process_block(block) {
--                                    Ok(_) => {
--                                        let status = chain_lock.status();
--                                        let state_commitment = chain_lock.get_state_commitment();
--                                        let state_root: &[u8] = state_commitment.as_ref();
--                                        log::info!(
--                                            "Processed network Block #{}. New State Root: 0x{}",
--                                            status.height,
--                                            hex::encode(state_root)
--                                        );
--                                    }
--                                    Err(e) => {
--                                        log::error!("Error processing block from network: {}", e);
--                                    }
--                                }
--                            }
--                            Err(e) => {
--                                log::error!("Failed to deserialize block: {:?}", e);
--                            }
--                        }
--                    }
--                    SwarmEvent::NewListenAddr { address, .. } => {
--                        log::info!("Local node is listening on {}", address);
--                    }
--                    _ => {}
--                }
--            },
--            // Handle blocks produced locally that need to be gossiped
--            Some(block_to_gossip) = block_rx.recv() => {
--                if let Err(e) = swarm.behaviour_mut().gossipsub.publish(topic.clone(), block_to_gossip) {
--                    log::error!("Failed to publish block: {:?}", e);
--                }
--            }
--        }
--    }
-+    Ok(())
- }```
- 
--###### File: chain/src/lib.rs
--###*Size: 4.0K, Lines: 14, Type: ASCII text*
-+###### Directory: chain/src/traits
-+
-+####### File: chain/src/traits/mod.rs
-+####*Size: 4.0K, Lines: 56, Type: ASCII text*
- 
- ```rust
--//! # DePIN SDK Chain
--//!
--//! Chain implementation components for the DePIN SDK.
-+// Path: crates/chain/src/traits.rs
- 
--pub mod app;
--pub mod upgrade_manager;
-+//! This module defines the public traits that describe the core logic of a sovereign chain.
-+
-+use depin_sdk_core::app::{Block, ChainError, ChainStatus};
-+use depin_sdk_core::commitment::CommitmentScheme;
-+use depin_sdk_core::state::{StateManager, StateTree};
-+use depin_sdk_core::transaction::TransactionModel;
-+use depin_sdk_core::validator::WorkloadContainer;
-+
-+/// A trait that defines the logic and capabilities of a sovereign chain state machine.
-+// FIX: The `Sized` bound is removed, making this trait object-safe (`dyn`).
-+pub trait SovereignChain<CS, TM>
-+where
-+    CS: CommitmentScheme,
-+    TM: TransactionModel<CommitmentScheme = CS>,
-+{
-+    // FIX: `new` is removed from the trait. Construction is now an inherent method on the impl struct.
-+
-+    // Accessor methods remain.
-+    fn status(&self) -> &ChainStatus;
-+    fn transaction_model(&self) -> &TM;
-+
-+    fn process_transaction<ST>(
-+        &mut self,
-+        tx: &TM::Transaction,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError>
-+    where
-+        ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+            + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+            + Send + Sync + 'static;
- 
--// Re-export for convenience
--pub use upgrade_manager::ModuleUpgradeManager;
-+    fn process_block<ST>(
-+        &mut self,
-+        block: Block<TM::Transaction>,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError>
-+    where
-+        ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+            + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+            + Send + Sync + 'static,
-+        CS::Commitment: Send + Sync;
- 
--// Re-export consensus from its crate
--pub use depin_sdk_consensus as consensus;
-+    fn create_block<ST>(
-+        &self,
-+        transactions: Vec<TM::Transaction>,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Block<TM::Transaction>
-+    where
-+        ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+            + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+            + Send + Sync + 'static,
-+        CS::Commitment: Send + Sync;
-+    
-+    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>>;
-+}```
- 
--// TODO: Add governance crate when it's implemented
--// pub use depin_sdk_governance as governance;```
-+###### Directory: chain/src/upgrade_manager
- 
--###### File: chain/src/upgrade_manager.rs
--###*Size: 8.0K, Lines: 184, Type: ASCII text*
-+####### File: chain/src/upgrade_manager/mod.rs
-+####*Size: 8.0K, Lines: 193, Type: ASCII text*
- 
- ```rust
--use depin_sdk_core::services::{ServiceType, UpgradableService};
- use depin_sdk_core::error::CoreError;
-+use depin_sdk_core::services::{ServiceType, UpgradableService};
- use std::collections::HashMap;
-+use std::fmt;
- use std::sync::Arc;
- 
- /// Manages runtime upgrades of blockchain services
-@@ -1375,6 +445,18 @@ pub struct ModuleUpgradeManager {
-     scheduled_upgrades: HashMap<u64, Vec<(ServiceType, Vec<u8>)>>,
- }
- 
-+// FIX: Manually implement Debug because Arc<dyn UpgradableService> does not implement Debug.
-+// This implementation prints the service types instead of the service objects themselves.
-+impl fmt::Debug for ModuleUpgradeManager {
-+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-+        f.debug_struct("ModuleUpgradeManager")
-+            .field("active_services", &self.active_services.keys())
-+            .field("upgrade_history", &self.upgrade_history)
-+            .field("scheduled_upgrades", &self.scheduled_upgrades)
-+            .finish()
-+    }
-+}
-+
- impl ModuleUpgradeManager {
-     /// Create a new module upgrade manager
-     pub fn new() -> Self {
-@@ -1389,9 +471,11 @@ impl ModuleUpgradeManager {
-     pub fn register_service(&mut self, service: Arc<dyn UpgradableService>) {
-         let service_type = service.service_type();
-         self.active_services.insert(service_type.clone(), service);
--        
-+
-         // Initialize upgrade history if not present
--        self.upgrade_history.entry(service_type).or_insert_with(Vec::new);
-+        self.upgrade_history
-+            .entry(service_type)
-+            .or_insert_with(Vec::new);
-     }
- 
-     /// Get a service by type
-@@ -1410,7 +494,7 @@ impl ModuleUpgradeManager {
-             .entry(activation_height)
-             .or_insert_with(Vec::new)
-             .push((service_type, upgrade_data));
--        
-+
-         Ok(())
-     }
- 
-@@ -1422,7 +506,7 @@ impl ModuleUpgradeManager {
-         };
- 
-         let mut applied_count = 0;
--        
-+
-         for (service_type, upgrade_data) in upgrades {
-             match self.execute_upgrade(&service_type, &upgrade_data) {
-                 Ok(()) => {
-@@ -1454,13 +538,14 @@ impl ModuleUpgradeManager {
-             .ok_or_else(|| CoreError::ServiceNotFound(format!("{:?}", service_type)))?;
- 
-         // 1. Prepare: Get the state snapshot from the current service
--        let snapshot = active_service.prepare_upgrade(new_module_wasm)
-+        let _snapshot = active_service
-+            .prepare_upgrade(new_module_wasm)
-             .map_err(|e| CoreError::UpgradeError(e.to_string()))?;
- 
-         // 2. TODO: Instantiate new service from WASM (or other format)
-         // This would require a proper WASM loading mechanism
-         // For now, we'll create a placeholder
--        
-+
-         // 3. TODO: Complete the upgrade by migrating state to new service
-         // new_service.complete_upgrade(&snapshot)?;
- 
-@@ -1496,12 +581,12 @@ impl ModuleUpgradeManager {
-     /// Start all registered services
-     pub fn start_all_services(&mut self) -> Result<(), CoreError> {
-         for (service_type, service) in &self.active_services {
--            service.start()
--                .map_err(|e| CoreError::Custom(format!(
--                    "Failed to start service {:?}: {}", 
--                    service_type, 
--                    e
--                )))?;
-+            service.start().map_err(|e| {
-+                CoreError::Custom(format!(
-+                    "Failed to start service {:?}: {}",
-+                    service_type, e
-+                ))
-+            })?;
-         }
-         Ok(())
-     }
-@@ -1509,12 +594,9 @@ impl ModuleUpgradeManager {
-     /// Stop all registered services
-     pub fn stop_all_services(&mut self) -> Result<(), CoreError> {
-         for (service_type, service) in &self.active_services {
--            service.stop()
--                .map_err(|e| CoreError::Custom(format!(
--                    "Failed to stop service {:?}: {}", 
--                    service_type, 
--                    e
--                )))?;
-+            service.stop().map_err(|e| {
-+                CoreError::Custom(format!("Failed to stop service {:?}: {}", service_type, e))
-+            })?;
-         }
-         Ok(())
-     }
-@@ -1523,31 +605,43 @@ impl ModuleUpgradeManager {
-     pub fn reset(&mut self) -> Result<(), CoreError> {
-         // Stop all services first
-         self.stop_all_services()?;
--        
-+
-         // Clear all state
-         self.active_services.clear();
-         self.upgrade_history.clear();
-         self.scheduled_upgrades.clear();
--        
-+
-         Ok(())
-     }
- }
- 
- /// Helper function to load a service from WASM bytes
- /// TODO: Implement actual WASM loading logic
-+#[allow(dead_code)]
- fn load_service_from_wasm(_wasm_bytes: &[u8]) -> Result<Box<dyn UpgradableService>, CoreError> {
--    Err(CoreError::Custom("WASM loading not implemented yet".to_string()))
--}
-+    Err(CoreError::Custom(
-+        "WASM loading not implemented yet".to_string(),
-+    ))
-+}```
- 
--#[cfg(test)]
--mod tests {
--    use super::*;
-+###### File: chain/src/lib.rs
-+###*Size: 4.0K, Lines: 10, Type: ASCII text*
- 
--    // TODO: Add tests when the implementation is complete
--}```
-+```rust
-+//! # DePIN SDK Chain
-+//!
-+//! This crate provides the implementation logic for the `SovereignAppChain` state machine.
-+
-+mod app;
-+pub mod upgrade_manager;
-+pub mod traits;
-+
-+// FIX: Corrected the path to ChainLogic, removing the non-existent 'logic' module.
-+pub use app::ChainLogic;
-+pub use upgrade_manager::ModuleUpgradeManager;```
- 
- ##### File: chain/Cargo.toml
--##*Size: 4.0K, Lines: 57, Type: ASCII text*
-+##*Size: 4.0K, Lines: 45, Type: ASCII text*
- 
- ```toml
- [package]
-@@ -1569,32 +663,20 @@ serde = { workspace = true, features = ["derive"] }
- serde_json = { workspace = true }
- thiserror = { workspace = true }
- anyhow = { workspace = true }
--
--# Dependencies added for the mvsc binary, made optional
--depin-sdk-crypto = { path = "../crypto", optional = true }
- tokio = { workspace = true, features = ["full"], optional = true }
- futures = { workspace = true, optional = true }
--hex = { version = "0.4", optional = true }
--clap = { version = "4.3", features = ["derive"], optional = true }
--env_logger = { version = "0.10", optional = true }
--libp2p = { version = "0.52", features = [
--    "tokio",
--    "gossipsub",
--    "mdns",
--    "macros",
--    "tcp",
--    "noise",
--    "yamux",
--], optional = true }
--
-+hex = { workspace = true, optional = true }
-+clap = { workspace = true, features = ["derive"], optional = true }
-+env_logger = { workspace = true, optional = true }
-+libp2p = { workspace = true, optional = true }
-+# FIX: Add the missing async-trait dependency.
-+async-trait = { workspace = true }
- 
- [features]
- default = []
- tendermint = []
- custom-consensus = []
--# Feature to enable building the binary and its dependencies
- mvsc-bin = [
--    "dep:depin-sdk-crypto",
-     "dep:tokio",
-     "dep:futures",
-     "dep:hex",
-@@ -1616,19 +698,16 @@ required-features = ["mvsc-bin"]
- ###### Directory: commitment_schemes/src/elliptical_curve
- 
- ####### File: commitment_schemes/src/elliptical_curve/mod.rs
--####*Size: 16K, Lines: 390, Type: ASCII text*
-+####*Size: 16K, Lines: 381, Type: ASCII text*
- 
- ```rust
- //! Elliptical curve commitment implementation
- // File: crates/commitment_schemes/src/elliptical_curve/mod.rs
- //! Elliptical curve commitment implementation
- 
--use curve25519_dalek::ristretto::{CompressedRistretto, RistrettoPoint};
--use curve25519_dalek::scalar::Scalar;
--use curve25519_dalek::traits::Identity;
-+use depin_sdk_crypto::algorithms::hash;
-+use dcrypt::algorithms::ec::k256::{self as k256, Point, Scalar};
- use rand::{rngs::OsRng, RngCore};
--use sha2::{Digest, Sha512};
--use std::fmt::Debug;
- 
- use depin_sdk_core::commitment::{
-     CommitmentScheme, HomomorphicCommitmentScheme, HomomorphicOperation, ProofContext,
-@@ -1639,16 +718,16 @@ use depin_sdk_core::commitment::{
- #[derive(Debug, Clone)]
- pub struct EllipticalCurveCommitmentScheme {
-     /// Generator points
--    generators: Vec<RistrettoPoint>,
-+    generators: Vec<Point>,
- }
- 
- /// Elliptical curve commitment
- #[derive(Debug, Clone, PartialEq, Eq)]
--pub struct EllipticalCurveCommitment(CompressedRistretto);
-+pub struct EllipticalCurveCommitment([u8; k256::K256_POINT_COMPRESSED_SIZE]);
- 
- impl AsRef<[u8]> for EllipticalCurveCommitment {
-     fn as_ref(&self) -> &[u8] {
--        self.0.as_bytes()
-+        &self.0
-     }
- }
- 
-@@ -1668,39 +747,46 @@ impl EllipticalCurveCommitmentScheme {
-     pub fn new(num_generators: usize) -> Self {
-         // Generate deterministic generators for reproducible tests
-         let mut generators = Vec::with_capacity(num_generators);
-+        let g = k256::base_point_g();
-         for i in 0..num_generators {
--            // Use a SHA-512 hash to derive each generator point
--            let mut hasher = Sha512::new();
--            hasher.update(format!("generator-{}", i).as_bytes());
--            let hash = hasher.finalize();
--
--            let mut seed = [0u8; 64];
--            seed.copy_from_slice(&hash);
--
--            generators.push(RistrettoPoint::from_uniform_bytes(&seed));
-+            // Use a SHA-256 hash to derive a scalar for each generator point
-+            let scalar = Self::hash_to_scalar(format!("generator-{}", i).as_bytes());
-+            generators.push(g.mul(&scalar).expect("Failed to create generator"));
-         }
- 
-         Self { generators }
-     }
- 
-     /// Generate a random blinding factor
--    fn random_blinding() -> Scalar {
-+    fn random_blinding() -> k256::Scalar {
-         let mut rng = OsRng;
--        let mut bytes = [0u8; 64];
--        rng.fill_bytes(&mut bytes);
--        Scalar::from_bytes_mod_order_wide(&bytes)
-+        loop {
-+            let mut bytes = [0u8; 32];
-+            rng.fill_bytes(&mut bytes);
-+            if let Ok(scalar) = Scalar::new(bytes) {
-+                return scalar;
-+            }
-+        }
-     }
- 
-     /// Convert value to scalar
--    fn value_to_scalar(value: &impl AsRef<[u8]>) -> Scalar {
--        let mut hasher = Sha512::new();
--        hasher.update(value.as_ref());
--        let hash = hasher.finalize();
--
--        let mut scalar_bytes = [0u8; 64];
--        scalar_bytes.copy_from_slice(&hash);
-+    fn value_to_scalar(value: &impl AsRef<[u8]>) -> k256::Scalar {
-+        Self::hash_to_scalar(value.as_ref())
-+    }
- 
--        Scalar::from_bytes_mod_order_wide(&scalar_bytes)
-+    /// Helper to convert a hash to a valid scalar, retrying if needed.
-+    fn hash_to_scalar(data: &[u8]) -> k256::Scalar {
-+        let mut hash_bytes = hash::sha256(data);
-+        loop {
-+            // Create a fixed-size array from the vector's slice to avoid moving hash_bytes.
-+            let mut array = [0u8; 32];
-+            array.copy_from_slice(&hash_bytes);
-+            if let Ok(scalar) = Scalar::new(array) {
-+                return scalar;
-+            }
-+            // Re-hash if the hash corresponds to an invalid scalar (e.g., zero)
-+            hash_bytes = hash::sha256(&hash_bytes);
-+        }
-     }
- }
- 
-@@ -1711,7 +797,7 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
- 
-     fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-         // Start with identity point
--        let mut commitment_point = RistrettoPoint::identity();
-+        let mut commitment_point = Point::identity();
- 
-         // Use generators for each value
-         for (i, value_opt) in values.iter().enumerate() {
-@@ -1723,19 +809,21 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
-                 // Convert value to scalar
-                 let scalar = Self::value_to_scalar(value);
- 
--                // Add generator_i * value_scalar to commitment
--                commitment_point += self.generators[i] * scalar;
-+                // Add generator_i * value_scalar to the commitment point
-+                let term = self.generators[i].mul(&scalar).expect("Scalar mul failed");
-+                commitment_point = commitment_point.add(&term);
-             }
-         }
- 
-         // Add a random blinding factor with the last generator if we have one
-         if !self.generators.is_empty() {
-             let blinding = Self::random_blinding();
--            commitment_point += self.generators[self.generators.len() - 1] * blinding;
-+            let blinding_term = self.generators[self.generators.len() - 1].mul(&blinding).expect("Blinding failed");
-+            commitment_point = commitment_point.add(&blinding_term);
-         }
- 
--        // Return the compressed point
--        EllipticalCurveCommitment(commitment_point.compress())
-+        // Return the compressed point representation
-+        EllipticalCurveCommitment(commitment_point.serialize_compressed())
-     }
- 
-     fn create_proof(
-@@ -1826,17 +914,18 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
-         // Convert value to scalar
-         let value_scalar = Self::value_to_scalar(value);
- 
--        // Create a commitment to this single value with the provided blinding
--        let blinding_generator = self.generators[self.generators.len() - 1];
--        let computed_point =
--            (self.generators[position] * value_scalar) + (blinding_generator * proof.blinding);
-+        // Recreate the point for the value and blinding factor
-+        let blinding_generator = &self.generators[self.generators.len() - 1];
-+        let value_term = self.generators[position].mul(&value_scalar).expect("Scalar mul failed");
-+        let blinding_term = blinding_generator.mul(&proof.blinding).expect("Blinding failed");
-+        let computed_point = value_term.add(&blinding_term);
- 
-         // Check if the computed commitment matches the provided one
--        let computed_commitment = EllipticalCurveCommitment(computed_point.compress());
-+        let computed_commitment = EllipticalCurveCommitment(computed_point.serialize_compressed());
- 
-         // This is a simplified check - a real implementation would be more complex
-         // for multiple values
--        commitment.0 == computed_commitment.0
-+        commitment.as_ref() == computed_commitment.as_ref()
-     }
- 
-     fn scheme_id() -> SchemeIdentifier {
-@@ -1847,17 +936,13 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
- impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
-     fn add(&self, a: &Self::Commitment, b: &Self::Commitment) -> Result<Self::Commitment, String> {
-         // Decompress points
--        let point_a =
--            a.0.decompress()
--                .ok_or_else(|| "Invalid point in commitment A".to_string())?;
--        let point_b =
--            b.0.decompress()
--                .ok_or_else(|| "Invalid point in commitment B".to_string())?;
-+        let point_a = Point::deserialize_compressed(a.as_ref()).map_err(|e| e.to_string())?;
-+        let point_b = Point::deserialize_compressed(b.as_ref()).map_err(|e| e.to_string())?;
- 
-         // Homomorphic addition is point addition
--        let result_point = point_a + point_b;
-+        let result_point = point_a.add(&point_b);
- 
--        Ok(EllipticalCurveCommitment(result_point.compress()))
-+        Ok(EllipticalCurveCommitment(result_point.serialize_compressed()))
-     }
- 
-     fn scalar_multiply(
-@@ -1870,17 +955,17 @@ impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
-         }
- 
-         // Decompress point
--        let point =
--            a.0.decompress()
--                .ok_or_else(|| "Invalid point in commitment".to_string())?;
-+        let point = Point::deserialize_compressed(a.as_ref()).map_err(|e| e.to_string())?;
- 
--        // Convert i32 to Scalar
--        let s = Scalar::from(scalar as u64);
-+        // Convert i32 to Scalar. This is a simplified conversion for small, positive integers.
-+        let mut scalar_bytes = [0u8; 32];
-+        scalar_bytes[..8].copy_from_slice(&(scalar as u64).to_le_bytes());
-+        let s = Scalar::new(scalar_bytes).map_err(|e| e.to_string())?;
- 
-         // Scalar multiplication
--        let result_point = point * s;
-+        let result_point = point.mul(&s).map_err(|e| e.to_string())?;
- 
--        Ok(EllipticalCurveCommitment(result_point.compress()))
-+        Ok(EllipticalCurveCommitment(result_point.serialize_compressed()))
-     }
- 
-     fn supports_operation(&self, operation: HomomorphicOperation) -> bool {
-@@ -1894,30 +979,24 @@ impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
- // Add utility methods for EllipticalCurveCommitment
- impl EllipticalCurveCommitment {
-     /// Create a new EllipticalCurveCommitment from a compressed point
--    pub fn new(point: CompressedRistretto) -> Self {
-+    pub fn new(point: [u8; k256::K256_POINT_COMPRESSED_SIZE]) -> Self {
-         Self(point)
-     }
- 
-     /// Get the compressed point
--    pub fn point(&self) -> &CompressedRistretto {
-+    pub fn point(&self) -> &[u8; k256::K256_POINT_COMPRESSED_SIZE] {
-         &self.0
-     }
- 
-     /// Convert to a byte representation
-     pub fn to_bytes(&self) -> Vec<u8> {
--        self.0.as_bytes().to_vec()
-+        self.0.to_vec()
-     }
- 
-     /// Create from bytes
-     pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
--        if bytes.len() != 32 {
--            return Err("Invalid point length".to_string());
--        }
--
--        let mut array = [0u8; 32];
--        array.copy_from_slice(bytes);
--
--        Ok(Self(CompressedRistretto(array)))
-+        let array: [u8; k256::K256_POINT_COMPRESSED_SIZE] = bytes.try_into().map_err(|_| "Invalid point length".to_string())?;
-+        Ok(Self(array))
-     }
- }
- 
-@@ -1952,7 +1031,7 @@ impl EllipticalCurveProof {
-         let mut result = Vec::with_capacity(32 + 8 + self.value.len() + 4);
- 
-         // Serialize blinding factor (32 bytes)
--        result.extend_from_slice(self.blinding.as_bytes());
-+        result.extend_from_slice(self.blinding.serialize().as_ref());
- 
-         // Serialize position (8 bytes)
-         result.extend_from_slice(&self.position.to_le_bytes());
-@@ -1976,12 +1055,7 @@ impl EllipticalCurveProof {
-         // Read blinding
-         let mut blinding_bytes = [0u8; 32];
-         blinding_bytes.copy_from_slice(&bytes[pos..pos + 32]);
--        let maybe_blinding = Scalar::from_canonical_bytes(blinding_bytes);
--        let blinding = if maybe_blinding.is_some().into() {
--            maybe_blinding.unwrap()
--        } else {
--            return Err("Invalid blinding factor".to_string());
--        };
-+        let blinding = Scalar::new(blinding_bytes).map_err(|e| e.to_string())?;
-         pos += 32;
- 
-         // Read position
-@@ -2008,19 +1082,18 @@ impl EllipticalCurveProof {
-             value,
-         })
-     }
--}
--```
-+}```
- 
- ###### Directory: commitment_schemes/src/hash
- 
- ####### File: commitment_schemes/src/hash/mod.rs
--####*Size: 12K, Lines: 389, Type: ASCII text*
-+####*Size: 12K, Lines: 375, Type: ASCII text*
- 
- ```rust
- //! Hash-based commitment scheme implementations
- 
- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
--use sha2::{Digest, Sha256};
-+use depin_sdk_crypto::algorithms::hash;
- use std::fmt::Debug;
- 
- /// Hash-based commitment scheme
-@@ -2037,8 +1110,6 @@ pub enum HashFunction {
-     Sha256,
-     /// SHA-512
-     Sha512,
--    /// Keccak-256
--    Keccak256,
- }
- 
- /// Hash-based commitment
-@@ -2078,19 +1149,8 @@ impl HashCommitmentScheme {
-     /// Helper function to hash data using the selected hash function
-     pub fn hash_data(&self, data: &[u8]) -> Vec<u8> {
-         match self.hash_function {
--            HashFunction::Sha256 => {
--                let mut hasher = Sha256::new();
--                hasher.update(data);
--                hasher.finalize().to_vec()
--            }
--            HashFunction::Sha512 => {
--                // Implementation for SHA-512 would go here
--                vec![0; 64] // Placeholder
--            }
--            HashFunction::Keccak256 => {
--                // Implementation for Keccak-256 would go here
--                vec![0; 32] // Placeholder
--            }
-+            HashFunction::Sha256 => hash::sha256(data),
-+            HashFunction::Sha512 => hash::sha512(data),
-         }
-     }
- 
-@@ -2104,7 +1164,6 @@ impl HashCommitmentScheme {
-         match self.hash_function {
-             HashFunction::Sha256 => 32,
-             HashFunction::Sha512 => 64,
--            HashFunction::Keccak256 => 32,
-         }
-     }
- }
-@@ -2174,8 +1233,9 @@ impl CommitmentScheme for HashCommitmentScheme {
-         value: &Self::Value,
-         context: &ProofContext,
-     ) -> bool {
--        // Verify that selectors match
--        if !matches!(&proof.selector, selector) {
-+        // FIX: The compiler detected that `selector` was being compared to itself.
-+        // We need to compare the proof's selector with the one passed to the function.
-+        if &proof.selector != selector {
-             return false;
-         }
- 
-@@ -2405,8 +1465,7 @@ impl HashProof {
-             additional_data,
-         })
-     }
--}
--```
-+}```
- 
- ###### Directory: commitment_schemes/src/kzg
- 
-@@ -3037,12 +2096,12 @@ license = "MIT OR Apache-2.0"
- 
- [dependencies]
- depin-sdk-core = { path = "../core" }
-+depin-sdk-crypto = { path = "../crypto" }
-+dcrypt = { version = "0.12.0-beta.1", features = ["full"] }
- log = { workspace = true }
- serde = { workspace = true }
- thiserror = { workspace = true }
- bytes = { workspace = true }
--sha2 = { workspace = true }
--curve25519-dalek = { workspace = true }
- rand = { workspace = true }
- 
- [features]
-@@ -3216,6 +2275,108 @@ default = []
- 
- ##### Directory: core/src
- 
-+###### Directory: core/src/app
-+
-+####### File: core/src/app/mod.rs
-+####*Size: 4.0K, Lines: 46, Type: ASCII text*
-+
-+```rust
-+// Path: crates/core/src/app/mod.rs
-+
-+use crate::transaction::TransactionModel;
-+use serde::{Deserialize, Serialize};
-+
-+#[derive(Serialize, Deserialize, Debug)]
-+pub struct ChainStatus {
-+    pub height: u64,
-+    pub latest_timestamp: u64,
-+    pub total_transactions: u64,
-+    pub is_running: bool,
-+}
-+
-+// FIX: Add derive(Clone, Debug). Clone is needed for block processing,
-+// and Debug is needed for `.unwrap()` calls on Results containing the block.
-+#[derive(Serialize, Deserialize, Debug, Clone)]
-+pub struct Block<T> {
-+    pub header: BlockHeader,
-+    pub transactions: Vec<T>,
-+}
-+
-+#[derive(Serialize, Deserialize, Debug, Clone)]
-+pub struct BlockHeader {
-+    pub height: u64,
-+    pub prev_hash: Vec<u8>,
-+    pub state_root: Vec<u8>,
-+    pub transactions_root: Vec<u8>,
-+    pub timestamp: u64,
-+}
-+
-+#[derive(Debug)]
-+pub enum ChainError {
-+    Block(String),
-+    Transaction(String),
-+}
-+
-+/// A struct that holds the core, serializable state of a sovereign chain.
-+/// This is distinct from its logic, which is defined by the `SovereignChain` trait.
-+#[derive(Debug)]
-+pub struct SovereignAppChain<CS, TM: TransactionModel> {
-+    pub commitment_scheme: CS,
-+    pub transaction_model: TM,
-+    pub chain_id: String,
-+    pub status: ChainStatus,
-+    pub recent_blocks: Vec<Block<TM::Transaction>>,
-+    pub max_recent_blocks: usize,
-+}```
-+
-+###### Directory: core/src/chain
-+
-+####### File: core/src/chain/mod.rs
-+####*Size: 4.0K, Lines: 40, Type: ASCII text*
-+
-+```rust
-+// Path: crates/core/src/chain/mod.rs
-+
-+use crate::app::{Block, ChainError, ChainStatus};
-+use crate::commitment::CommitmentScheme;
-+use crate::state::StateManager;
-+use crate::transaction::TransactionModel;
-+use crate::validator::WorkloadContainer;
-+use async_trait::async_trait;
-+use std::fmt::Debug;
-+
-+/// A trait that defines the logic and capabilities of a sovereign chain state machine.
-+#[async_trait]
-+pub trait SovereignChain<CS, TM, ST>: Debug + Send
-+where
-+    CS: CommitmentScheme,
-+    TM: TransactionModel<CommitmentScheme = CS>,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
-+{
-+    fn status(&self) -> &ChainStatus;
-+    fn transaction_model(&self) -> &TM;
-+
-+    async fn process_transaction(
-+        &mut self,
-+        tx: &TM::Transaction,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError>;
-+
-+    async fn process_block(
-+        &mut self,
-+        block: Block<TM::Transaction>,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError>;
-+
-+    fn create_block(
-+        &self,
-+        transactions: Vec<TM::Transaction>,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Block<TM::Transaction>;
-+
-+    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>>;
-+}```
-+
- ###### Directory: core/src/commitment
- 
- ####### Directory: core/src/commitment/tests
-@@ -3798,6 +2959,25 @@ mod tests;
- pub use classification::*;
- ```
- 
-+###### Directory: core/src/config
-+
-+####### File: core/src/config/mod.rs
-+####*Size: 4.0K, Lines: 11, Type: ASCII text*
-+
-+```rust
-+// Path: crates/core/src/config/mod.rs
-+
-+//! Shared configuration structures for core DePIN SDK components.
-+
-+use serde::Deserialize;
-+
-+/// Configuration for the Workload container (`workload.toml`).
-+/// This is defined in `core` because it's part of the public `WorkloadContainer` struct.
-+#[derive(Debug, Deserialize, Clone)]
-+pub struct WorkloadConfig {
-+    pub enabled_vms: Vec<String>,
-+}```
-+
- ###### Directory: core/src/crypto
- 
- ####### Directory: core/src/crypto/tests
-@@ -4262,125 +3442,66 @@ mod tests;```
- ###### Directory: core/src/error
- 
- ####### File: core/src/error/mod.rs
--####*Size: 4.0K, Lines: 115, Type: ASCII text*
-+####*Size: 4.0K, Lines: 56, Type: ASCII text*
- 
- ```rust
--//! Error types for the DePIN SDK Core.
--
--use std::fmt;
--
--/// Error type for transaction operations
--#[derive(Debug, Clone, PartialEq, Eq)]
--pub enum TransactionError {
--    /// Invalid transaction format or data
--    InvalidTransaction(String),
--    
--    /// Failed to access or modify state
--    StateAccessFailed(String),
--    
--    /// Invalid input referenced in transaction
--    InvalidInput(String),
--    
--    /// Insufficient funds for transaction
--    InsufficientFunds(String),
--    
--    /// Invalid signature
--    InvalidSignature(String),
--    
--    /// Invalid nonce value
--    InvalidNonce(String),
--    
--    /// Serialization or deserialization error
--    SerializationError(String),
--    
--    /// Other transaction errors
--    Other(String),
--}
--
--impl fmt::Display for TransactionError {
--    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--        match self {
--            TransactionError::InvalidTransaction(msg) => write!(f, "Invalid transaction: {}", msg),
--            TransactionError::StateAccessFailed(msg) => write!(f, "State access failed: {}", msg),
--            TransactionError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
--            TransactionError::InsufficientFunds(msg) => write!(f, "Insufficient funds: {}", msg),
--            TransactionError::InvalidSignature(msg) => write!(f, "Invalid signature: {}", msg),
--            TransactionError::InvalidNonce(msg) => write!(f, "Invalid nonce: {}", msg),
--            TransactionError::SerializationError(msg) => write!(f, "Serialization error: {}", msg),
--            TransactionError::Other(msg) => write!(f, "Other error: {}", msg),
--        }
--    }
--}
-+// Path: crates/core/src/error/mod.rs
- 
--impl std::error::Error for TransactionError {}
-+use thiserror::Error;
- 
--/// Error type for state operations
--#[derive(Debug, Clone, PartialEq, Eq)]
-+#[derive(Error, Debug)]
- pub enum StateError {
--    /// Key not found in state
-+    #[error("Key not found: {0}")]
-     KeyNotFound(String),
--    
--    /// Failed to read from storage
--    ReadError(String),
--    
--    /// Failed to write to storage
-+    #[error("Validation failed: {0}")]
-+    Validation(String),
-+    #[error("Apply failed: {0}")]
-+    Apply(String),
-+    #[error("State backend error: {0}")]
-+    Backend(String),
-+    // FIX: Add variants for errors that occur in state tree implementations.
-+    // The `WriteError` is used by `FileStateTree` when file I/O fails.
-+    // The `InvalidValue` is used by `VerkleTree` when a value can't be converted.
-+    #[error("State write error: {0}")]
-     WriteError(String),
--    
--    /// Invalid key format
--    InvalidKey(String),
--    
--    /// Invalid value format
-+    #[error("Invalid value: {0}")]
-     InvalidValue(String),
--    
--    /// Other state errors
--    Other(String),
--}
--
--impl fmt::Display for StateError {
--    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--        match self {
--            StateError::KeyNotFound(msg) => write!(f, "Key not found: {}", msg),
--            StateError::ReadError(msg) => write!(f, "Read error: {}", msg),
--            StateError::WriteError(msg) => write!(f, "Write error: {}", msg),
--            StateError::InvalidKey(msg) => write!(f, "Invalid key: {}", msg),
--            StateError::InvalidValue(msg) => write!(f, "Invalid value: {}", msg),
--            StateError::Other(msg) => write!(f, "Other error: {}", msg),
--        }
--    }
- }
- 
--impl std::error::Error for StateError {}
--
--impl From<StateError> for TransactionError {
--    fn from(error: StateError) -> Self {
--        TransactionError::StateAccessFailed(error.to_string())
--    }
-+#[derive(Error, Debug)]
-+pub enum TransactionError {
-+    #[error("Serialization error: {0}")]
-+    Serialization(String),
-+    #[error("Deserialization error: {0}")]
-+    Deserialization(String),
-+    #[error("Invalid transaction: {0}")]
-+    Invalid(String),
-+    // FIX: Add a variant to wrap StateErrors, which will allow `?` to work.
-+    #[error("State error: {0}")]
-+    State(#[from] StateError),
-+}
-+
-+#[derive(Error, Debug)]
-+pub enum ValidatorError {
-+    #[error("Container '{0}' is already running")]
-+    AlreadyRunning(String),
-+    #[error("IO error: {0}")]
-+    Io(#[from] std::io::Error),
-+    #[error("Configuration error: {0}")]
-+    Config(String),
-+    #[error("Other error: {0}")]
-+    Other(String),
- }
- 
--/// Core error type for the SDK
--#[derive(Debug, thiserror::Error)]
-+#[derive(Debug, Error)]
- pub enum CoreError {
-     #[error("Service not found: {0}")]
-     ServiceNotFound(String),
--    
--    #[error("Invalid block: {0}")]
--    InvalidBlock(String),
--    
--    #[error("Consensus error: {0}")]
--    ConsensusError(String),
--    
--    #[error("Cryptographic error: {0}")]
--    CryptoError(String),
--    
-     #[error("Upgrade error: {0}")]
-     UpgradeError(String),
--    
-     #[error("Custom error: {0}")]
-     Custom(String),
--}
--
--/// Result type used throughout the SDK
--pub type Result<T> = std::result::Result<T, CoreError>;```
-+}```
- 
- ###### Directory: core/src/homomorphic
- 
-@@ -5236,93 +4357,38 @@ mod tests {
- ```
- 
- ####### File: core/src/state/manager.rs
--####*Size: 4.0K, Lines: 78, Type: ASCII text*
-+####*Size: 4.0K, Lines: 21, Type: ASCII text*
- 
- ```rust
--// File: crates/core/src/state/manager.rs
-+// Path: crates/core/src/state/manager.rs
- 
- use crate::error::StateError;
-+use crate::state::StateTree;
- 
--/// State manager interface for the DePIN SDK
-+/// State manager interface for the DePIN SDK.
- ///
--/// The StateManager provides a higher-level interface for state operations,
--/// potentially wrapping one or more state trees or other storage mechanisms.
--/// It provides key-value access with optional commitment scheme capabilities.
--pub trait StateManager {
--    /// The commitment type this manager uses
--    type Commitment;
--    
--    /// The proof type this manager uses
--    type Proof;
--    
--    /// Get a value by key
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError>;
--    
--    /// Set a value for a key
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError>;
--    
--    /// Delete a key-value pair
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError>;
--    
--    /// Set multiple key-value pairs in a single batch operation
--    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
--        // Default implementation applies updates one by one
--        for (key, value) in updates {
--            self.set(key, value)?;
--        }
--        Ok(())
--    }
--    
--    /// Get multiple values by keys in a single batch operation
--    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
--        // Default implementation retrieves values one by one
--        let mut values = Vec::with_capacity(keys.len());
--        for key in keys {
--            values.push(self.get(key)?);
--        }
--        Ok(values)
--    }
--    
--    /// Get the current root commitment
--    ///
--    /// # Returns
--    /// * The current root commitment
--    fn root_commitment(&self) -> Self::Commitment;
--    
--    /// Create a proof for a specific key
--    ///
--    /// # Arguments
--    /// * `key` - The key to create a proof for
--    ///
--    /// # Returns
--    /// * `Some(proof)` - If proof creation succeeded
--    /// * `None` - If the key doesn't exist or proof creation isn't supported
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof>;
--    
--    /// Verify a proof against the root commitment
--    ///
--    /// # Arguments
--    /// * `commitment` - The commitment to verify against
--    /// * `proof` - The proof to verify
--    /// * `key` - The key the proof is for
--    /// * `value` - The value to verify
--    ///
--    /// # Returns
--    /// * `true` - If the proof is valid
--    /// * `false` - If the proof is invalid or verification isn't supported
--    fn verify_proof(
--        &self,
--        commitment: &Self::Commitment,
--        proof: &Self::Proof,
--        key: &[u8],
--        value: &[u8]
--    ) -> bool;
-+/// `StateManager` is a higher-level abstraction that must also be a `StateTree`.
-+/// It provides all the same core methods as `StateTree` (via inheritance) and
-+/// adds batching capabilities.
-+pub trait StateManager: StateTree {
-+    // REMOVED: All redundant associated types and method signatures from StateTree are gone.
-+    // They are inherited automatically.
-+
-+    /// Set multiple key-value pairs in a single batch operation.
-+    /// This is now a required method for any implementor of StateManager.
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError>;
-+
-+    /// Get multiple values by keys in a single batch operation.
-+    /// This is now a required method.
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError>;
- }```
- 
- ####### File: core/src/state/mod.rs
--####*Size: 4.0K, Lines: 24, Type: ASCII text*
-+####*Size: 4.0K, Lines: 25, Type: ASCII text*
- 
- ```rust
-+// Path: crates/core/src/state/mod.rs
-+
- //! State management interfaces for the DePIN SDK Core.
- 
- mod manager;
-@@ -5336,18 +4402,17 @@ pub use tree::*;
- 
- use crate::commitment::CommitmentScheme;
- 
--/// Type alias for a StateManager compatible with a specific CommitmentScheme
-+/// Type alias for a StateManager trait object compatible with a specific CommitmentScheme.
- pub type StateManagerFor<CS> = dyn StateManager<
-     Commitment = <CS as CommitmentScheme>::Commitment,
-     Proof = <CS as CommitmentScheme>::Proof,
- >;
- 
--/// Type alias for a StateTree compatible with a specific CommitmentScheme
-+/// Type alias for a StateTree trait object compatible with a specific CommitmentScheme.
- pub type StateTreeFor<CS> = dyn StateTree<
-     Commitment = <CS as CommitmentScheme>::Commitment,
-     Proof = <CS as CommitmentScheme>::Proof,
-->;
--```
-+>;```
- 
- ####### File: core/src/state/tree.rs
- ####*Size: 4.0K, Lines: 65, Type: ASCII text*
-@@ -5978,30 +5043,50 @@ mod tests {
- ```
- 
- ####### File: core/src/transaction/mod.rs
--####*Size: 8.0K, Lines: 170, Type: ASCII text*
-+####*Size: 8.0K, Lines: 153, Type: ASCII text*
- 
- ```rust
- // File: crates/core/src/transaction/mod.rs
- 
--use std::any::Any;
-+use crate::commitment::CommitmentScheme;
- use crate::error::TransactionError;
- use crate::state::StateManager;
--use crate::commitment::CommitmentScheme;
-+use std::any::Any;
-+use std::fmt::Debug;
- 
- /// Core transaction model trait that defines the interface for all transaction models.
- ///
- /// This trait is intentionally model-agnostic, allowing for different implementations
- /// (UTXO, account-based, hybrid, etc.) while providing a consistent interface.
- pub trait TransactionModel {
--    /// The transaction type for this model
--    type Transaction;
--    
--    /// The proof type for this model
-+    /// The transaction type for this model.
-+    type Transaction: Debug;
-+
-+    /// The proof type for this model.
-     type Proof;
--    
--    /// The commitment scheme used by this model
-+
-+    /// The commitment scheme used by this model.
-     type CommitmentScheme: CommitmentScheme;
- 
-+    /// Creates a "coinbase" or block reward transaction.
-+    ///
-+    /// This provides a generic way for a block producer (like the OrchestrationContainer)
-+    /// to create the first, special transaction in a block without needing to know the
-+    /// specific details of the transaction model.
-+    ///
-+    /// # Arguments
-+    /// * `block_height` - The height of the block this transaction will be in.
-+    /// * `recipient` - The public key or address of the block producer who should receive the reward.
-+    ///
-+    /// # Returns
-+    /// * `Ok(transaction)` - A valid coinbase transaction.
-+    /// * `Err(TransactionError)` - If the coinbase transaction could not be created.
-+    fn create_coinbase_transaction(
-+        &self,
-+        block_height: u64,
-+        recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError>;
-+
-     /// Validate a transaction against the current state.
-     ///
-     /// # Arguments
-@@ -6015,9 +5100,9 @@ pub trait TransactionModel {
-     fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
- 
-     /// Apply a transaction to the state.
-     ///
-@@ -6031,10 +5116,10 @@ pub trait TransactionModel {
-     fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
--    
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
-+
-     /// Generate a proof for a transaction.
-     ///
-     /// # Arguments
-@@ -6044,13 +5129,17 @@ pub trait TransactionModel {
-     /// # Returns
-     /// * `Ok(proof)` - If the proof was successfully generated.
-     /// * `Err(TransactionError)` - If an error occurred during proof generation.
--    fn generate_proof<S>(&self, tx: &Self::Transaction, state: &S) -> Result<Self::Proof, TransactionError>
-+    fn generate_proof<S>(
-+        &self,
-+        tx: &Self::Transaction,
-+        state: &S,
-+    ) -> Result<Self::Proof, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
--    
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
-+
-     /// Verify a proof for a transaction.
-     ///
-     /// # Arguments
-@@ -6064,47 +5153,23 @@ pub trait TransactionModel {
-     fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
--    
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
-+
-     /// Serialize a transaction to bytes.
--    ///
--    /// # Arguments
--    /// * `tx` - The transaction to serialize.
--    ///
--    /// # Returns
--    /// * `Ok(bytes)` - The serialized transaction.
--    /// * `Err(TransactionError)` - If an error occurred during serialization.
-     fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError>;
--    
-+
-     /// Deserialize bytes to a transaction.
--    ///
--    /// # Arguments
--    /// * `data` - The serialized transaction.
--    ///
--    /// # Returns
--    /// * `Ok(transaction)` - The deserialized transaction.
--    /// * `Err(TransactionError)` - If an error occurred during deserialization.
-     fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError>;
- 
-     /// Optional extension point for model-specific functionality.
--    ///
--    /// This allows models to expose additional functionality beyond the core interface
--    /// without breaking the common abstraction.
--    ///
--    /// # Returns
--    /// * `Some(extensions)` - A reference to model-specific extensions.
--    /// * `None` - If no extensions are available.
-     fn get_model_extensions(&self) -> Option<&dyn Any> {
-         None
-     }
- }
- 
--/// Registry for managing multiple transaction models.
--///
--/// This provides runtime selection capabilities when compile-time selection
--/// through feature flags is not feasible.
-+/// Registry for managing multiple transaction models at runtime.
- #[derive(Default)]
- pub struct TransactionModelRegistry {
-     models: std::collections::HashMap<String, Box<dyn Any>>,
-@@ -6117,37 +5182,20 @@ impl TransactionModelRegistry {
-             models: std::collections::HashMap::new(),
-         }
-     }
--    
-+
-     /// Register a transaction model.
--    ///
--    /// # Arguments
--    /// * `name` - The name to register the model under.
--    /// * `model` - The model to register.
-     pub fn register<T: TransactionModel + 'static>(&mut self, name: &str, model: T) {
-         self.models.insert(name.to_string(), Box::new(model));
-     }
--    
-+
-     /// Get a registered transaction model.
--    ///
--    /// # Arguments
--    /// * `name` - The name of the model to retrieve.
--    ///
--    /// # Returns
--    /// * `Some(model)` - The requested model.
--    /// * `None` - If no model is registered under the given name.
-     pub fn get<T: 'static>(&self, name: &str) -> Option<&T> {
--        self.models.get(name)
-+        self.models
-+            .get(name)
-             .and_then(|model| model.downcast_ref::<T>())
-     }
--    
-+
-     /// Check if a model is registered.
--    ///
--    /// # Arguments
--    /// * `name` - The name to check.
--    ///
--    /// # Returns
--    /// * `true` - If a model is registered under the given name.
--    /// * `false` - Otherwise.
-     pub fn has_model(&self, name: &str) -> bool {
-         self.models.contains_key(name)
-     }
-@@ -6156,36 +5204,40 @@ impl TransactionModelRegistry {
- ###### Directory: core/src/types
- 
- ####### File: core/src/types/mod.rs
--####*Size: 4.0K, Lines: 46, Type: ASCII text*
-+####*Size: 4.0K, Lines: 50, Type: ASCII text*
- 
- ```rust
-+// Path: crates/core/src/types/mod.rs
-+
- //! Type aliases and common types for the DePIN SDK
- 
- use crate::commitment::CommitmentScheme;
- use crate::state::StateManager;
- use crate::transaction::TransactionModel;
- 
--/// Type aliases for commitment schemes
-+/// Type aliases for commitment schemes.
- pub mod commitment {
-     use super::*;
- 
--    /// The commitment type for a given commitment scheme
-+    /// The commitment type for a given commitment scheme.
-     pub type CommitmentOf<CS> = <CS as CommitmentScheme>::Commitment;
- 
--    /// The proof type for a given commitment scheme  
-+    /// The proof type for a given commitment scheme.
-     pub type ProofOf<CS> = <CS as CommitmentScheme>::Proof;
- 
--    /// The value type for a given commitment scheme
-+    /// The value type for a given commitment scheme.
-     pub type ValueOf<CS> = <CS as CommitmentScheme>::Value;
- }
- 
--/// Type aliases for state management
-+/// Type aliases for state management.
- pub mod state {
-     use super::*;
- 
--    /// Type alias for a state manager that uses a specific commitment scheme
--    pub type StateManagerFor<CS> 
--    where 
-+    /// Type alias for a `StateManager` trait object that is compatible with a
-+    /// specific `CommitmentScheme`. This is now unambiguous because `StateManager`
-+    /// inherits its associated types directly from its `StateTree` supertrait.
-+    pub type StateManagerFor<CS>
-+    where
-         CS: CommitmentScheme,
-     = dyn StateManager<
-         Commitment = <CS as CommitmentScheme>::Commitment,
-@@ -6193,22 +5245,54 @@ pub mod state {
-     >;
- }
- 
--/// Type aliases for transaction models
-+/// Type aliases for transaction models.
- pub mod transaction {
-     use super::*;
- 
--    /// Transaction type for a transaction model
-+    /// The transaction type for a given transaction model.
-     pub type TransactionOf<TM> = <TM as TransactionModel>::Transaction;
- 
--    /// Proof type for a transaction model
-+    /// The proof type for a given transaction model.
-     pub type ProofOf<TM> = <TM as TransactionModel>::Proof;
- 
--    /// Commitment scheme type for a transaction model
-+    /// The commitment scheme type for a given transaction model.
-     pub type CommitmentSchemeOf<TM> = <TM as TransactionModel>::CommitmentScheme;
- }```
- 
- ###### Directory: core/src/validator
- 
-+####### Directory: core/src/validator/container
-+
-+######## File: core/src/validator/container/mod.rs
-+#####*Size: 4.0K, Lines: 24, Type: ASCII text*
-+
-+```rust
-+// Path: crates/core/src/validator/container/mod.rs
-+
-+use crate::error::ValidatorError;
-+use async_trait::async_trait;
-+
-+/// A trait for any component that can be started and stopped.
-+#[async_trait]
-+pub trait Container {
-+    /// A unique identifier for the container.
-+    fn id(&self) -> &'static str;
-+    /// Returns true if the container is currently running.
-+    fn is_running(&self) -> bool;
-+    /// Starts the container's logic.
-+    async fn start(&self) -> Result<(), ValidatorError>;
-+    /// Stops the container's logic.
-+    async fn stop(&self) -> Result<(), ValidatorError>;
-+}
-+
-+/// A trait for the Guardian container, responsible for secure boot and attestation.
-+pub trait GuardianContainer: Container {
-+    /// Initiates the secure boot process.
-+    fn start_boot(&self) -> Result<(), ValidatorError>;
-+    /// Verifies the attestation of other containers.
-+    fn verify_attestation(&self) -> Result<bool, ValidatorError>;
-+}```
-+
- ####### Directory: core/src/validator/tests
- 
- ######## File: core/src/validator/tests/mod.rs
-@@ -6458,72 +5542,101 @@ mod tests {
- }
- ```
- 
--####### File: core/src/validator/container.rs
--####*Size: 4.0K, Lines: 25, Type: ASCII text*
-+####### File: core/src/validator/mod.rs
-+####*Size: 4.0K, Lines: 62, Type: ASCII text*
- 
- ```rust
--//! Container interface definitions
-+// Path: crates/core/src/validator/mod.rs
- 
--/// Container interface
--pub trait Container {
--    /// Start the container
--    fn start(&self) -> Result<(), String>;
--    
--    /// Stop the container
--    fn stop(&self) -> Result<(), String>;
--    
--    /// Check if the container is running
--    fn is_running(&self) -> bool;
--    
--    /// Get the container ID
--    fn id(&self) -> &str;
--}
-+use crate::{
-+    config::WorkloadConfig,
-+    error::ValidatorError,
-+    state::{StateManager, StateTree},
-+};
-+use std::fmt::Debug;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
- 
--/// Guardian container interface
--pub trait GuardianContainer: Container {
--    /// Start the boot process
--    fn start_boot(&self) -> Result<(), String>;
--    
--    /// Verify attestation
--    fn verify_attestation(&self) -> Result<bool, String>;
-+// FIX: Declare the container module so it's part of the `validator` module.
-+pub mod container;
-+
-+// FIX: Publicly re-export the traits using a relative path.
-+pub use container::{Container, GuardianContainer};
-+
-+/// A container responsible for executing transactions and managing state.
-+#[derive(Debug)]
-+pub struct WorkloadContainer<ST: StateManager> {
-+    _config: WorkloadConfig,
-+    state_tree: Arc<Mutex<ST>>,
- }
--```
- 
--####### File: core/src/validator/mod.rs
--####*Size: 4.0K, Lines: 10, Type: ASCII text*
-+impl<ST> WorkloadContainer<ST>
-+where
-+    ST: StateManager,
-+{
-+    pub fn new(config: WorkloadConfig, state_tree: ST) -> Self {
-+        Self {
-+            _config: config,
-+            state_tree: Arc::new(Mutex::new(state_tree)),
-+        }
-+    }
- 
--```rust
--//! Validator architecture trait definitions
-+    pub fn state_tree(&self) -> Arc<Mutex<ST>> {
-+        self.state_tree.clone()
-+    }
-+}
-+
-+#[async_trait::async_trait]
-+impl<ST> Container for WorkloadContainer<ST>
-+where
-+    ST: StateManager + StateTree + Send + Sync + 'static,
-+{
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!("WorkloadContainer started.");
-+        Ok(())
-+    }
- 
--mod container;
--mod types;
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("WorkloadContainer stopped.");
-+        Ok(())
-+    }
- 
--#[cfg(test)]
--mod tests;
-+    fn is_running(&self) -> bool {
-+        true
-+    }
- 
--pub use container::*;
--pub use types::*;
--```
-+    fn id(&self) -> &'static str {
-+        "workload_container"
-+    }
-+}```
- 
- ####### File: core/src/validator/types.rs
--####*Size: 4.0K, Lines: 25, Type: ASCII text*
-+####*Size: 4.0K, Lines: 32, Type: ASCII text*
- 
- ```rust
- //! Validator type definitions
-+use crate::error::ValidatorError;
- 
- /// Validator model trait
- pub trait ValidatorModel {
-+    /// An associated type representing the specific WorkloadContainer implementation this validator uses.
-+    /// This allows us to access it generically without knowing the validator's concrete type.
-+    type WorkloadContainerType;
-+
-     /// Start the validator
--    fn start(&self) -> Result<(), String>;
--    
-+    fn start(&self) -> Result<(), ValidatorError>;
-+
-     /// Stop the validator
--    fn stop(&self) -> Result<(), String>;
--    
-+    fn stop(&self) -> Result<(), ValidatorError>;
-+
-     /// Check if the validator is running
-     fn is_running(&self) -> bool;
--    
-+
-     /// Get the validator type
-     fn validator_type(&self) -> ValidatorType;
-+
-+    /// Provides generic access to the validator's workload container.
-+    fn workload_container(&self) -> &Self::WorkloadContainerType;
- }
- 
- /// Validator types
-@@ -6533,36 +5646,41 @@ pub enum ValidatorType {
-     Standard,
-     /// Hybrid validator (5 containers)
-     Hybrid,
--}
--```
-+}```
- 
- ###### File: core/src/lib.rs
--###*Size: 4.0K, Lines: 30, Type: ASCII text*
-+###*Size: 4.0K, Lines: 36, Type: ASCII text*
- 
- ```rust
- //! # DePIN SDK Core
- //!
- //! Core traits and interfaces for the DePIN SDK.
- 
-+pub mod app;
-+pub mod chain;
-+pub mod commitment;
- pub mod component;
-+// NEW: A module for shared configuration structs.
-+pub mod config;
- pub mod crypto;
- pub mod error;
- pub mod homomorphic;
-+pub mod ibc;
- pub mod services;
--pub mod commitment;
- pub mod state;
--pub mod types;
--pub mod ibc;
- pub mod transaction;
-+pub mod types;
- pub mod validator;
- 
--// Only include test utilities when running tests
- #[cfg(test)]
- pub mod test_utils;
- 
- // Re-export key traits and types for convenience
-+pub use app::*;
-+pub use chain::*;
- pub use commitment::*;
- pub use component::*;
-+pub use config::*;
- pub use crypto::*;
- pub use error::*;
- pub use homomorphic::*;
-@@ -6573,27 +5691,32 @@ pub use transaction::*;
- pub use validator::*;```
- 
- ##### File: core/Cargo.toml
--##*Size: 4.0K, Lines: 18, Type: ASCII text*
-+##*Size: 4.0K, Lines: 23, Type: ASCII text*
- 
- ```toml
-+# Path: crates/core/Cargo.toml
-+
- [package]
- name = "depin-sdk-core"
- version = "0.1.0"
- edition = "2021"
--description = "Core traits and interfaces for the DePIN SDK"
-+description = "Core types and traits for the DePIN SDK"
- license = "MIT OR Apache-2.0"
- 
- [dependencies]
-+# FIX: Add async-trait as a dependency, which is now required by the Container trait.
-+async-trait = { workspace = true }
- log = { workspace = true }
--serde = { workspace = true }
-+serde = { workspace = true, features = ["derive"] }
-+serde_json = { workspace = true }
- thiserror = { workspace = true }
- bytes = { workspace = true }
--anyhow = { workspace = true }
-+tokio = { workspace = true, features = ["sync"] }
- 
- [features]
- default = []
--post-quantum = []
- homomorphic = []
-+post-quantum = []
- ```
- 
- #### Directory: crypto
-@@ -10697,15 +9820,15 @@ pub use proof::{HomomorphicProof, ProofGenerator};
- ```
- 
- ###### File: homomorphic/src/proof.rs
--###*Size: 16K, Lines: 357, Type: ASCII text*
-+###*Size: 16K, Lines: 356, Type: ASCII text*
- 
- ```rust
- use crate::error::{HomomorphicError, HomomorphicResult};
- use depin_sdk_core::commitment::HomomorphicCommitmentScheme;
- use depin_sdk_core::commitment::HomomorphicOperation;
--use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-+// FIX: Remove unused imports.
-+use depin_sdk_core::commitment::{ProofContext, Selector};
- use depin_sdk_core::homomorphic::CommitmentOperation;
--use std::collections::HashMap;
- use std::fmt::Debug;
- use std::marker::PhantomData;
- 
-@@ -11056,11 +10179,10 @@ impl<CS: HomomorphicCommitmentScheme> ProofGenerator<CS> {
-             )),
-         }
-     }
--}
--```
-+}```
- 
- ##### File: homomorphic/Cargo.toml
--##*Size: 4.0K, Lines: 19, Type: ASCII text*
-+##*Size: 4.0K, Lines: 16, Type: ASCII text*
- 
- ```toml
- [package]
-@@ -11076,9 +10198,6 @@ depin-sdk-commitment-schemes = { path = "../commitment_schemes" }
- log = { workspace = true }
- serde = { workspace = true }
- thiserror = { workspace = true }
--rand = "0.8"
--sha2 = "0.10"
--curve25519-dalek = "4.0"
- 
- [features]
- default = []
-@@ -12651,139 +11770,141 @@ default = []
- ###### Directory: state_trees/src/file
- 
- ####### File: state_trees/src/file/mod.rs
--####*Size: 8.0K, Lines: 181, Type: C source, ASCII text*
-+####*Size: 8.0K, Lines: 166, Type: ASCII text*
- 
- ```rust
--use depin_sdk_core::commitment::CommitmentScheme;
-+// Path: crates/state_trees/src/file/mod.rs
-+
-+use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
- use depin_sdk_core::error::StateError;
- use depin_sdk_core::state::{StateManager, StateTree};
--use crate::HashMapStateTree;
- use serde::{Deserialize, Serialize};
-+use std::any::Any;
- use std::collections::HashMap;
--use std::fs;
-+use std::fs::{File, OpenOptions};
-+use std::io::{self};
-+use std::marker::PhantomData;
- use std::path::{Path, PathBuf};
--use std::any::Any;
--use std::sync::{Arc, RwLock};
--
--// A serializable representation of the state, using hex strings for keys and values.
--#[derive(Serialize, Deserialize, Default)]
--struct SerializableState(HashMap<String, String>);
- 
--/// A state tree that persists its state to a JSON file.
--/// It wraps an in-memory HashMapStateTree and adds load/save functionality.
--pub struct FileStateTree<CS: CommitmentScheme + Clone>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--{
--    // The inner, in-memory state tree.
--    inner: HashMapStateTree<CS>,
--    // Path to the state file on disk.
-+/// A simple, file-backed state tree implementation for demonstration purposes.
-+/// It uses a HashMap internally and serializes to a JSON file.
-+///
-+/// FIX: The internal HashMap now uses `String` for keys to be compatible with
-+/// the JSON format, which requires string keys for objects. Binary keys are
-+/// hex-encoded before being used with the map.
-+#[derive(Serialize, Deserialize, Debug)]
-+pub struct FileStateTree<C: CommitmentScheme> {
-     path: PathBuf,
--    // We use an Arc<RwLock<()>> as a simple, cheap way to prevent saves
--    // from happening concurrently, which could corrupt the file.
--    save_lock: Arc<RwLock<()>>,
-+    #[serde(skip, default)]
-+    scheme: C,
-+    // FIX: Changed key type from Vec<u8> to String.
-+    data: HashMap<String, Vec<u8>>,
-+    #[serde(skip)]
-+    _phantom: PhantomData<C::Value>,
- }
- 
--impl<CS: CommitmentScheme + Clone> FileStateTree<CS>
-+impl<C> FileStateTree<C>
- where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+    C: CommitmentScheme + Clone + Default,
-+    C::Value: From<Vec<u8>>,
- {
--    /// Creates a new FileStateTree.
--    ///
--    /// It attempts to load the initial state from the file at `path`.
--    /// If the file doesn't exist, it starts with an empty state.
--    pub fn new<P: AsRef<Path>>(path: P, scheme: CS) -> Self {
--        let mut tree = Self {
--            inner: HashMapStateTree::new(scheme),
--            path: path.as_ref().to_path_buf(),
--            save_lock: Arc::new(RwLock::new(())),
--        };
--
--        if let Err(e) = tree.load() {
--            // Log a warning if loading fails, but don't panic.
--            // This allows the node to start fresh if the state file is corrupted or unreadable.
--            eprintln!("[Warning] Failed to load state from {:?}: {}. Starting with a fresh state.", tree.path, e);
--        }
--        tree
-+    pub fn new<P: AsRef<Path>>(path: P, scheme: C) -> Self {
-+        let path_buf = path.as_ref().to_path_buf();
-+        Self::load(&path_buf, scheme.clone()).unwrap_or_else(|_| Self {
-+            path: path_buf,
-+            scheme,
-+            data: HashMap::new(),
-+            _phantom: PhantomData,
-+        })
-     }
- 
--    /// Loads the state from the JSON file.
--    pub fn load(&mut self) -> Result<(), StateError> {
--        if !self.path.exists() {
--            println!("State file not found at {:?}, starting new state.", self.path);
--            return Ok(());
--        }
--
--        let json_data = fs::read_to_string(&self.path)
--            .map_err(|e| StateError::ReadError(e.to_string()))?;
--            
--        let serializable_map: SerializableState = serde_json::from_str(&json_data)
--            .map_err(|e| StateError::ReadError(format!("JSON deserialization error: {}", e)))?;
--
--        self.inner.data.clear();
--        for (k_hex, v_hex) in serializable_map.0 {
--            let k = hex::decode(&k_hex)
--                .map_err(|e| StateError::InvalidKey(format!("Hex decode error: {}", e)))?;
--            let v_bytes = hex::decode(&v_hex)
--                .map_err(|e| StateError::InvalidValue(format!("Hex decode error: {}", e)))?;
--            
--            self.inner.data.insert(k, CS::Value::from(v_bytes));
--        }
--
--        println!("Successfully loaded state with {} entries from {:?}", self.inner.data.len(), self.path);
--        Ok(())
-+    fn load<P: AsRef<Path>>(path: P, scheme: C) -> io::Result<Self> {
-+        let file = File::open(path)?;
-+        let mut loaded: Self = serde_json::from_reader(file)
-+            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
-+        loaded.scheme = scheme;
-+        Ok(loaded)
-     }
- 
--    /// Saves the current state to the JSON file.
--    pub fn save(&self) -> Result<(), StateError> {
--        // Acquire a write lock to ensure only one save operation happens at a time.
--        let _lock = self.save_lock.write().unwrap();
--
--        let mut serializable_map = SerializableState::default();
--        for (k, v) in &self.inner.data {
--            serializable_map.0.insert(hex::encode(k), hex::encode(v.as_ref()));
--        }
--
--        let json_data = serde_json::to_string_pretty(&serializable_map)
--            .map_err(|e| StateError::WriteError(e.to_string()))?;
--        
--        fs::write(&self.path, json_data)
--            .map_err(|e| StateError::WriteError(e.to_string()))?;
--
--        Ok(())
-+    fn save(&self) -> io::Result<()> {
-+        let file = OpenOptions::new()
-+            .write(true)
-+            .create(true)
-+            .truncate(true)
-+            .open(&self.path)?;
-+        serde_json::to_writer_pretty(file, self)
-+            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))
-     }
- }
- 
--// Delegate StateTree and StateManager traits to the inner HashMapStateTree.
--impl<CS: CommitmentScheme + Clone> StateTree for FileStateTree<CS>
-+impl<C> StateTree for FileStateTree<C>
- where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+    C: CommitmentScheme + Clone + Send + Sync + Default,
-+    C::Value: From<Vec<u8>>,
- {
--    type Commitment = CS::Commitment;
--    type Proof = CS::Proof;
-+    type Commitment = C::Commitment;
-+    type Proof = C::Proof;
- 
-     fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        StateTree::get(&self.inner, key)
-+        // FIX: Hex-encode the key for lookup.
-+        let key_hex = hex::encode(key);
-+        Ok(self.data.get(&key_hex).cloned())
-     }
- 
-     fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        StateTree::insert(&mut self.inner, key, value)
-+        // FIX: Hex-encode the key before insertion.
-+        let key_hex = hex::encode(key);
-+        self.data.insert(key_hex, value.to_vec());
-+        self.save()
-+            .map_err(|e| StateError::WriteError(e.to_string()))
-     }
- 
-     fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        StateTree::delete(&mut self.inner, key)
-+        // FIX: Hex-encode the key for removal.
-+        let key_hex = hex::encode(key);
-+        self.data.remove(&key_hex);
-+        self.save()
-+            .map_err(|e| StateError::WriteError(e.to_string()))
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        StateTree::root_commitment(&self.inner)
-+        let mut values_to_sort = self.data.values().cloned().collect::<Vec<_>>();
-+        values_to_sort.sort();
-+
-+        let values_to_commit: Vec<Option<C::Value>> = values_to_sort
-+            .into_iter()
-+            .map(|v| Some(C::Value::from(v)))
-+            .collect();
-+
-+        self.scheme.commit(&values_to_commit)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        StateTree::create_proof(&self.inner, key)
-+        // FIX: Hex-encode the key for lookup.
-+        let key_hex = hex::encode(key);
-+        let value = self.data.get(&key_hex)?;
-+        self.scheme
-+            .create_proof(
-+                &Selector::Key(key.to_vec()),
-+                &C::Value::from(value.clone()),
-+            )
-+            .ok()
-     }
- 
--    fn verify_proof(&self, commitment: &Self::Commitment, proof: &Self::Proof, key: &[u8], value: &[u8]) -> bool {
--        StateTree::verify_proof(&self.inner, commitment, proof, key, value)
-+    fn verify_proof(
-+        &self,
-+        commitment: &Self::Commitment,
-+        proof: &Self::Proof,
-+        key: &[u8],
-+        value: &[u8],
-+    ) -> bool {
-+        self.scheme.verify(
-+            commitment,
-+            proof,
-+            &Selector::Key(key.to_vec()),
-+            &C::Value::from(value.to_vec()),
-+            &ProofContext::default(),
-+        )
-     }
- 
-     fn as_any(&self) -> &dyn Any {
-@@ -12791,56 +11912,39 @@ where
-     }
- }
- 
--impl<CS: CommitmentScheme + Clone> StateManager for FileStateTree<CS>
-+impl<C> StateManager for FileStateTree<C>
- where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+    C: CommitmentScheme + Clone + Send + Sync + Default,
-+    C::Commitment: Send + Sync,
-+    C::Proof: Send + Sync,
-+    C::Value: From<Vec<u8>> + Send + Sync,
- {
--    type Commitment = CS::Commitment;
--    type Proof = CS::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        <Self as StateTree>::get(self, key)
--    }
--
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::insert(self, key, value)
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::delete(self, key)
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        <Self as StateTree>::root_commitment(self)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        <Self as StateTree>::create_proof(self, key)
--    }
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            // FIX: Hex-encode each key before batch insertion.
-+            let key_hex = hex::encode(key);
- 
--    fn verify_proof(&self, commitment: &Self::Commitment, proof: &Self::Proof, key: &[u8], value: &[u8]) -> bool {
--        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
-+            self.data.insert(key_hex, value.to_vec());
-+        }
-+        self.save()
-+            .map_err(|e| StateError::WriteError(e.to_string()))
-     }
--}
- 
--// Automatically save the state when the FileStateTree is dropped.
--// This is a safety net for graceful shutdowns.
--impl<CS: CommitmentScheme + Clone> Drop for FileStateTree<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--{
--    fn drop(&mut self) {
--        println!("Shutting down... saving final state to {:?}", self.path);
--        if let Err(e) = self.save() {
--            eprintln!("[Error] Failed to save state on shutdown: {}", e);
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut values = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            // FIX: Hex-encode each key for batch lookup.
-+            let key_hex = hex::encode(key);
-+            values.push(self.data.get(&key_hex).cloned());
-         }
-+        Ok(values)
-     }
- }```
- 
- ###### Directory: state_trees/src/hashmap
- 
- ####### File: state_trees/src/hashmap/mod.rs
--####*Size: 4.0K, Lines: 131, Type: ASCII text*
-+####*Size: 4.0K, Lines: 110, Type: ASCII text*
- 
- ```rust
- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-@@ -12909,10 +12013,7 @@ where
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        // Fixed ambiguous method call by explicitly specifying which trait's method to use
--        let value = <Self as StateTree>::get(self, key)
--            .ok()?
--            .map(|v| self.to_value(&v))?;
-+        let value = self.get(key).ok()?.map(|v| self.to_value(&v))?;
-         let selector = Selector::Key(key.to_vec());
-         self.scheme.create_proof(&selector, &value).ok()
-     }
-@@ -12941,45 +12042,27 @@ impl<CS: CommitmentScheme> StateManager for HashMapStateTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    type Commitment = CS::Commitment;
--    type Proof = CS::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        <Self as StateTree>::get(self, key)
--    }
--
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::insert(self, key, value)
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::delete(self, key)
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        <Self as StateTree>::root_commitment(self)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        <Self as StateTree>::create_proof(self, key)
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            let value_typed = self.to_value(value);
-+            self.data.insert(key.to_vec(), value_typed);
-+        }
-+        Ok(())
-     }
- 
--    fn verify_proof(
--        &self,
--        commitment: &Self::Commitment,
--        proof: &Self::Proof,
--        key: &[u8],
--        value: &[u8],
--    ) -> bool {
--        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut values = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            values.push(self.data.get(key).map(|v| v.as_ref().to_vec()));
-+        }
-+        Ok(values)
-     }
--}
--```
-+}```
- 
- ###### Directory: state_trees/src/iavl
- 
- ####### File: state_trees/src/iavl/mod.rs
--####*Size: 8.0K, Lines: 150, Type: ASCII text*
-+####*Size: 4.0K, Lines: 110, Type: ASCII text*
- 
- ```rust
- //! IAVL tree implementation
-@@ -13029,7 +12112,6 @@ where
-     type Proof = CS::Proof;
- 
-     fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        // Convert to the appropriate value type for this commitment scheme
-         let scheme_value = self.to_value(value);
-         self.data.insert(key.to_vec(), scheme_value);
-         Ok(())
-@@ -13045,18 +12127,13 @@ where
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        // Convert data to format expected by commitment scheme
-         let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-         self.scheme.commit(&values)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-         let value = self.data.get(key)?;
--
--        // Create a key-based selector for the proof
-         let selector = Selector::Key(key.to_vec());
--
--        // Create the proof using the selector
-         self.scheme.create_proof(&selector, value).ok()
-     }
- 
-@@ -13067,16 +12144,9 @@ where
-         key: &[u8],
-         value: &[u8],
-     ) -> bool {
--        // Create a key-based selector for verification
-         let selector = Selector::Key(key.to_vec());
--
--        // Create an empty context for now
-         let context = ProofContext::default();
--
--        // Convert the raw value to the scheme's value type
-         let scheme_value = self.to_value(value);
--
--        // Verify the proof using the selector and context
-         self.scheme
-             .verify(commitment, proof, &selector, &scheme_value, &context)
-     }
-@@ -13086,58 +12156,31 @@ where
-     }
- }
- 
--// Add support for tree-specific operations for IAVL
--impl<CS: CommitmentScheme> IAVLTree<CS>
-+// FIX: Implement the StateManager trait.
-+impl<CS: CommitmentScheme> StateManager for IAVLTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    /// Get the height of the tree
--    pub fn height(&self) -> usize {
--        // This would be a real implementation in a complete IAVL tree
--        // For now, we just return a placeholder value
--        let size = self.data.len();
--        if size == 0 {
--            0
--        } else {
--            (size as f64).log2().ceil() as usize
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            self.insert(key, value)?;
-         }
-+        Ok(())
-     }
- 
--    /// Get the number of nodes in the tree
--    pub fn size(&self) -> usize {
--        self.data.len()
--    }
--
--    /// Check if the tree is balanced
--    pub fn is_balanced(&self) -> bool {
--        // This would be a real implementation in a complete IAVL tree
--        // For now, we just return true
--        true
--    }
--
--    /// Create a proof with additional path information
--    pub fn create_path_proof(&self, key: &[u8]) -> Option<(CS::Proof, Vec<Vec<u8>>)> {
--        // This would create a proof with the complete path from root to leaf
--        let value = self.data.get(key)?;
--
--        // Create a key-based selector
--        let selector = Selector::Key(key.to_vec());
--
--        // Create the proof
--        let proof = self.scheme.create_proof(&selector, value).ok()?;
--
--        // In a real implementation, we would compute the path
--        // For now, we just return an empty path
--        let path = Vec::new();
--
--        Some((proof, path))
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut results = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            results.push(self.get(key)?);
-+        }
-+        Ok(results)
-     }
- }```
- 
- ###### Directory: state_trees/src/sparse_merkle
- 
- ####### File: state_trees/src/sparse_merkle/mod.rs
--####*Size: 4.0K, Lines: 139, Type: ASCII text*
-+####*Size: 4.0K, Lines: 111, Type: ASCII text*
- 
- ```rust
- //! Sparse Merkle tree implementation
-@@ -13168,7 +12211,6 @@ where
-         }
-     }
- 
--    /// Helper to convert raw bytes to the commitment scheme's Value type
-     fn to_value(&self, bytes: &[u8]) -> CS::Value {
-         CS::Value::from(bytes.to_vec())
-     }
-@@ -13197,20 +12239,14 @@ where
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        // Convert data to format expected by commitment scheme
-         let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-         self.scheme.commit(&values)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        // Get the value as an Option<Vec<u8>>
-         let value_result = self.get(key).ok()?;
-         let value = value_result?;
--        
--        // Now convert value to the typed value and create the proof
-         let value_typed = self.to_value(&value);
--
--        // Use key-based selector for sparse Merkle trees
-         self.scheme
-             .create_proof(&Selector::Key(key.to_vec()), &value_typed)
-             .ok()
-@@ -13224,11 +12260,7 @@ where
-         value: &[u8],
-     ) -> bool {
-         let value_typed = self.to_value(value);
--
--        // Create context (empty for now, could be extended with tree-specific data)
-         let context = ProofContext::default();
--
--        // Use key-based selector for verification
-         self.scheme.verify(
-             commitment,
-             proof,
-@@ -13239,52 +12271,35 @@ where
-     }
- 
-     fn as_any(&self) -> &dyn Any {
--        self        
-+        self
-     }
- }
- 
--// Add some utility methods for sparse Merkle trees
--impl<CS: CommitmentScheme> SparseMerkleTree<CS>
-+// FIX: Implement the StateManager trait.
-+impl<CS: CommitmentScheme> StateManager for SparseMerkleTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    /// Get the number of key-value pairs in the tree
--    pub fn len(&self) -> usize {
--        self.data.len()
--    }
--
--    /// Check if the tree is empty
--    pub fn is_empty(&self) -> bool {
--        self.data.is_empty()
--    }
--
--    /// Get all keys in the tree
--    pub fn keys(&self) -> Vec<Vec<u8>> {
--        self.data.keys().cloned().collect()
--    }
--
--    /// Clear all data in the tree
--    pub fn clear(&mut self) {
--        self.data.clear()
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            self.insert(key, value)?;
-+        }
-+        Ok(())
-     }
- 
--    /// Create a proof for multiple keys at once
--    pub fn create_multi_proof(&self, keys: &[&[u8]]) -> HashMap<Vec<u8>, Option<CS::Proof>> {
--        let mut proofs = HashMap::new();
--
--        for &key in keys {
--            let proof = self.create_proof(key);
--            proofs.insert(key.to_vec(), proof);
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut results = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            results.push(self.get(key)?);
-         }
--
--        proofs
-+        Ok(results)
-     }
- }```
- 
- ###### Directory: state_trees/src/verkle
- 
- ####### File: state_trees/src/verkle/mod.rs
--####*Size: 8.0K, Lines: 148, Type: ASCII text*
-+####*Size: 4.0K, Lines: 150, Type: ASCII text*
- 
- ```rust
- //! Verkle tree implementation
-@@ -13347,7 +12362,6 @@ where
-     type Proof = CS::Proof;
- 
-     fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        // Convert value to the appropriate type for the commitment scheme
-         let cs_value = self
-             .convert_value(value)
-             .map_err(|e| StateError::InvalidValue(e))?;
-@@ -13356,7 +12370,6 @@ where
-     }
- 
-     fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        // Convert back from CS::Value to Vec<u8>
-         Ok(self.data.get(key).map(|v| self.extract_value(v)))
-     }
- 
-@@ -13366,15 +12379,12 @@ where
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        // Convert data to format expected by commitment scheme
-         let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-         self.scheme.commit(&values)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-         let value = self.data.get(key)?;
--
--        // Create a key-based proof using the new selector API
-         self.scheme
-             .create_proof(&Selector::Key(key.to_vec()), value)
-             .ok()
-@@ -13387,18 +12397,12 @@ where
-         key: &[u8],
-         value: &[u8],
-     ) -> bool {
--        // Convert value to the appropriate type
-         if let Ok(cs_value) = self.convert_value(value) {
--            // Create verification context with additional data if needed
-             let mut context = ProofContext::new();
--
--            // For Verkle trees, we might need the branching factor in the context
-             context.add_data(
-                 "branching_factor",
-                 self.branching_factor.to_le_bytes().to_vec(),
-             );
--
--            // Use Key selector for verification
-             self.scheme.verify(
-                 commitment,
-                 proof,
-@@ -13412,56 +12416,64 @@ where
-     }
- 
-     fn as_any(&self) -> &dyn Any {
--        self        
-+        self
-+    }
-+}
-+
-+// FIX: Implement the StateManager trait.
-+impl<CS: CommitmentScheme> StateManager for VerkleTree<CS>
-+where
-+    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-+{
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            self.insert(key, value)?;
-+        }
-+        Ok(())
-+    }
-+
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut results = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            results.push(self.get(key)?);
-+        }
-+        Ok(results)
-     }
- }
- 
--// Helper methods to convert between Vec<u8> and CS::Value
- impl<CS: CommitmentScheme> VerkleTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    /// Convert a Vec<u8> to CS::Value
-     fn convert_value(&self, value: &[u8]) -> Result<CS::Value, String> {
-         Ok(CS::Value::from(value.to_vec()))
-     }
- 
--    /// Extract a Vec<u8> from CS::Value
-     fn extract_value(&self, value: &CS::Value) -> Vec<u8> {
-         value.as_ref().to_vec()
-     }
--
--    /// Create a CS::Value from bytes - implement appropriate conversion logic
--    fn create_cs_value(&self, bytes: &[u8]) -> Result<CS::Value, String> {
--        Ok(CS::Value::from(bytes.to_vec()))
--    }
- }```
- 
- ###### File: state_trees/src/lib.rs
--###*Size: 4.0K, Lines: 20, Type: ASCII text*
-+###*Size: 4.0K, Lines: 15, Type: ASCII text*
- 
- ```rust
- //! # DePIN SDK State Trees
- //!
- //! Implementations of various state tree structures for the DePIN SDK.
- 
-+pub mod file;
- pub mod hashmap;
- pub mod iavl;
- pub mod sparse_merkle;
- pub mod verkle;
--pub mod file;
- 
- // Re-export concrete implementations for convenience
- pub use file::FileStateTree;
- pub use hashmap::HashMapStateTree;
- pub use iavl::IAVLTree;
- pub use sparse_merkle::SparseMerkleTree;
--pub use verkle::VerkleTree;
--
--// Import core traits for use in the implementations
--use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::state::StateTree;
--use std::any::Any;```
-+pub use verkle::VerkleTree;```
- 
- ##### File: state_trees/Cargo.toml
- ##*Size: 4.0K, Lines: 22, Type: ASCII text*
-@@ -13788,662 +12800,262 @@ rand = { workspace = true }
- ###### Directory: transaction_models/src/account
- 
- ####### File: transaction_models/src/account/mod.rs
--####*Size: 16K, Lines: 503, Type: ASCII text*
-+####*Size: 8.0K, Lines: 178, Type: ASCII text*
- 
- ```rust
--//! Account-based transaction model implementation.
--
-+// Path: crates/transaction_models/src/account/mod.rs
- 
- use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::TransactionError;
-+use depin_sdk_core::error::{StateError, TransactionError};
- use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use std::any::Any;
--use std::collections::HashMap;
-+use serde::{Deserialize, Serialize};
- 
--/// Account transaction
--#[derive(Debug, Clone)]
-+// FIX: Add derive macros for PartialEq and Eq, required by HybridTransaction.
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
- pub struct AccountTransaction {
--    /// Transaction ID
--    pub txid: Vec<u8>,
--    /// Sender account
-     pub from: Vec<u8>,
--    /// Receiver account
-     pub to: Vec<u8>,
--    /// Value to transfer
--    pub value: u64,
--    /// Nonce to prevent replay
-+    pub amount: u64,
-     pub nonce: u64,
--    /// Signature from sender
--    pub signature: Vec<u8>,
--}
--
--/// Account proof for transaction verification
--#[derive(Debug, Clone)]
--pub struct AccountProof {
--    /// Proof for sender's account
--    pub sender_proof: Vec<u8>,
--    /// Proof for sender's nonce
--    pub nonce_proof: Vec<u8>,
--    /// Additional data for verification
--    pub metadata: HashMap<String, Vec<u8>>,
- }
- 
--/// Account state stored in the state manager
--#[derive(Debug, Clone)]
--pub struct AccountState {
--    /// Account balance
-+#[derive(Serialize, Deserialize, Debug, Clone)]
-+pub struct Account {
-     pub balance: u64,
--    /// Account nonce (for replay protection)
-     pub nonce: u64,
- }
- 
--/// Account-specific operations
--pub trait AccountOperations {
--    /// Create a key for an account in the state store.
--    ///
--    /// # Arguments
--    /// * `account` - Account identifier.
--    ///
--    /// # Returns
--    /// * `Ok(key)` - The generated key.
--    /// * `Err(TransactionError)` - If key creation failed.
--    fn create_account_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError>;
--
--    /// Create a key for an account nonce in the state store.
--    ///
--    /// # Arguments
--    /// * `account` - Account identifier.
--    ///
--    /// # Returns
--    /// * `Ok(key)` - The generated key.
--    /// * `Err(TransactionError)` - If key creation failed.
--    fn create_nonce_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError>;
--}
--
--/// Account model configuration
--#[derive(Clone)]
-+// FIX: Add derive(Debug) as required by HybridConfig.
-+#[derive(Debug, Clone, Default)]
- pub struct AccountConfig {
--    /// Maximum transaction value
--    pub max_value: u64,
--    /// Initial balance for new accounts (if auto-create is enabled)
-     pub initial_balance: u64,
--    /// Whether to automatically create accounts on first receive
--    pub auto_create_accounts: bool,
- }
- 
--impl Default for AccountConfig {
--    fn default() -> Self {
--        Self {
--            max_value: u64::MAX,
--            initial_balance: 0,
--            auto_create_accounts: true,
--        }
--    }
--}
--
--/// Account transaction model implementation
-+// FIX: Add derive(Debug, Clone) as required by HybridModel.
-+#[derive(Debug, Clone)]
- pub struct AccountModel<CS: CommitmentScheme> {
--    /// Model configuration
--    config: AccountConfig,
--    /// Commitment scheme
--    scheme: CS,
--}
--
--impl<CS: CommitmentScheme> AccountModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    /// Create a new account model with default configuration.
--    pub fn new(scheme: CS) -> Self {
-+    config: AccountConfig,
-+    _commitment_scheme: CS,
-+}
-+
-+impl<CS: CommitmentScheme> AccountModel<CS> {
-+    pub fn new(commitment_scheme: CS) -> Self {
-         Self {
-             config: AccountConfig::default(),
--            scheme,
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
- 
--    /// Create a new account model with custom configuration.
--    pub fn with_config(scheme: CS, config: AccountConfig) -> Self {
-+    pub fn with_config(commitment_scheme: CS, config: AccountConfig) -> Self {
-         Self {
-             config,
--            scheme,
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
- 
--    /// Get model configuration.
--    pub fn config(&self) -> &AccountConfig {
--        &self.config
--    }
--
--    /// Get the commitment scheme
--    pub fn scheme(&self) -> &CS {
--        &self.scheme
--    }
--
--    /// Convert a value to the commitment scheme's value type
--    fn to_value(&self, bytes: &[u8]) -> CS::Value {
--        CS::Value::from(bytes.to_vec())
--    }
--
--    /// Helper method to get an account from the state.
--    fn get_account<S>(
--        &self,
--        state: &S,
--        account: &[u8],
--    ) -> Result<Option<AccountState>, TransactionError>
--    where
--        S: StateManager<
--            Commitment = CS::Commitment,
--            Proof = CS::Proof,
--        > + ?Sized,
--    {
--        let key = self.create_account_key(account)?;
--        let value = state
--            .get(&key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--
-+    fn get_account<S: StateManager + ?Sized>(&self, state: &S, key: &[u8]) -> Result<Account, TransactionError> {
-+        let value = state.get(key)?;
-         match value {
-             Some(data) => self.decode_account(&data),
--            None => Ok(None),
-+            None => Ok(Account {
-+                balance: self.config.initial_balance,
-+                nonce: 0,
-+            }),
-         }
-     }
- 
--    /// Helper method to decode an account from bytes.
--    fn decode_account(&self, data: &[u8]) -> Result<Option<AccountState>, TransactionError> {
--        if data.len() < 16 {
--            return Err(TransactionError::SerializationError(
--                "Account data too short".to_string(),
--            ));
--        }
--
--        let mut balance_bytes = [0u8; 8];
--        balance_bytes.copy_from_slice(&data[0..8]);
--        let balance = u64::from_le_bytes(balance_bytes);
--
--        let mut nonce_bytes = [0u8; 8];
--        nonce_bytes.copy_from_slice(&data[8..16]);
--        let nonce = u64::from_le_bytes(nonce_bytes);
--
--        Ok(Some(AccountState { balance, nonce }))
-+    fn decode_account(&self, data: &[u8]) -> Result<Account, TransactionError> {
-+        // FIX: Use the correct `Serialization` variant.
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
--    /// Helper method to encode an account to bytes.
--    fn encode_account(&self, account: &AccountState) -> Vec<u8> {
--        let mut data = Vec::with_capacity(16);
--        data.extend_from_slice(&account.balance.to_le_bytes());
--        data.extend_from_slice(&account.nonce.to_le_bytes());
--        data
-+    fn encode_account(&self, account: &Account) -> Vec<u8> {
-+        serde_json::to_vec(account).unwrap()
-     }
- }
- 
--impl<CS: CommitmentScheme> TransactionModel for AccountModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
-+impl<CS: CommitmentScheme + Send + Sync> TransactionModel for AccountModel<CS> {
-     type Transaction = AccountTransaction;
--    type Proof = AccountProof;
-     type CommitmentScheme = CS;
-+    type Proof = ();
- 
-+    // FIX: Add the required `where` clause to the method signature.
-     fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Check transaction structure
--        if tx.value == 0 {
--            return Ok(false);
--        }
--
--        if tx.value > self.config.max_value {
--            return Ok(false);
-+        let sender_account = self.get_account(state, &tx.from)?;
-+        if sender_account.balance < tx.amount {
-+            // FIX: Use the correct `Invalid` variant.
-+            return Err(TransactionError::Invalid("Insufficient balance".to_string()));
-         }
--
--        // Get sender account
--        let sender = self.get_account(state, &tx.from)?;
--
--        match sender {
--            Some(account) => {
--                // Check balance
--                if account.balance < tx.value {
--                    return Ok(false);
--                }
--
--                // Check nonce
--                if account.nonce != tx.nonce {
--                    return Ok(false);
--                }
--
--                // TODO: Validate signature
--
--                Ok(true)
--            }
--            None => Ok(false), // Sender doesn't exist
-+        if sender_account.nonce != tx.nonce {
-+            return Err(TransactionError::Invalid("Invalid nonce".to_string()));
-         }
-+        Ok(true)
-     }
- 
-+    // FIX: Add the required `where` clause.
-     fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Validate transaction first
-+        // Since we now have `From<StateError>` for `TransactionError`, `?` works.
-         if !self.validate(tx, state)? {
--            return Err(TransactionError::InvalidTransaction(
--                "Transaction validation failed".to_string(),
--            ));
-+            // FIX: Use the correct `Invalid` variant.
-+            return Err(TransactionError::Invalid("Validation failed".to_string()));
-         }
- 
--        // Get sender account
--        let sender_key = self.create_account_key(&tx.from)?;
--        let sender = self.get_account(state, &tx.from)?.ok_or_else(|| {
--            TransactionError::InvalidTransaction("Sender account not found".to_string())
--        })?;
--
--        // Update sender account
--        let new_sender = AccountState {
--            balance: sender.balance - tx.value,
--            nonce: sender.nonce + 1,
--        };
--
--        state
--            .set(&sender_key, &self.encode_account(&new_sender))
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--
--        // Get or create receiver account
--        let receiver_key = self.create_account_key(&tx.to)?;
--        let receiver = match self.get_account(state, &tx.to)? {
--            Some(account) => account,
--            None => {
--                if !self.config.auto_create_accounts {
--                    return Err(TransactionError::InvalidTransaction(
--                        "Receiver account not found".to_string(),
--                    ));
--                }
--
--                AccountState {
--                    balance: self.config.initial_balance,
--                    nonce: 0,
--                }
--            }
--        };
--
--        // Update receiver account
--        let new_receiver = AccountState {
--            balance: receiver.balance.checked_add(tx.value).ok_or_else(|| {
--                TransactionError::InvalidTransaction("Balance overflow".to_string())
--            })?,
--            nonce: receiver.nonce,
--        };
-+        let sender_key = tx.from.clone();
-+        let mut sender_account = self.get_account(state, &sender_key)?;
-+        sender_account.balance -= tx.amount;
-+        sender_account.nonce += 1;
-+        state.insert(&sender_key, &self.encode_account(&sender_account))?;
- 
--        state
--            .set(&receiver_key, &self.encode_account(&new_receiver))
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
-+        let receiver_key = tx.to.clone();
-+        let mut receiver_account = self.get_account(state, &receiver_key)?;
-+        receiver_account.balance = receiver_account
-+            .balance
-+            .checked_add(tx.amount)
-+            // FIX: Use the correct `Invalid` variant.
-+            .ok_or(TransactionError::Invalid("Balance overflow".to_string()))?;
-+        state.insert(&receiver_key, &self.encode_account(&receiver_account))?;
- 
-         Ok(())
-     }
- 
-+    fn create_coinbase_transaction(
-+        &self,
-+        _block_height: u64,
-+        _recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError> {
-+        // Account models don't typically have coinbase transactions.
-+        Err(TransactionError::Invalid(
-+            "Coinbase not supported for account model".to_string(),
-+        ))
-+    }
-+
-+    // FIX: Add the required `where` clause.
-     fn generate_proof<S>(
-         &self,
--        tx: &Self::Transaction,
--        state: &S,
-+        _tx: &Self::Transaction,
-+        _state: &S,
-     ) -> Result<Self::Proof, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        let sender_key = self.create_account_key(&tx.from)?;
--        let nonce_key = self.create_nonce_key(&tx.from)?;
--
--        // In a real implementation, we would create cryptographic proofs
--        // For this example, we'll just get the raw account data
--        let sender_data = state
--            .get(&sender_key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?
--            .ok_or_else(|| {
--                TransactionError::InvalidInput("Sender account not found".to_string())
--            })?;
--
--        let nonce_data = state
--            .get(&nonce_key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?
--            .unwrap_or_else(|| vec![0; 8]); // Default nonce is 0
--
--        Ok(AccountProof {
--            sender_proof: sender_data,
--            nonce_proof: nonce_data,
--            metadata: HashMap::new(),
--        })
-+        Ok(())
-     }
- 
--    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-+    // FIX: Add the required `where` clause.
-+    fn verify_proof<S>(
-+        &self,
-+        _proof: &Self::Proof,
-+        _state: &S,
-+    ) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // In a real implementation, this would verify cryptographic proofs
--        // For this example, we'll just return true
-         Ok(true)
-     }
- 
-     fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        // Simple manual serialization for demonstration
--        let mut data = Vec::new();
--
--        // Serialize txid
--        data.extend_from_slice(&(tx.txid.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.txid);
--
--        // Serialize from
--        data.extend_from_slice(&(tx.from.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.from);
--
--        // Serialize to
--        data.extend_from_slice(&(tx.to.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.to);
--
--        // Serialize value and nonce
--        data.extend_from_slice(&tx.value.to_le_bytes());
--        data.extend_from_slice(&tx.nonce.to_le_bytes());
--
--        // Serialize signature
--        data.extend_from_slice(&(tx.signature.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.signature);
--
--        Ok(data)
-+        // FIX: Use the correct `Serialization` variant.
-+        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
-     fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        if data.len() < 4 {
--            return Err(TransactionError::SerializationError(
--                "Data too short".to_string(),
--            ));
--        }
--
--        let mut pos = 0;
--
--        // Deserialize txid
--        let txid_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + txid_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid txid length".to_string(),
--            ));
--        }
--
--        let txid = data[pos..pos + txid_len].to_vec();
--        pos += txid_len;
--
--        // Deserialize from
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let from_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + from_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid from length".to_string(),
--            ));
--        }
--
--        let from = data[pos..pos + from_len].to_vec();
--        pos += from_len;
--
--        // Deserialize to
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let to_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + to_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid to length".to_string(),
--            ));
--        }
--
--        let to = data[pos..pos + to_len].to_vec();
--        pos += to_len;
--
--        // Deserialize value and nonce
--        if pos + 16 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let mut value_bytes = [0u8; 8];
--        value_bytes.copy_from_slice(&data[pos..pos + 8]);
--        let value = u64::from_le_bytes(value_bytes);
--        pos += 8;
--
--        let mut nonce_bytes = [0u8; 8];
--        nonce_bytes.copy_from_slice(&data[pos..pos + 8]);
--        let nonce = u64::from_le_bytes(nonce_bytes);
--        pos += 8;
--
--        // Deserialize signature
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let signature_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + signature_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid signature length".to_string(),
--            ));
--        }
--
--        let signature = data[pos..pos + signature_len].to_vec();
--
--        Ok(AccountTransaction {
--            txid,
--            from,
--            to,
--            value,
--            nonce,
--            signature,
--        })
--    }
--
--    fn get_model_extensions(&self) -> Option<&dyn Any> {
--        Some(self as &dyn Any)
--    }
--}
--
--impl<CS: CommitmentScheme> AccountOperations for AccountModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    fn create_account_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError> {
--        let mut key = Vec::with_capacity(account.len() + 1);
--        key.push(b'a'); // Prefix 'a' for account
--        key.extend_from_slice(account);
--        Ok(key)
--    }
--
--    fn create_nonce_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError> {
--        let mut key = Vec::with_capacity(account.len() + 1);
--        key.push(b'n'); // Prefix 'n' for nonce
--        key.extend_from_slice(account);
--        Ok(key)
-+        // FIX: Use the correct `Deserialization` variant.
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-     }
--}
--
--/// Helper function to read a u32 from a byte slice
--fn read_u32(data: &[u8]) -> u32 {
--    let mut bytes = [0u8; 4];
--    bytes.copy_from_slice(data);
--    u32::from_le_bytes(bytes)
- }```
- 
--####### File: transaction_models/src/account/mod.rs:131:8
--####*Size: 0, Lines: 0, Type: empty*
--
--####*File content not included (exceeds threshold or non-text file)*
--
--####### File: transaction_models/src/account/mod.rs:331:31
--####*Size: 0, Lines: 0, Type: empty*
--
--####*File content not included (exceeds threshold or non-text file)*
--
--####### File: transaction_models/src/account/mod.rs:331:52
--####*Size: 0, Lines: 0, Type: empty*
--
--####*File content not included (exceeds threshold or non-text file)*
--
- ###### Directory: transaction_models/src/hybrid
- 
- ####### File: transaction_models/src/hybrid/mod.rs
--####*Size: 12K, Lines: 283, Type: ASCII text*
-+####*Size: 8.0K, Lines: 145, Type: ASCII text*
- 
- ```rust
--// Fixed implementation for hybrid transaction model
-+// Path: crates/transaction_models/src/hybrid/mod.rs
- 
--use crate::account::{AccountModel, AccountProof, AccountTransaction};
--use crate::utxo::{UTXOModel, UTXOProof, UTXOTransaction};
-+use crate::account::{AccountConfig, AccountModel, AccountTransaction};
-+use crate::utxo::{UTXOConfig, UTXOModel, UTXOTransaction};
- use depin_sdk_core::commitment::CommitmentScheme;
- use depin_sdk_core::error::TransactionError;
- use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use std::any::Any;
-+use serde::{Deserialize, Serialize};
- 
--/// Hybrid transaction that can be either UTXO or account-based
--#[derive(Debug, Clone)]
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
- pub enum HybridTransaction {
--    /// UTXO-based transaction
--    UTXO(UTXOTransaction),
--    /// Account-based transaction
-     Account(AccountTransaction),
-+    UTXO(UTXOTransaction),
- }
- 
--/// Hybrid proof that can be either UTXO or account-based
- #[derive(Debug, Clone)]
- pub enum HybridProof {
--    /// UTXO-based proof
--    UTXO(UTXOProof),
--    /// Account-based proof
--    Account(AccountProof),
-+    // FIX: Match the inner models' proof types, which are now `()`.
-+    Account(()),
-+    UTXO(()),
- }
- 
--/// Hybrid transaction model configuration
--#[derive(Clone)]
-+#[derive(Debug, Clone, Default)]
- pub struct HybridConfig {
--    /// UTXO model configuration
--    pub utxo_config: crate::utxo::UTXOConfig,
--    /// Account model configuration
--    pub account_config: crate::account::AccountConfig,
--    /// Whether to enforce fee payment in UTXO mode
--    pub require_fee: bool,
--    /// Minimum fee amount (if required)
--    pub min_fee: u64,
--}
--
--impl Default for HybridConfig {
--    fn default() -> Self {
--        Self {
--            utxo_config: crate::utxo::UTXOConfig::default(),
--            account_config: crate::account::AccountConfig::default(),
--            require_fee: false,
--            min_fee: 0,
--        }
--    }
--}
--
--/// Hybrid-specific operations
--pub trait HybridOperations {
--    /// Get access to the underlying UTXO model.
--    fn utxo_model(&self) -> &UTXOModel<Self::CommitmentScheme>;
--
--    /// Get access to the underlying account model.
--    fn account_model(&self) -> &AccountModel<Self::CommitmentScheme>;
--
--    /// Associated type for the commitment scheme
--    type CommitmentScheme: CommitmentScheme;
--
--    /// Create a cross-model transaction (e.g., UTXO input with account output).
--    ///
--    /// This is a placeholder for more complex hybrid operations that might be
--    /// supported in a real implementation.
--    fn create_cross_model_transaction(&self) -> Result<HybridTransaction, TransactionError> {
--        Err(TransactionError::Other("Not implemented".to_string()))
--    }
-+    pub account_config: AccountConfig,
-+    pub utxo_config: UTXOConfig,
- }
- 
--/// Hybrid transaction model implementation
--pub struct HybridModel<CS: CommitmentScheme + Clone> {
--    /// UTXO model
--    utxo_model: UTXOModel<CS>,
--    /// Account model
-+#[derive(Debug, Clone)]
-+pub struct HybridModel<CS: CommitmentScheme> {
-     account_model: AccountModel<CS>,
--    /// Model configuration
--    config: HybridConfig,
--    /// Commitment scheme
--    scheme: CS,
-+    utxo_model: UTXOModel<CS>,
- }
- 
--impl<CS: CommitmentScheme + Clone> HybridModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    /// Create a new hybrid model with default configuration.
-+impl<CS: CommitmentScheme + Clone> HybridModel<CS> {
-     pub fn new(scheme: CS) -> Self {
-         Self {
--            utxo_model: UTXOModel::new(scheme.clone()),
-             account_model: AccountModel::new(scheme.clone()),
--            config: HybridConfig::default(),
--            scheme,
-+            utxo_model: UTXOModel::new(scheme),
-         }
-     }
--
--    /// Create a new hybrid model with custom configuration.
-     pub fn with_config(scheme: CS, config: HybridConfig) -> Self {
-         Self {
--            utxo_model: UTXOModel::with_config(scheme.clone(), config.utxo_config.clone()),
--            account_model: AccountModel::with_config(scheme.clone(), config.account_config.clone()),
--            config,
--            scheme,
-+            account_model: AccountModel::with_config(scheme.clone(), config.account_config),
-+            utxo_model: UTXOModel::with_config(scheme, config.utxo_config),
-         }
-     }
--
--    /// Get model configuration.
--    pub fn config(&self) -> &HybridConfig {
--        &self.config
--    }
--
--    /// Get the commitment scheme
--    pub fn scheme(&self) -> &CS {
--        &self.scheme
--    }
- }
- 
--impl<CS: CommitmentScheme + Clone> TransactionModel for HybridModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
-+impl<CS: CommitmentScheme + Clone + Send + Sync> TransactionModel for HybridModel<CS> {
-     type Transaction = HybridTransaction;
--    type Proof = HybridProof;
-     type CommitmentScheme = CS;
-+    type Proof = HybridProof;
-+
-+    fn create_coinbase_transaction(
-+        &self,
-+        block_height: u64,
-+        recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError> {
-+        let utxo_coinbase = self
-+            .utxo_model
-+            .create_coinbase_transaction(block_height, recipient)?;
-+        Ok(HybridTransaction::UTXO(utxo_coinbase))
-+    }
- 
-+    // FIX: Add the required `where` clause to the method signature.
-     fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
-@@ -14452,13 +13064,12 @@ where
-             > + ?Sized,
-     {
-         match tx {
-+            HybridTransaction::Account(account_tx) => self.account_model.validate(account_tx, state),
-             HybridTransaction::UTXO(utxo_tx) => self.utxo_model.validate(utxo_tx, state),
--            HybridTransaction::Account(account_tx) => {
--                self.account_model.validate(account_tx, state)
--            }
-         }
-     }
- 
-+    // FIX: Add the required `where` clause.
-     fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-     where
-         S: StateManager<
-@@ -14466,30 +13077,13 @@ where
-                 Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-             > + ?Sized,
-     {
--        // Additional hybrid-specific validation
--        if self.config.require_fee {
--            // Check if fee is paid (implementation depends on fee model)
--            // This is a placeholder for a real fee verification
--            let _fee_paid = match tx {
--                HybridTransaction::UTXO(_utxo_tx) => {
--                    // For UTXO, fee is implicit (input value - output value)
--                    true
--                }
--                HybridTransaction::Account(_account_tx) => {
--                    // For account, fee might be explicit or implicit
--                    // This is a simplified check
--                    true
--                }
--            };
--        }
--
--        // Delegate to appropriate model
-         match tx {
--            HybridTransaction::UTXO(utxo_tx) => self.utxo_model.apply(utxo_tx, state),
-             HybridTransaction::Account(account_tx) => self.account_model.apply(account_tx, state),
-+            HybridTransaction::UTXO(utxo_tx) => self.utxo_model.apply(utxo_tx, state),
-         }
-     }
- 
-+    // FIX: Add the required `where` clause.
-     fn generate_proof<S>(
-         &self,
-         tx: &Self::Transaction,
-@@ -14502,403 +13096,165 @@ where
-             > + ?Sized,
-     {
-         match tx {
--            HybridTransaction::UTXO(utxo_tx) => self
--                .utxo_model
--                .generate_proof(utxo_tx, state)
--                .map(HybridProof::UTXO),
--            HybridTransaction::Account(account_tx) => self
--                .account_model
--                .generate_proof(account_tx, state)
--                .map(HybridProof::Account),
--        }
--    }
--
--    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
--    where
--        S: StateManager<
--                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--            > + ?Sized,
--    {
--        match proof {
--            HybridProof::UTXO(utxo_proof) => self.utxo_model.verify_proof(utxo_proof, state),
--            HybridProof::Account(account_proof) => {
--                self.account_model.verify_proof(account_proof, state)
-+            HybridTransaction::Account(account_tx) => {
-+                let proof = self.account_model.generate_proof(account_tx, state)?;
-+                Ok(HybridProof::Account(proof))
-             }
--        }
--    }
--
--    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        let mut data = Vec::new();
--
--        match tx {
-             HybridTransaction::UTXO(utxo_tx) => {
--                // Add type byte (0 for UTXO)
--                data.push(0);
--
--                // Serialize UTXO transaction
--                let utxo_data = self.utxo_model.serialize_transaction(utxo_tx)?;
--                data.extend_from_slice(&utxo_data);
--            }
--            HybridTransaction::Account(account_tx) => {
--                // Add type byte (1 for Account)
--                data.push(1);
--
--                // Serialize account transaction
--                let account_data = self.account_model.serialize_transaction(account_tx)?;
--                data.extend_from_slice(&account_data);
-+                let proof = self.utxo_model.generate_proof(utxo_tx, state)?;
-+                Ok(HybridProof::UTXO(proof))
-             }
-         }
--
--        Ok(data)
-     }
- 
--    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        if data.is_empty() {
--            return Err(TransactionError::SerializationError(
--                "Empty data".to_string(),
--            ));
--        }
--
--        let tx_type = data[0];
--        let tx_data = &data[1..];
--
--        match tx_type {
--            0 => {
--                // UTXO transaction
--                let utxo_tx = self.utxo_model.deserialize_transaction(tx_data)?;
--                Ok(HybridTransaction::UTXO(utxo_tx))
--            }
--            1 => {
--                // Account transaction
--                let account_tx = self.account_model.deserialize_transaction(tx_data)?;
--                Ok(HybridTransaction::Account(account_tx))
-+    // FIX: Add the required `where` clause.
-+    fn verify_proof<S>(
-+        &self,
-+        proof: &Self::Proof,
-+        state: &S,
-+    ) -> Result<bool, TransactionError>
-+    where
-+        S: StateManager<
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-+    {
-+        match proof {
-+            HybridProof::Account(account_proof) => {
-+                self.account_model.verify_proof(account_proof, state)
-             }
--            _ => Err(TransactionError::SerializationError(format!(
--                "Unknown transaction type: {}",
--                tx_type
--            ))),
-+            HybridProof::UTXO(utxo_proof) => self.utxo_model.verify_proof(utxo_proof, state),
-         }
-     }
- 
--    fn get_model_extensions(&self) -> Option<&dyn Any> {
--        Some(self as &dyn Any)
--    }
--}
--
--impl<CS: CommitmentScheme + Clone> HybridOperations for HybridModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    type CommitmentScheme = CS;
--
--    fn utxo_model(&self) -> &UTXOModel<Self::CommitmentScheme> {
--        &self.utxo_model
-+    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
-+        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
--    fn account_model(&self) -> &AccountModel<Self::CommitmentScheme> {
--        &self.account_model
-+    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-     }
--}
--```
-+}```
- 
- ###### Directory: transaction_models/src/utxo
- 
- ####### File: transaction_models/src/utxo/mod.rs
--####*Size: 20K, Lines: 578, Type: ASCII text*
-+####*Size: 8.0K, Lines: 190, Type: ASCII text*
- 
- ```rust
--//! UTXO-based transaction model implementation.
-+// Path: crates/transaction_models/src/utxo/mod.rs
- 
--use depin_sdk_core::crypto::SerializableKey;
--use depin_sdk_core::crypto::VerifyingKey;
--use depin_sdk_crypto::{algorithms::hash::sha256, sign::eddsa::{Ed25519PublicKey, Ed25519Signature}};
- use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::TransactionError;
-+use depin_sdk_core::error::{StateError, TransactionError};
- use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use std::any::Any;
--use std::collections::HashMap;
-+use serde::{Deserialize, Serialize};
-+use sha2::{Digest, Sha256};
- 
--/// UTXO transaction input
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct UTXOInput {
--    /// Previous transaction ID
--    pub prev_txid: Vec<u8>,
--    /// Output index in the previous transaction
--    pub prev_index: u32,
--    /// Signature unlocking the UTXO
-+#[derive(Debug, Clone, Default)]
-+pub struct UTXOConfig {
-+    pub max_inputs: usize,
-+    pub max_outputs: usize,
-+}
-+
-+pub trait UTXOOperations {
-+    fn create_utxo_key(&self, tx_hash: &[u8], index: u32) -> Vec<u8>;
-+}
-+
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-+pub struct Input {
-+    pub tx_hash: Vec<u8>,
-+    pub output_index: u32,
-     pub signature: Vec<u8>,
- }
- 
--/// UTXO transaction output
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct UTXOOutput {
--    /// Value of the output
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-+pub struct Output {
-     pub value: u64,
--    /// Locking script or public key hash
--    pub lock_script: Vec<u8>,
-+    pub public_key: Vec<u8>,
- }
- 
--/// UTXO transaction
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
- pub struct UTXOTransaction {
--    /// Transaction ID
--    pub txid: Vec<u8>,
--    /// Inputs (references to previous transaction outputs)
--    pub inputs: Vec<UTXOInput>,
--    /// Outputs (new unspent transaction outputs)
--    pub outputs: Vec<UTXOOutput>,
-+    pub inputs: Vec<Input>,
-+    pub outputs: Vec<Output>,
- }
- 
- impl UTXOTransaction {
--    /// Check if this is a coinbase transaction (has no inputs)
--    pub fn is_coinbase(&self) -> bool {
--        self.inputs.is_empty()
-+    pub fn hash(&self) -> Vec<u8> {
-+        let serialized = serde_json::to_vec(self).unwrap();
-+        Sha256::digest(&serialized).to_vec()
-     }
- }
- 
--/// UTXO proof data
- #[derive(Debug, Clone)]
--pub struct UTXOProof {
--    /// Proofs for transaction inputs
--    pub input_proofs: Vec<Vec<u8>>,
--    /// Additional data needed for verification
--    pub metadata: HashMap<String, Vec<u8>>,
--}
--
--/// UTXO-specific operations
--pub trait UTXOOperations {
--    /// Create a key for a UTXO in the state store.
--    ///
--    /// # Arguments
--    /// * `txid` - Transaction ID.
--    /// * `index` - Output index.
--    ///
--    /// # Returns
--    /// * `Ok(key)` - The generated key.
--    /// * `Err(TransactionError)` - If key creation failed.
--    fn create_utxo_key(&self, txid: &[u8], index: u32) -> Result<Vec<u8>, TransactionError>;
--}
--
--/// Configuration for the UTXO model
--#[derive(Clone)]
--pub struct UTXOConfig {
--    /// Minimum confirmations required for spending
--    pub min_confirmations: u32,
--    /// Maximum number of inputs per transaction
--    pub max_inputs: usize,
--    /// Maximum number of outputs per transaction
--    pub max_outputs: usize,
--    /// Maximum coinbase value (for block rewards)
--    pub max_coinbase_value: u64,
--    /// Whether to allow coinbase transactions
--    pub allow_coinbase: bool,
--}
--
--impl Default for UTXOConfig {
--    fn default() -> Self {
--        Self {
--            min_confirmations: 1,
--            max_inputs: 100,
--            max_outputs: 100,
--            max_coinbase_value: 50_000_000, // 50 coins with 6 decimal places
--            allow_coinbase: true,
--        }
--    }
--}
--
--/// UTXO transaction model implementation
- pub struct UTXOModel<CS: CommitmentScheme> {
--    /// Model configuration
-     config: UTXOConfig,
--    /// The commitment scheme
--    scheme: CS,
-+    _commitment_scheme: CS,
- }
- 
--impl<CS: CommitmentScheme> UTXOModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    /// Create a new UTXO model with default configuration.
--    pub fn new(scheme: CS) -> Self {
-+impl<CS: CommitmentScheme + Clone> UTXOModel<CS> {
-+    pub fn new(commitment_scheme: CS) -> Self {
-         Self {
-             config: UTXOConfig::default(),
--            scheme,
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
--
--    /// Create a new UTXO model with custom configuration.
--    pub fn with_config(scheme: CS, config: UTXOConfig) -> Self {
-+    pub fn with_config(commitment_scheme: CS, config: UTXOConfig) -> Self {
-         Self {
-             config,
--            scheme,
--        }
--    }
--
--    /// Get model configuration.
--    pub fn config(&self) -> &UTXOConfig {
--        &self.config
--    }
--
--    /// Get the commitment scheme
--    pub fn scheme(&self) -> &CS {
--        &self.scheme
--    }
--
--    /// Helper method to get a UTXO from the state.
--    fn get_utxo<S>(
--        &self,
--        state: &S,
--        txid: &[u8],
--        index: u32,
--    ) -> Result<Option<UTXOOutput>, TransactionError>
--    where
--        S: StateManager<
--            Commitment = CS::Commitment,
--            Proof = CS::Proof,
--        > + ?Sized,
--    {
--        let key = self.create_utxo_key(txid, index)?;
--        let value = state
--            .get(&key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--
--        match value {
--            Some(data) => self.decode_utxo(&data),
--            None => Ok(None),
--        }
--    }
--
--    /// Helper method to decode a UTXO from bytes.
--    fn decode_utxo(&self, data: &[u8]) -> Result<Option<UTXOOutput>, TransactionError> {
--        if data.len() < 8 {
--            return Err(TransactionError::SerializationError(
--                "UTXO data too short".to_string(),
--            ));
-+            _commitment_scheme: commitment_scheme,
-         }
--
--        let mut value_bytes = [0u8; 8];
--        value_bytes.copy_from_slice(&data[0..8]);
--        let value = u64::from_le_bytes(value_bytes);
--        let lock_script = data[8..].to_vec();
--
--        Ok(Some(UTXOOutput { value, lock_script }))
--    }
--
--    /// Helper method to encode a UTXO to bytes.
--    fn encode_utxo(&self, output: &UTXOOutput) -> Vec<u8> {
--        let mut data = Vec::with_capacity(8 + output.lock_script.len());
--        data.extend_from_slice(&output.value.to_le_bytes());
--        data.extend_from_slice(&output.lock_script);
--        data
--    }
--    
--    /// Convert raw bytes to the commitment scheme's value type
--    fn to_value(&self, bytes: &[u8]) -> CS::Value {
--        CS::Value::from(bytes.to_vec())
-     }
-+}
- 
--    /// Validate a coinbase transaction
--    fn validate_coinbase(&self, tx: &UTXOTransaction) -> Result<bool, TransactionError> {
--        // Check if coinbase transactions are allowed
--        if !self.config.allow_coinbase {
--            return Ok(false);
--        }
--
--        // Verify total output value doesn't exceed maximum
--        let mut total_output = 0u64;
--        for output in &tx.outputs {
--            total_output = total_output.checked_add(output.value).ok_or_else(|| {
--                TransactionError::InvalidTransaction("Coinbase output value overflow".to_string())
--            })?;
--        }
--
--        if total_output > self.config.max_coinbase_value {
--            return Ok(false);
--        }
--
--        // Additional coinbase validation could go here:
--        // - Check block height for reward schedule
--        // - Verify only one coinbase per block
--        // - Validate special coinbase fields
--
--        Ok(true)
-+impl<CS: CommitmentScheme> UTXOOperations for UTXOModel<CS> {
-+    fn create_utxo_key(&self, tx_hash: &[u8], index: u32) -> Vec<u8> {
-+        let mut key = b"u".to_vec();
-+        key.extend_from_slice(tx_hash);
-+        key.extend_from_slice(&index.to_le_bytes());
-+        key
-     }
- }
- 
--impl<CS: CommitmentScheme> TransactionModel for UTXOModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
-+impl<CS: CommitmentScheme + Clone + Send + Sync> TransactionModel for UTXOModel<CS> {
-     type Transaction = UTXOTransaction;
--    type Proof = UTXOProof;
-     type CommitmentScheme = CS;
-+    type Proof = ();
- 
--    fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-+    fn validate<SM>(&self, tx: &Self::Transaction, state: &SM) -> Result<bool, TransactionError>
-     where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+        SM: StateManager<
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Check transaction structure
--        if tx.outputs.is_empty() {
--            return Ok(false);
--        }
--
--        if tx.outputs.len() > self.config.max_outputs {
--            return Ok(false);
--        }
--
--        // Handle coinbase transactions (no inputs)
--        if tx.is_coinbase() {
--            return self.validate_coinbase(tx);
-+        // --- FIX: Add special validation logic for coinbase transactions ---
-+        // A coinbase transaction is the only valid transaction type with no inputs.
-+        if tx.inputs.is_empty() {
-+            // A valid coinbase should have at least one output to reward the miner.
-+            // More complex rules (e.g., exactly one output) could be added here.
-+            return Ok(!tx.outputs.is_empty());
-         }
-+        // --- End Fix ---
- 
--        // Regular transaction validation
--        if tx.inputs.len() > self.config.max_inputs {
-+        if tx.inputs.len() > self.config.max_inputs || tx.outputs.len() > self.config.max_outputs {
-             return Ok(false);
-         }
- 
--        // Validate inputs exist and are unspent
--        let mut total_input = 0u64;
--
-+        let mut total_input: u64 = 0;
-         for input in &tx.inputs {
--            let utxo = self.get_utxo(state, &input.prev_txid, input.prev_index)?;
--
--            match utxo {
--                Some(output) => {
--                    // Reconstruct the digest that was signed.
--                    let mut digest_data = Vec::new();
--                    digest_data.extend_from_slice(&input.prev_txid);
--                    let digest = sha256(&digest_data);
--
--                    let public_key = Ed25519PublicKey::from_bytes(&output.lock_script).map_err(|e| TransactionError::InvalidSignature(e))?;
--                    let signature = Ed25519Signature::from_bytes(&input.signature).map_err(|e| TransactionError::InvalidSignature(e))?;
--
--                    if !public_key.verify(&digest, &signature) {
--                        return Err(TransactionError::InvalidSignature("Signature verification failed".to_string()));
--                    }
--
--                    total_input = total_input.checked_add(output.value).ok_or_else(|| {
--                        TransactionError::InvalidTransaction("Input value overflow".to_string())
--                    })?;
--                }
--                None => return Ok(false), // Input UTXO not found
--            }
--        }
--
--        // Calculate total output
--        let mut total_output = 0u64;
--
--        for output in &tx.outputs {
--            total_output = total_output.checked_add(output.value).ok_or_else(|| {
--                TransactionError::InvalidTransaction("Output value overflow".to_string())
-+            let key = self.create_utxo_key(&input.tx_hash, input.output_index);
-+            let utxo_bytes = state.get(&key)?.ok_or_else(|| {
-+                TransactionError::Invalid(format!("Input UTXO not found"))
-             })?;
-+            let utxo: Output = serde_json::from_slice(&utxo_bytes)
-+                .map_err(|e| TransactionError::Invalid(format!("Deserialize error: {}", e)))?;
-+            total_input = total_input.checked_add(utxo.value)
-+                .ok_or_else(|| TransactionError::Invalid("Input value overflow".to_string()))?;
-         }
- 
--        // Ensure total input >= total output (the difference is the fee)
-+        let total_output: u64 = tx.outputs.iter().map(|o| o.value).sum();
-         if total_input < total_output {
-             return Ok(false);
-         }
-@@ -14906,325 +13262,96 @@ where
-         Ok(true)
-     }
- 
--    fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-+    fn apply<SM>(&self, tx: &Self::Transaction, state: &mut SM) -> Result<(), TransactionError>
-     where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+        SM: StateManager<
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Validate transaction first
-         if !self.validate(tx, state)? {
--            return Err(TransactionError::InvalidTransaction(
--                "Transaction validation failed".to_string(),
--            ));
-+            return Err(TransactionError::Invalid("Validation failed".to_string()));
-         }
--
--        // Only remove spent inputs for non-coinbase transactions
--        if !tx.is_coinbase() {
--            for input in &tx.inputs {
--                let key = self.create_utxo_key(&input.prev_txid, input.prev_index)?;
--                state
--                    .delete(&key)
--                    .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--            }
-+        for input in &tx.inputs {
-+            let key = self.create_utxo_key(&input.tx_hash, input.output_index);
-+            state.delete(&key)?;
-         }
--
--        // Add new outputs (for both coinbase and regular transactions)
--        for (i, output) in tx.outputs.iter().enumerate() {
--            let key = self.create_utxo_key(&tx.txid, i as u32)?;
--            let value = self.encode_utxo(output);
--
--            state
--                .set(&key, &value)
--                .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
-+        let tx_hash = tx.hash();
-+        for (index, output) in tx.outputs.iter().enumerate() {
-+            let key = self.create_utxo_key(&tx_hash, index as u32);
-+            let value = serde_json::to_vec(output)
-+                .map_err(|e| TransactionError::Serialization(e.to_string()))?;
-+            state.insert(&key, &value)?;
-         }
--
-         Ok(())
-     }
- 
--    fn generate_proof<S>(
-+    fn create_coinbase_transaction(
-         &self,
--        tx: &Self::Transaction,
--        state: &S,
--    ) -> Result<Self::Proof, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
--    {
--        let mut input_proofs = Vec::with_capacity(tx.inputs.len());
--
--        // Coinbase transactions don't need input proofs
--        if tx.is_coinbase() {
--            return Ok(UTXOProof {
--                input_proofs,
--                metadata: HashMap::new(),
--            });
--        }
--
--        for input in &tx.inputs {
--            let key = self.create_utxo_key(&input.prev_txid, input.prev_index)?;
--
--            // In a real implementation, we would create cryptographic proofs
--            // For this example, we'll just get the raw UTXO data
--            let utxo_data = state
--                .get(&key)
--                .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?
--                .ok_or_else(|| {
--                    TransactionError::InvalidInput("Referenced UTXO not found".to_string())
--                })?;
--
--            input_proofs.push(utxo_data);
--        }
--
--        Ok(UTXOProof {
--            input_proofs,
--            metadata: HashMap::new(),
-+        _block_height: u64,
-+        recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError> {
-+        Ok(UTXOTransaction {
-+            inputs: vec![],
-+            outputs: vec![Output { value: 50, public_key: recipient.to_vec() }],
-         })
-     }
- 
--    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-+    fn generate_proof<S>(
-+        &self,
-+        _tx: &Self::Transaction,
-+        _state: &S,
-+    ) -> Result<Self::Proof, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
--    {
--        // In a real implementation, this would verify cryptographic proofs
--        // For this example, we'll just return true
--        Ok(true)
--    }
--
--    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        // Simple manual serialization for demonstration
--        let mut data = Vec::new();
--
--        // Serialize txid
--        data.extend_from_slice(&(tx.txid.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.txid);
--
--        // Serialize inputs
--        data.extend_from_slice(&(tx.inputs.len() as u32).to_le_bytes());
--        for input in &tx.inputs {
--            data.extend_from_slice(&(input.prev_txid.len() as u32).to_le_bytes());
--            data.extend_from_slice(&input.prev_txid);
--            data.extend_from_slice(&input.prev_index.to_le_bytes());
--            data.extend_from_slice(&(input.signature.len() as u32).to_le_bytes());
--            data.extend_from_slice(&input.signature);
--        }
--
--        // Serialize outputs
--        data.extend_from_slice(&(tx.outputs.len() as u32).to_le_bytes());
--        for output in &tx.outputs {
--            data.extend_from_slice(&output.value.to_le_bytes());
--            data.extend_from_slice(&(output.lock_script.len() as u32).to_le_bytes());
--            data.extend_from_slice(&output.lock_script);
--        }
--
--        Ok(data)
--    }
--
--    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        if data.len() < 4 {
--            return Err(TransactionError::SerializationError(
--                "Data too short".to_string(),
--            ));
--        }
--
--        let mut pos = 0;
--
--        // Deserialize txid
--        let txid_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + txid_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid txid length".to_string(),
--            ));
--        }
--
--        let txid = data[pos..pos + txid_len].to_vec();
--        pos += txid_len;
--
--        // Deserialize inputs
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let input_count = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        let mut inputs = Vec::with_capacity(input_count);
--        for _ in 0..input_count {
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let prev_txid_len = read_u32(&data[pos..pos + 4]) as usize;
--            pos += 4;
--
--            if pos + prev_txid_len > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid prev_txid length".to_string(),
--                ));
--            }
--
--            let prev_txid = data[pos..pos + prev_txid_len].to_vec();
--            pos += prev_txid_len;
--
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let prev_index = read_u32(&data[pos..pos + 4]);
--            pos += 4;
--
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let signature_len = read_u32(&data[pos..pos + 4]) as usize;
--            pos += 4;
--
--            if pos + signature_len > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid signature length".to_string(),
--                ));
--            }
--
--            let signature = data[pos..pos + signature_len].to_vec();
--            pos += signature_len;
--
--            inputs.push(UTXOInput {
--                prev_txid,
--                prev_index,
--                signature,
--            });
--        }
--
--        // Deserialize outputs
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let output_count = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        let mut outputs = Vec::with_capacity(output_count);
--        for _ in 0..output_count {
--            if pos + 8 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let mut value_bytes = [0u8; 8];
--            value_bytes.copy_from_slice(&data[pos..pos + 8]);
--            let value = u64::from_le_bytes(value_bytes);
--            pos += 8;
--
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let lock_script_len = read_u32(&data[pos..pos + 4]) as usize;
--            pos += 4;
--
--            if pos + lock_script_len > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid lock_script length".to_string(),
--                ));
--            }
--
--            let lock_script = data[pos..pos + lock_script_len].to_vec();
--            pos += lock_script_len;
--
--            outputs.push(UTXOOutput { value, lock_script });
--        }
--
--        Ok(UTXOTransaction {
--            txid,
--            inputs,
--            outputs,
--        })
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-+    {
-+        Ok(())
-     }
- 
--    fn get_model_extensions(&self) -> Option<&dyn Any> {
--        Some(self as &dyn Any)
-+    fn verify_proof<S>(
-+        &self,
-+        _proof: &Self::Proof,
-+        _state: &S,
-+    ) -> Result<bool, TransactionError>
-+    where
-+        S: StateManager<
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-+    {
-+        Ok(true)
-     }
--}
- 
--impl<CS: CommitmentScheme> UTXOOperations for UTXOModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    fn create_utxo_key(&self, txid: &[u8], index: u32) -> Result<Vec<u8>, TransactionError> {
--        let mut key = Vec::with_capacity(txid.len() + 5);
--        key.push(b'u'); // Prefix 'u' for UTXO
--        key.extend_from_slice(txid);
--        key.extend_from_slice(&index.to_le_bytes());
--        Ok(key)
-+    fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
-+        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
--}
- 
--/// Helper function to read a u32 from a byte slice
--fn read_u32(data: &[u8]) -> u32 {
--    let mut bytes = [0u8; 4];
--    bytes.copy_from_slice(data);
--    u32::from_le_bytes(bytes)
-+    fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-+    }
- }```
- 
- ###### File: transaction_models/src/lib.rs
--###*Size: 4.0K, Lines: 29, Type: ASCII text*
-+###*Size: 4.0K, Lines: 10, Type: ASCII text*
- 
- ```rust
--//! # DePIN SDK Transaction Models
--//!
--//! Implementations of various transaction models for the DePIN SDK.
--//!
--//! This crate provides concrete implementations of the transaction model
--//! interfaces defined in the `depin_sdk_core` crate.
--//!
--//! ## Usage
--//!
--//! Each transaction model is implemented in its own module.
--//! Applications should import the specific model types they wish to use.
--//!
--//! ```rust
--//! // Example: Using the UTXO model
--//! use transaction_models::utxo::{UTXOModel, UTXOProof, UTXOTransaction};
--//!
--//! // Example: Using the account model
--//! use transaction_models::account::{AccountModel, AccountProof, AccountTransaction};
--//! ```
-+// Path: crates/transaction_models/src/lib.rs
- 
--// Modules for each transaction model
-+#![allow(clippy::new_without_default)]
- pub mod account;
- pub mod hybrid;
- pub mod utxo;
- 
--// Re-export operation traits for convenience
--pub use account::AccountOperations;
--pub use hybrid::HybridOperations;
--pub use utxo::UTXOOperations;
--```
-+pub use account::{AccountConfig, AccountModel, AccountTransaction};
-+// FIX: The HybridOperations trait does not exist, so this line is removed.
-+pub use hybrid::{HybridConfig, HybridModel, HybridTransaction};
-+pub use utxo::{UTXOConfig, UTXOModel, UTXOTransaction};```
- 
- ##### File: transaction_models/Cargo.toml
--##*Size: 4.0K, Lines: 22, Type: ASCII text*
-+##*Size: 4.0K, Lines: 19, Type: ASCII text*
- 
- ```toml
- [package]
-@@ -15235,20 +13362,17 @@ description = "Transaction model implementations for the DePIN SDK"
- license = "MIT OR Apache-2.0"
- 
- [dependencies]
--depin-sdk-crypto = { path = "../crypto", optional = true }
- depin-sdk-core = { path = "../core" }
- log = { workspace = true }
--serde = { workspace = true }
-+serde = { workspace = true, features = ["derive"] }
-+serde_json = { workspace = true }
- thiserror = { workspace = true }
--bytes = { workspace = true }
--anyhow = { workspace = true }
--
-+sha2 = { workspace = true }
-+# FIX: Add the missing 'hex' dependency used for logging UTXO hashes.
-+hex = { workspace = true }
- 
- [features]
--default = ["dep:depin-sdk-crypto"]
--utxo-model = []
--account-model = []
--hybrid-model = []
-+default = []
- ```
- 
- #### Directory: validator
-@@ -15258,186 +13382,153 @@ hybrid-model = []
- ###### Directory: validator/src/bin
- 
- ####### File: validator/src/bin/validator_hybrid.rs
--####*Size: 4.0K, Lines: 88, Type: ASCII text*
-+####*Size: 4.0K, Lines: 73, Type: C source, ASCII text*
- 
- ```rust
--//! Hybrid validator binary
-+// Path: crates/validator/src/bin/validator_hybrid.rs
- 
--use std::env;
--use std::path::Path;
--use depin_sdk_validator::hybrid::HybridValidator;
-+use anyhow::anyhow;
-+use clap::Parser;
-+// FIX: Import WorkloadContainer from its new, correct location in `core`.
-+use depin_sdk_core::validator::WorkloadContainer;
-+use depin_sdk_core::{config::WorkloadConfig, Container};
-+use depin_sdk_state_trees::file::FileStateTree;
-+// FIX: Add necessary imports.
-+use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-+use depin_sdk_validator::{
-+    common::GuardianContainer,
-+    hybrid::{ApiContainer, InterfaceContainer},
-+    standard::OrchestrationContainer,
-+};
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
-+
-+
-+#[derive(Parser, Debug)]
-+#[clap(name = "validator_hybrid", about = "A hybrid DePIN SDK validator node with public APIs.")]
-+struct Opts {
-+    #[clap(long, default_value = "./config")]
-+    config_dir: String,
-+}
- 
- #[tokio::main]
--async fn main() -> Result<(), Box<dyn std::error::Error>> {
--    // Parse command-line arguments
--    let args: Vec<String> = env::args().collect();
--    let container_type = if args.len() > 1 { &args[1] } else { "all" };
--    
--    // Default config directory is ./config
--    let config_dir = env::var("CONFIG_DIR").unwrap_or_else(|_| "./config".to_string());
-+async fn main() -> anyhow::Result<()> {
-+    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-+    let opts = Opts::parse();
-+    let path = PathBuf::from(opts.config_dir);
-+
-+    log::info!("Initializing Hybrid Validator...");
-+
-+    // FIX: Pass borrowed paths (`&`) to the `new` constructors.
-+    let guardian = GuardianContainer::new(&path.join("guardian.toml"))?;
-+
-+    let state_tree = FileStateTree::new("state.json", HashCommitmentScheme::new());
-+
-+    let workload = Arc::new(WorkloadContainer::new(
-+        WorkloadConfig::default(),
-+        state_tree,
-+    ));
-+
-+    let orchestration = Arc::new(OrchestrationContainer::new(
-+        &path.join("orchestration.toml"),
-+    )?);
-     
--    println!("Starting DePIN SDK Hybrid Validator");
--    println!("Container type: {}", container_type);
--    println!("Config directory: {}", config_dir);
-+    // Wire up a dummy chain for now.
-+    orchestration.set_chain_and_workload_ref(Arc::new(Mutex::new(())), workload);
-+
-+    let interface = InterfaceContainer::new(&path.join("interface.toml"))?;
-+    let api = ApiContainer::new(&path.join("api.toml"))?;
-+
-+
-+    log::info!("Starting services...");
-+    guardian.start()?;
-+    // FIX: The start method is async and must be awaited.
-+    orchestration.start().await?;
-+    interface.start()?;
-+    api.start()?;
-+
-+    tokio::signal::ctrl_c().await?;
-+    log::info!("Shutdown signal received.");
-+
-+    api.stop()?;
-+    interface.stop()?;
-+    orchestration.stop().await?;
-+    guardian.stop()?;
-+    log::info!("Validator stopped gracefully.");
-     
--    match container_type {
--        "guardian" => {
--            // Start only the guardian container
--            let path = Path::new(&config_dir);
--            let guardian = depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"));
--            guardian.start_boot()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "orchestration" => {
--            // Start only the orchestration container
--            let path = Path::new(&config_dir);
--            let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(path.join("orchestration.toml"));
--            orchestration.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "workload" => {
--            // Start only the workload container
--            let path = Path::new(&config_dir);
--            let workload = depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"));
--            workload.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "interface" => {
--            // Start only the interface container
--            let path = Path::new(&config_dir);
--            let interface = depin_sdk_validator::hybrid::InterfaceContainer::new(path.join("interface.toml"));
--            interface.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "api" => {
--            // Start only the API container
--            let path = Path::new(&config_dir);
--            let api = depin_sdk_validator::hybrid::ApiContainer::new(path.join("api.toml"));
--            api.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "all" | _ => {
--            // Start the full validator
--            let path = Path::new(&config_dir);
--            let validator = HybridValidator::new(path)?;
--            validator.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--    }
--}
--```
-+    Ok(())
-+}```
- 
- ####### File: validator/src/bin/validator.rs
--####*Size: 4.0K, Lines: 82, Type: ASCII text*
-+####*Size: 4.0K, Lines: 64, Type: C source, ASCII text*
- 
- ```rust
--//! Standard validator binary
-+// Path: crates/validator/src/bin/validator.rs
- 
--use depin_sdk_validator::standard::StandardValidator;
--use std::env;
--use std::path::Path;
-+use anyhow::anyhow;
-+use clap::Parser;
-+use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-+// FIX: core::Container is now async
-+use depin_sdk_core::validator::{Container, WorkloadContainer};
-+use depin_sdk_core::WorkloadConfig;
-+use depin_sdk_state_trees::file::FileStateTree;
-+use depin_sdk_validator::{common::GuardianContainer, standard::OrchestrationContainer};
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
-+
-+#[derive(Parser, Debug)]
-+#[clap(name = "validator", about = "A standard DePIN SDK validator node.")]
-+struct Opts {
-+    #[clap(long, default_value = "./config")]
-+    config_dir: String,
-+}
- 
- #[tokio::main]
--async fn main() -> Result<(), Box<dyn std::error::Error>> {
--    // Parse command-line arguments
--    let args: Vec<String> = env::args().collect();
--    let container_type = if args.len() > 1 { &args[1] } else { "all" };
--
--    // Default config directory is ./config
--    let config_dir = env::var("CONFIG_DIR").unwrap_or_else(|_| "./config".to_string());
--
--    println!("Starting DePIN SDK Standard Validator");
--    println!("Container type: {}", container_type);
--    println!("Config directory: {}", config_dir);
--
--    match container_type {
--        "guardian" => {
--            // Start only the guardian container
--            let path = Path::new(&config_dir);
--            let guardian =
--                depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"));
--            guardian.start_boot()?;
--
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        "orchestration" => {
--            // Start only the orchestration container
--            let path = Path::new(&config_dir);
--            let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(
--                path.join("orchestration.toml"),
--            );
--            orchestration.start()?;
-+async fn main() -> anyhow::Result<()> {
-+    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-+    let opts = Opts::parse();
-+    let path = PathBuf::from(opts.config_dir);
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        "workload" => {
--            // Start only the workload container
--            let path = Path::new(&config_dir);
--            let workload =
--                depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"));
--            workload.start()?;
-+    log::info!("Initializing Standard Validator...");
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        // Fixed: Separate "all" case from wildcard pattern to avoid Clippy warning
--        "all" => {
--            // Start the full validator
--            let path = Path::new(&config_dir);
--            let validator = StandardValidator::new(path)?;
--            validator.start()?;
-+    let guardian = GuardianContainer::new(&path.join("guardian.toml"))?;
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        _ => {
--            // Default to full validator for any other input
--            let path = Path::new(&config_dir);
--            let validator = StandardValidator::new(path)?;
--            validator.start()?;
-+    let state_tree = FileStateTree::new("state.json", HashCommitmentScheme::new());
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--    }
--}
--```
-+    let workload_config = WorkloadConfig {
-+        enabled_vms: vec!["WASM".to_string()],
-+    };
-+
-+    let workload = Arc::new(WorkloadContainer::new(workload_config, state_tree));
-+
-+    // FIX: OrchestrationContainer::new is now async and must be awaited.
-+    let orchestration = Arc::new(
-+        OrchestrationContainer::<
-+            HashCommitmentScheme,
-+            (), // Placeholder for TM
-+            FileStateTree<HashCommitmentScheme>,
-+        >::new(&path.join("orchestration.toml"))
-+        .await?,
-+    );
-+
-+    // Wire up a dummy chain for now. In a real scenario, this would be part of the composition root.
-+    // orchestration.set_chain_and_workload_ref(Arc::new(Mutex::new(())), workload);
-+
-+    log::info!("Starting services...");
-+    orchestration.start().await?;
-+    guardian.start().await?;
-+
-+    tokio::signal::ctrl_c().await?;
-+    log::info!("Shutdown signal received.");
-+
-+    orchestration.stop().await?;
-+    guardian.stop().await?;
-+    log::info!("Validator stopped gracefully.");
-+
-+    Ok(())
-+}```
- 
- ###### Directory: validator/src/common
- 
-@@ -15916,77 +14007,73 @@ mod tests {
- ```
- 
- ####### File: validator/src/common/guardian.rs
--####*Size: 4.0K, Lines: 67, Type: ASCII text*
-+####*Size: 4.0K, Lines: 63, Type: ASCII text*
- 
- ```rust
--//! Implementation of the guardian container
-+// Path: crates/validator/src/common/guardian.rs
- 
-+use async_trait::async_trait;
-+use depin_sdk_core::error::ValidatorError;
-+use depin_sdk_core::validator::{Container, GuardianContainer as GuardianContainerTrait};
- use std::path::Path;
--use std::error::Error;
--use std::sync::{Arc, Mutex};
-+// FIX: Add imports for atomic state management
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
- 
--/// Guardian container for security, boot process, and attestation
-+#[derive(Debug, Default)]
- pub struct GuardianContainer {
--    /// Configuration path
--    config_path: String,
--    /// Boot status
--    boot_status: Arc<Mutex<BootStatus>>,
-+    // FIX: Use Arc<AtomicBool> for thread-safe interior mutability.
-+    running: Arc<AtomicBool>,
- }
- 
--/// Boot status
--#[derive(Debug, Clone, Copy, PartialEq, Eq)]
--pub enum BootStatus {
--    /// Not started
--    NotStarted,
--    /// In progress
--    InProgress,
--    /// Completed successfully
--    Completed,
--    /// Failed
--    Failed,
-+impl GuardianContainer {
-+    pub fn new(_config_path: &Path) -> anyhow::Result<Self> {
-+        // FIX: Initialize the atomic bool correctly.
-+        Ok(Self {
-+            running: Arc::new(AtomicBool::new(false)),
-+        })
-+    }
- }
- 
--impl GuardianContainer {
--    /// Create a new guardian container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
--        Self {
--            config_path: config_path.as_ref().to_string_lossy().to_string(),
--            boot_status: Arc::new(Mutex::new(BootStatus::NotStarted)),
--        }
-+#[async_trait]
-+impl Container for GuardianContainer {
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!("Starting GuardianContainer...");
-+        // FIX: Atomically set the running flag to true.
-+        self.running.store(true, Ordering::SeqCst);
-+        Ok(())
-     }
--    
--    /// Start the boot process
--    pub fn start_boot(&self) -> Result<(), Box<dyn Error>> {
--        let mut status = self.boot_status.lock().unwrap();
--        *status = BootStatus::InProgress;
--        
--        // Perform boot process (simplified for initial setup)
--        println!("Guardian container starting boot process...");
--        
--        // In a real implementation, we would:
--        // 1. Verify hardware attestation
--        // 2. Check secure boot status
--        // 3. Initialize security boundaries
--        
--        *status = BootStatus::Completed;
--        println!("Guardian container boot process completed.");
--        
-+
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("Stopping GuardianContainer...");
-+        // FIX: Atomically set the running flag to false.
-+        self.running.store(false, Ordering::SeqCst);
-         Ok(())
-     }
--    
--    /// Get the current boot status
--    pub fn boot_status(&self) -> BootStatus {
--        *self.boot_status.lock().unwrap()
-+
-+    fn is_running(&self) -> bool {
-+        // FIX: Atomically load the value of the running flag.
-+        self.running.load(Ordering::SeqCst)
-     }
--    
--    /// Verify attestation
--    pub fn verify_attestation(&self) -> Result<bool, Box<dyn Error>> {
--        // Simplified attestation verification for initial setup
--        // In a real implementation, we would verify hardware attestation
--        Ok(true)
-+
-+    fn id(&self) -> &'static str {
-+        "guardian"
-     }
- }
--```
-+
-+impl GuardianContainerTrait for GuardianContainer {
-+    fn start_boot(&self) -> Result<(), ValidatorError> {
-+        log::info!("Guardian: Initiating secure boot sequence...");
-+        Ok(())
-+    }
-+
-+    fn verify_attestation(&self) -> Result<bool, ValidatorError> {
-+        log::info!("Guardian: Verifying inter-container attestation...");
-+        Ok(true)
-+    }
-+}```
- 
- ####### File: validator/src/common/mod.rs
- ####*Size: 4.0K, Lines: 10, Type: ASCII text*
-@@ -16005,7 +14092,7 @@ pub use security::*;
- ```
- 
- ####### File: validator/src/common/security.rs
--####*Size: 4.0K, Lines: 56, Type: ASCII text*
-+####*Size: 4.0K, Lines: 55, Type: ASCII text*
- 
- ```rust
- //! Implementation of security boundaries between containers
-@@ -16035,7 +14122,7 @@ impl SecurityChannel {
-     }
-     
-     /// Establish the security channel
--    pub fn establish(&self) -> Result<(), Box<dyn Error>> {
-+    pub fn establish(&self) -> Result<(), Box<dyn Error + Send + Sync>> {
-         // Simplified channel establishment for initial setup
-         // In a real implementation, we would:
-         // 1. Perform mutual authentication
-@@ -16048,7 +14135,7 @@ impl SecurityChannel {
-     }
-     
-     /// Send data through the security channel
--    pub fn send(&self, data: &[u8]) -> Result<(), Box<dyn Error>> {
-+    pub fn send(&self, data: &[u8]) -> Result<(), Box<dyn Error + Send + Sync>> {
-         // Simplified sending for initial setup
-         println!("Sending {} bytes through channel {}", data.len(), self.channel_id);
-         
-@@ -16056,15 +14143,14 @@ impl SecurityChannel {
-     }
-     
-     /// Receive data from the security channel
--    pub fn receive(&self, max_size: usize) -> Result<Vec<u8>, Box<dyn Error>> {
-+    pub fn receive(&self, max_size: usize) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
-         // Simplified receiving for initial setup
-         println!("Receiving up to {} bytes from channel {}", max_size, self.channel_id);
-         
-         // Return empty data for now
-         Ok(Vec::new())
-     }
--}
--```
-+}```
- 
- ###### Directory: validator/src/hybrid
- 
-@@ -16140,296 +14226,155 @@ mod tests {
- ```
- 
- ####### File: validator/src/hybrid/api.rs
--####*Size: 4.0K, Lines: 80, Type: ASCII text*
-+####*Size: 4.0K, Lines: 63, Type: ASCII text*
- 
- ```rust
--//! Implementation of API container
-+// Path: crates/validator/src/hybrid/api.rs
- 
-+use depin_sdk_core::error::ValidatorError;
-+use depin_sdk_core::validator::Container;
-+use serde::Deserialize;
- use std::path::Path;
--use std::error::Error;
--use std::sync::{Arc, Mutex};
-+// FIX: Add imports for atomic state management
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
-+use toml;
-+
-+/// Configuration for the API container, loaded from `api.toml`.
-+#[derive(Deserialize)]
-+pub struct ApiConfig {
-+    pub listen_address: String,
-+    pub enabled_endpoints: Vec<String>,
-+}
- 
--/// API container for API implementation and state queries
-+/// The ApiContainer is responsible for implementing the public-facing JSON-RPC
-+/// or other state-query APIs for a hybrid validator.
- pub struct ApiContainer {
--    /// Configuration path
--    config_path: String,
--    /// Running status
--    running: Arc<Mutex<bool>>,
-+    config: ApiConfig,
-+    // FIX: Use Arc<AtomicBool> for thread-safe state.
-+    running: Arc<AtomicBool>,
- }
- 
- impl ApiContainer {
--    /// Create a new API container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
--        Self {
--            config_path: config_path.as_ref().to_string_lossy().to_string(),
--            running: Arc::new(Mutex::new(false)),
--        }
--    }
--    
--    /// Start the API container
--    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        
--        println!("API container starting...");
--        
--        // In a real implementation, we would:
--        // 1. Initialize API endpoints
--        // 2. Connect to state storage
--        // 3. Start serving requests
--        
--        println!("API container started successfully");
--        
--        Ok(())
--    }
--    
--    /// Stop the API container
--    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        
--        println!("API container stopping...");
--        
--        // In a real implementation, we would:
--        // 1. Gracefully shutdown API server
--        // 2. Close state connections
--        // 3. Clean up resources
--        
--        println!("API container stopped successfully");
--        
--        Ok(())
--    }
--    
--    /// Handle an API request
--    pub fn handle_request(&self, endpoint: &str, params: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
--        if !self.is_running() {
--            return Err("API container is not running".into());
--        }
--        
--        // Simplified API handling for initial setup
--        println!("Handling API request to endpoint {}, {} bytes", endpoint, params.len());
--        
--        // In a real implementation, we would:
--        // 1. Parse the request parameters
--        // 2. Execute the appropriate API function
--        // 3. Format and return the response
--        
--        // Return a dummy response for now
--        Ok(vec![9, 10, 11, 12])
--    }
--    
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
-+    pub fn new(config_path: &Path) -> anyhow::Result<Self> {
-+        let config_str = std::fs::read_to_string(config_path)?;
-+        let config: ApiConfig = toml::from_str(&config_str)?;
-+        Ok(Self {
-+            config,
-+            running: Arc::new(AtomicBool::new(false)),
-+        })
-     }
- }
--```
--
--####### File: validator/src/hybrid/interface.rs
--####*Size: 4.0K, Lines: 82, Type: ASCII text*
--
--```rust
--//! Implementation of interface container
--
--use std::path::Path;
--use std::error::Error;
--use std::sync::{Arc, Mutex};
--use std::net::SocketAddr;
--
--/// Interface container for connection handling and protocol routing
--pub struct InterfaceContainer {
--    /// Configuration path
--    config_path: String,
--    /// Running status
--    running: Arc<Mutex<bool>>,
--}
- 
--impl InterfaceContainer {
--    /// Create a new interface container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
--        Self {
--            config_path: config_path.as_ref().to_string_lossy().to_string(),
--            running: Arc::new(Mutex::new(false)),
--        }
--    }
--    
--    /// Start the interface container
--    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        
--        println!("Interface container starting...");
--        
--        // In a real implementation, we would:
--        // 1. Start listening for connections
--        // 2. Initialize protocol handlers
--        // 3. Set up routing logic
--        
--        println!("Interface container started successfully");
--        
-+#[async_trait::async_trait]
-+impl Container for ApiContainer {
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!(
-+            "Starting ApiContainer, listening on {}...",
-+            self.config.listen_address
-+        );
-+        self.running.store(true, Ordering::SeqCst);
-         Ok(())
-     }
--    
--    /// Stop the interface container
--    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        
--        println!("Interface container stopping...");
--        
--        // In a real implementation, we would:
--        // 1. Close all connections
--        // 2. Stop listeners
--        // 3. Clean up resources
--        
--        println!("Interface container stopped successfully");
--        
-+
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("Stopping ApiContainer...");
-+        self.running.store(false, Ordering::SeqCst);
-         Ok(())
-     }
--    
--    /// Handle a client connection
--    pub fn handle_connection(&self, addr: SocketAddr, data: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
--        if !self.is_running() {
--            return Err("Interface container is not running".into());
--        }
--        
--        // Simplified connection handling for initial setup
--        println!("Handling connection from {}, {} bytes", addr, data.len());
--        
--        // In a real implementation, we would:
--        // 1. Identify the protocol
--        // 2. Route to the appropriate handler
--        // 3. Process the request
--        // 4. Return the response
--        
--        // Return a dummy response for now
--        Ok(vec![5, 6, 7, 8])
-+
-+    fn is_running(&self) -> bool {
-+        self.running.load(Ordering::SeqCst)
-     }
--    
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
-+
-+    fn id(&self) -> &'static str {
-+        "api"
-     }
--}
--```
-+}```
- 
--####### File: validator/src/hybrid/mod.rs
--####*Size: 4.0K, Lines: 112, Type: ASCII text*
-+####### File: validator/src/hybrid/interface.rs
-+####*Size: 4.0K, Lines: 63, Type: ASCII text*
- 
- ```rust
--//! Hybrid validator implementation (5 containers)
-+// Path: crates/validator/src/hybrid/interface.rs
- 
--mod interface;
--mod api;
-+use depin_sdk_core::error::ValidatorError;
-+use depin_sdk_core::validator::Container;
-+use serde::Deserialize;
-+use std::path::Path;
-+// FIX: Add imports for atomic state management
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
-+use toml;
- 
--#[cfg(test)]
--mod tests;
-+/// Configuration for the Interface container, loaded from `interface.toml`.
-+#[derive(Deserialize)]
-+pub struct InterfaceConfig {
-+    pub max_connections: u32,
-+    pub rate_limit_per_second: u64,
-+}
- 
--pub use interface::*;
--pub use api::*;
-+/// The InterfaceContainer manages raw network connections, protocol routing,
-+/// and basic DDoS protection for a hybrid validator's public-facing services.
-+pub struct InterfaceContainer {
-+    config: InterfaceConfig,
-+    // FIX: Use Arc<AtomicBool> for thread-safe state.
-+    running: Arc<AtomicBool>,
-+}
- 
--use std::error::Error;
--use std::path::Path;
--use crate::common::{GuardianContainer, SecurityChannel};
--use crate::standard::{OrchestrationContainer, WorkloadContainer};
--
--/// Hybrid validator with 5 containers
--pub struct HybridValidator {
--    /// Guardian container
--    pub guardian: GuardianContainer,
--    /// Orchestration container
--    pub orchestration: OrchestrationContainer,
--    /// Workload container
--    pub workload: WorkloadContainer,
--    /// Interface container
--    pub interface: InterfaceContainer,
--    /// API container
--    pub api: ApiContainer,
--    /// Security channels between containers
--    security_channels: Vec<SecurityChannel>,
--}
--
--impl HybridValidator {
--    /// Create a new hybrid validator
--    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error>> {
--        let config_dir = config_dir.as_ref();
--        
--        // Create containers
--        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"));
--        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"));
--        let workload = WorkloadContainer::new(config_dir.join("workload.toml"));
--        let interface = InterfaceContainer::new(config_dir.join("interface.toml"));
--        let api = ApiContainer::new(config_dir.join("api.toml"));
--        
--        // Create security channels
--        let mut security_channels = Vec::new();
--        
--        // Guardian to Orchestration
--        let channel_g_o = SecurityChannel::new("guardian", "orchestration");
--        channel_g_o.establish()?;
--        security_channels.push(channel_g_o);
--        
--        // Orchestration to Workload
--        let channel_o_w = SecurityChannel::new("orchestration", "workload");
--        channel_o_w.establish()?;
--        security_channels.push(channel_o_w);
--        
--        // Orchestration to Interface
--        let channel_o_i = SecurityChannel::new("orchestration", "interface");
--        channel_o_i.establish()?;
--        security_channels.push(channel_o_i);
--        
--        // Interface to API
--        let channel_i_a = SecurityChannel::new("interface", "api");
--        channel_i_a.establish()?;
--        security_channels.push(channel_i_a);
--        
-+impl InterfaceContainer {
-+    pub fn new(config_path: &Path) -> anyhow::Result<Self> {
-+        let config_str = std::fs::read_to_string(config_path)?;
-+        let config: InterfaceConfig = toml::from_str(&config_str)?;
-         Ok(Self {
--            guardian,
--            orchestration,
--            workload,
--            interface,
--            api,
--            security_channels,
-+            config,
-+            running: Arc::new(AtomicBool::new(false)),
-         })
-     }
--    
--    /// Start the validator
--    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--        // Start Guardian first
--        self.guardian.start_boot()?;
--        
--        // Start Orchestration
--        self.orchestration.start()?;
--        
--        // Start Workload
--        self.workload.start()?;
--        
--        // Start Interface
--        self.interface.start()?;
--        
--        // Start API
--        self.api.start()?;
--        
--        println!("Hybrid validator started successfully");
--        
-+}
-+
-+#[async_trait::async_trait]
-+impl Container for InterfaceContainer {
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!(
-+            "Starting InterfaceContainer with max {} connections...",
-+            self.config.max_connections
-+        );
-+        self.running.store(true, Ordering::SeqCst);
-         Ok(())
-     }
--    
--    /// Stop the validator
--    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--        // Stop in reverse order
--        self.api.stop()?;
--        self.interface.stop()?;
--        self.workload.stop()?;
--        self.orchestration.stop()?;
--        
--        println!("Hybrid validator stopped successfully");
--        
-+
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("Stopping InterfaceContainer...");
-+        self.running.store(false, Ordering::SeqCst);
-         Ok(())
-     }
--}
--```
-+
-+    fn is_running(&self) -> bool {
-+        self.running.load(Ordering::SeqCst)
-+    }
-+
-+    fn id(&self) -> &'static str {
-+        "interface"
-+    }
-+}```
-+
-+####### File: validator/src/hybrid/mod.rs
-+####*Size: 4.0K, Lines: 7, Type: ASCII text*
-+
-+```rust
-+// Path: crates/validator/src/hybrid/mod.rs
-+
-+pub mod api;
-+pub mod interface;
-+
-+// FIX: Publicly re-export the containers so they are visible to binaries.
-+pub use api::ApiContainer;
-+pub use interface::InterfaceContainer;```
- 
- ###### Directory: validator/src/standard
- 
-@@ -16499,294 +14444,505 @@ mod tests {
- ```
- 
- ####### File: validator/src/standard/mod.rs
--####*Size: 4.0K, Lines: 85, Type: ASCII text*
-+####*Size: 4.0K, Lines: 6, Type: ASCII text*
- 
- ```rust
--//! Standard validator implementation (3 containers)
-+// Path: crates/validator/src/standard/mod.rs
- 
--mod orchestration;
--mod workload;
-+pub mod orchestration;
-+pub mod workload;
- 
--#[cfg(test)]
--mod tests;
-+// FIX: Publicly re-export the container so it's visible to binaries in the same crate.
-+pub use orchestration::OrchestrationContainer;```
- 
--pub use orchestration::*;
--pub use workload::*;
-+####### File: validator/src/standard/orchestration.rs
-+####*Size: 12K, Lines: 273, Type: ASCII text*
-+
-+```rust
-+// Path: crates/validator/src/standard/orchestration.rs
-+
-+use crate::config::OrchestrationConfig;
-+use async_trait::async_trait;
-+use depin_sdk_core::{
-+    chain::SovereignChain,
-+    commitment::CommitmentScheme,
-+    error::ValidatorError,
-+    state::{StateManager, StateTree},
-+    transaction::TransactionModel,
-+    validator::{Container, WorkloadContainer},
-+};
-+use futures::StreamExt;
-+use libp2p::{
-+    core::upgrade, gossipsub, identity, noise, swarm::SwarmEvent, tcp, yamux, Swarm,
-+    SwarmBuilder, Transport,
-+};
-+use std::fmt::Debug;
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
-+use tokio::{
-+    sync::{watch, Mutex, OnceCell},
-+    task::JoinHandle,
-+    time::{self, Duration},
-+};
-+
-+pub struct OrchestrationContainer<CS, TM, ST>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-+    TM::Transaction: Clone + Debug + Send + Sync,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
-+{
-+    _config: OrchestrationConfig,
-+    chain: Arc<OnceCell<Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>>>,
-+    workload: Arc<OnceCell<Arc<WorkloadContainer<ST>>>>,
-+    swarm: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-+    shutdown_sender: Arc<watch::Sender<bool>>,
-+    task_handles: Arc<Mutex<Vec<JoinHandle<()>>>>,
-+    is_running: Arc<AtomicBool>,
-+}
-+
-+impl<CS, TM, ST> OrchestrationContainer<CS, TM, ST>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-+    TM::Transaction: Clone + Debug + Send + Sync,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + Send
-+        + Sync
-+        + 'static
-+        + Debug,
-+    CS::Commitment: Send + Sync + Debug,
-+{
-+    pub async fn new(config_path: &std::path::Path) -> anyhow::Result<Self> {
-+        let _config: OrchestrationConfig =
-+            toml::from_str(&std::fs::read_to_string(config_path)?)?;
-+
-+        let (shutdown_sender, _) = watch::channel(false);
-+
-+        let local_key = identity::Keypair::generate_ed25519();
-+
-+        let swarm = SwarmBuilder::with_existing_identity(local_key)
-+            .with_tokio()
-+            .with_other_transport(|key| {
-+                let noise_config = noise::Config::new(key)
-+                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
-+                let transport = tcp::tokio::Transport::new(tcp::Config::default())
-+                    .upgrade(upgrade::Version::V1Lazy)
-+                    .authenticate(noise_config)
-+                    .multiplex(yamux::Config::default())
-+                    .timeout(std::time::Duration::from_secs(20))
-+                    .boxed();
-+                Ok(transport)
-+            })?
-+            .with_behaviour(|key| {
-+                let gossipsub_config = gossipsub::Config::default();
-+                gossipsub::Behaviour::new(
-+                    gossipsub::MessageAuthenticity::Signed(key.clone()),
-+                    gossipsub_config,
-+                )
-+                .expect("Valid gossipsub config")
-+            })?
-+            .build();
- 
--use std::error::Error;
--use std::path::Path;
--use crate::common::{GuardianContainer, SecurityChannel};
--
--/// Standard validator with 3 containers
--pub struct StandardValidator {
--    /// Guardian container
--    pub guardian: GuardianContainer,
--    /// Orchestration container
--    pub orchestration: OrchestrationContainer,
--    /// Workload container
--    pub workload: WorkloadContainer,
--    /// Security channels between containers
--    security_channels: Vec<SecurityChannel>,
--}
--
--impl StandardValidator {
--    /// Create a new standard validator
--    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error>> {
--        let config_dir = config_dir.as_ref();
--        
--        // Create containers
--        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"));
--        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"));
--        let workload = WorkloadContainer::new(config_dir.join("workload.toml"));
--        
--        // Create security channels
--        let mut security_channels = Vec::new();
--        
--        // Guardian to Orchestration
--        let channel_g_o = SecurityChannel::new("guardian", "orchestration");
--        channel_g_o.establish()?;
--        security_channels.push(channel_g_o);
--        
--        // Orchestration to Workload
--        let channel_o_w = SecurityChannel::new("orchestration", "workload");
--        channel_o_w.establish()?;
--        security_channels.push(channel_o_w);
--        
-         Ok(Self {
--            guardian,
--            orchestration,
--            workload,
--            security_channels,
-+            _config,
-+            chain: Arc::new(OnceCell::new()),
-+            workload: Arc::new(OnceCell::new()),
-+            swarm: Arc::new(Mutex::new(swarm)),
-+            shutdown_sender: Arc::new(shutdown_sender),
-+            task_handles: Arc::new(Mutex::new(Vec::new())),
-+            is_running: Arc::new(AtomicBool::new(false)),
-         })
-     }
--    
--    /// Start the validator
--    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--        // Start Guardian first
--        self.guardian.start_boot()?;
--        
--        // Start Orchestration
--        self.orchestration.start()?;
--        
--        // Start Workload
--        self.workload.start()?;
--        
--        println!("Standard validator started successfully");
--        
--        Ok(())
-+
-+    pub fn set_chain_and_workload_ref(
-+        &self,
-+        chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
-+        workload_ref: Arc<WorkloadContainer<ST>>,
-+    ) {
-+        self.chain.set(chain_ref).expect("Chain ref already set");
-+        self.workload
-+            .set(workload_ref)
-+            .expect("Workload ref already set");
-     }
--    
--    /// Stop the validator
--    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--        // Stop in reverse order
--        self.workload.stop()?;
--        self.orchestration.stop()?;
--        
--        println!("Standard validator stopped successfully");
--        
--        Ok(())
-+
-+    async fn run_event_loop(
-+        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-+        mut shutdown_receiver: watch::Receiver<bool>,
-+    ) {
-+        loop {
-+            tokio::select! {
-+                biased;
-+                _ = shutdown_receiver.changed() => {
-+                    if *shutdown_receiver.borrow() {
-+                        log::info!("Orchestration event loop received shutdown signal.");
-+                        break;
-+                    }
-+                },
-+                event = async { swarm_ref.lock().await.select_next_some().await } => {
-+                     match event {
-+                        SwarmEvent::Behaviour(gossipsub::Event::Message { message, .. }) => {
-+                            log::info!(
-+                                "Received block gossip from peer {:?}: '{}'",
-+                                message.source,
-+                                String::from_utf8_lossy(&message.data)
-+                            );
-+                        }
-+                        SwarmEvent::NewListenAddr { address, .. } => {
-+                            log::info!("OrchestrationContainer now listening on {}", address);
-+                        }
-+                        SwarmEvent::ConnectionEstablished { peer_id, .. } => {
-+                            log::info!("Connection established with peer: {:?}", peer_id);
-+                        }
-+                        _ => {}
-+                    }
-+                }
-+            }
-+        }
-     }
--}
--```
- 
--####### File: validator/src/standard/orchestration.rs
--####*Size: 4.0K, Lines: 62, Type: ASCII text*
-+    async fn run_block_production(
-+        chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
-+        workload_ref: Arc<WorkloadContainer<ST>>,
-+        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-+        is_running: Arc<AtomicBool>,
-+    ) {
-+        let mut interval = time::interval(Duration::from_secs(10));
-+        while is_running.load(Ordering::SeqCst) {
-+            interval.tick().await;
- 
--```rust
--//! Implementation of orchestration container
-+            let new_block;
-+            {
-+                let mut chain = chain_ref.lock().await;
-+                let tm = chain.transaction_model().clone();
-+                let coinbase_result = tm
-+                    .create_coinbase_transaction(chain.status().height + 1, &[]);
-+                
-+                let coinbase = match coinbase_result {
-+                    Ok(tx) => tx,
-+                    Err(e) => {
-+                        log::error!("Failed to create coinbase transaction: {:?}", e);
-+                        continue;
-+                    }
-+                };
- 
--use std::path::Path;
--use std::error::Error;
--use std::sync::{Arc, Mutex};
-+                new_block = chain.create_block(vec![coinbase], &workload_ref);
- 
--/// Orchestration container for node functions and consensus
--pub struct OrchestrationContainer {
--    /// Configuration path
--    config_path: String,
--    /// Running status
--    running: Arc<Mutex<bool>>,
-+                if let Err(e) = chain
-+                    .process_block(new_block.clone(), &workload_ref)
-+                    .await
-+                {
-+                    log::error!("Failed to process new block: {:?}", e);
-+                    continue;
-+                }
-+                log::info!("Produced and processed new block #{}", new_block.header.height);
-+            }
-+            
-+            // --- FIX: Decouple network publishing from the main loop ---
-+            // Spawn a separate task to handle the potentially slow network I/O.
-+            // This prevents the main block production loop from ever getting stuck.
-+            let swarm_clone = swarm_ref.clone();
-+            tokio::spawn(async move {
-+                let mut swarm = swarm_clone.lock().await;
-+                let topic = gossipsub::IdentTopic::new("blocks");
-+                let message_data = serde_json::to_vec(&new_block.header).unwrap_or_default();
-+
-+                if let Err(e) = swarm.behaviour_mut().publish(topic, message_data) {
-+                    log::warn!("Failed to publish block (likely no peers): {:?}", e);
-+                }
-+            });
-+        }
-+        log::info!("Orchestration block production loop finished.");
-+    }
- }
- 
--impl OrchestrationContainer {
--    /// Create a new orchestration container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
--        Self {
--            config_path: config_path.as_ref().to_string_lossy().to_string(),
--            running: Arc::new(Mutex::new(false)),
--        }
-+#[async_trait]
-+impl<CS, TM, ST> Container for OrchestrationContainer<CS, TM, ST>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-+    TM::Transaction: Clone + Debug + Send + Sync,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + Send
-+        + Sync
-+        + 'static
-+        + Debug,
-+    CS::Commitment: Send + Sync + Debug,
-+{
-+    fn id(&self) -> &'static str {
-+        "orchestration_container"
-     }
--    
--    /// Start the orchestration container
--    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        
--        println!("Orchestration container starting...");
--        
--        // In a real implementation, we would:
--        // 1. Initialize consensus mechanism
--        // 2. Connect to peer network
--        // 3. Start block processing
--        
--        println!("Orchestration container started successfully");
-+
-+    fn is_running(&self) -> bool {
-+        self.is_running.load(Ordering::SeqCst)
-+    }
-+
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        if self.is_running() {
-+            return Err(ValidatorError::AlreadyRunning(self.id().to_string()));
-+        }
-+        log::info!("OrchestrationContainer starting...");
-+        self.is_running.store(true, Ordering::SeqCst);
-         
-+        let mut handles = self.task_handles.lock().await;
-+
-+        let event_loop_receiver = self.shutdown_sender.subscribe();
-+        let swarm_clone = self.swarm.clone();
-+        handles.push(tokio::spawn(async move {
-+            Self::run_event_loop(swarm_clone, event_loop_receiver).await;
-+        }));
-+
-+        let chain_clone = self.chain.get().unwrap().clone();
-+        let workload_clone = self.workload.get().unwrap().clone();
-+        let swarm_clone_2 = self.swarm.clone();
-+        let is_running_clone = self.is_running.clone();
-+
-+        handles.push(tokio::spawn(async move {
-+            Self::run_block_production(
-+                chain_clone,
-+                workload_clone,
-+                swarm_clone_2,
-+                is_running_clone,
-+            )
-+            .await;
-+        }));
-+
-         Ok(())
-     }
--    
--    /// Stop the orchestration container
--    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        
--        println!("Orchestration container stopping...");
--        
--        // In a real implementation, we would:
--        // 1. Gracefully disconnect from network
--        // 2. Stop consensus mechanism
--        // 3. Save state
--        
--        println!("Orchestration container stopped successfully");
-+
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        if !self.is_running() {
-+            return Ok(());
-+        }
-+        log::info!("OrchestrationContainer stopping...");
-+        self.is_running.store(false, Ordering::SeqCst);
-         
-+        self.shutdown_sender.send(true).map_err(|e| {
-+            ValidatorError::Other(format!("Failed to send shutdown signal: {}", e))
-+        })?;
-+
-+        let mut handles = self.task_handles.lock().await;
-+        for handle in handles.drain(..) {
-+            handle.await.map_err(|e| ValidatorError::Other(format!("Task panicked during shutdown: {}", e)))?;
-+        }
-+
-         Ok(())
-     }
--    
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
--    }
--}
--```
-+}```
- 
- ####### File: validator/src/standard/workload.rs
--####*Size: 4.0K, Lines: 81, Type: ASCII text*
-+####*Size: 4.0K, Lines: 50, Type: ASCII text*
- 
- ```rust
--//! Implementation of workload container
-+// Path: crates/validator/src/standard/workload.rs
- 
--use std::path::Path;
--use std::error::Error;
--use std::sync::{Arc, Mutex};
-+use crate::traits::WorkloadLogic;
-+use depin_sdk_core::commitment::CommitmentScheme;
-+use depin_sdk_core::error::ValidatorError;
-+use depin_sdk_core::state::{StateManager, StateTree};
-+use depin_sdk_core::transaction::TransactionModel;
-+use depin_sdk_core::validator::WorkloadContainer;
- 
--/// Workload container for resource provisioning and execution
--pub struct WorkloadContainer {
--    /// Configuration path
--    config_path: String,
--    /// Running status
--    running: Arc<Mutex<bool>>,
--}
-+impl<ST> WorkloadLogic<ST> for WorkloadContainer<ST>
-+where
-+    // FIX: The bound must be StateManager (which implies StateTree) and Sized.
-+    ST: StateManager + Send + Sync,
-+{
-+    fn execute_transaction<CS, TM>(
-+        &self,
-+        tx: &TM::Transaction,
-+        model: &TM,
-+    ) -> impl std::future::Future<Output = Result<(), ValidatorError>> + Send
-+    where
-+        CS: CommitmentScheme<
-+            Commitment = <ST as StateTree>::Commitment,
-+            Proof = <ST as StateTree>::Proof,
-+        >,
-+        TM: TransactionModel<CommitmentScheme = CS> + Sync,
-+        TM::Transaction: Sync,
-+        // FIX: The bound `ST: StateManager` is now satisfied by the impl block's bounds.
-+        ST: StateManager,
-+    {
-+        async move {
-+            let state_tree_arc = self.state_tree();
-+            let mut state = state_tree_arc.lock().await;
-+
-+            let is_valid = model
-+                .validate(tx, &*state)
-+                .map_err(|e| ValidatorError::Other(e.to_string()))?;
-+            if !is_valid {
-+                return Err(ValidatorError::Other(
-+                    "Transaction validation failed".to_string(),
-+                ));
-+            }
- 
--impl WorkloadContainer {
--    /// Create a new workload container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
--        Self {
--            config_path: config_path.as_ref().to_string_lossy().to_string(),
--            running: Arc::new(Mutex::new(false)),
--        }
--    }
--    
--    /// Start the workload container
--    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        
--        println!("Workload container starting...");
--        
--        // In a real implementation, we would:
--        // 1. Initialize execution environment
--        // 2. Allocate resources
--        // 3. Start transaction processing
--        
--        println!("Workload container started successfully");
--        
--        Ok(())
--    }
--    
--    /// Stop the workload container
--    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        
--        println!("Workload container stopping...");
--        
--        // In a real implementation, we would:
--        // 1. Gracefully stop transaction processing
--        // 2. Release resources
--        // 3. Save state
--        
--        println!("Workload container stopped successfully");
--        
--        Ok(())
--    }
--    
--    /// Execute a transaction
--    pub fn execute_transaction(&self, tx_data: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
--        if !self.is_running() {
--            return Err("Workload container is not running".into());
-+            model
-+                .apply(tx, &mut *state)
-+                .map_err(|e| ValidatorError::Other(e.to_string()))?;
-+
-+            log::info!("Successfully executed transaction and updated state.");
-+            Ok(())
-         }
--        
--        // Simplified transaction execution for initial setup
--        println!("Executing transaction of {} bytes", tx_data.len());
--        
--        // In a real implementation, we would:
--        // 1. Parse the transaction
--        // 2. Verify it against the state
--        // 3. Apply it to the state
--        // 4. Return the result
--        
--        // Return a dummy result for now
--        Ok(vec![1, 2, 3, 4])
--    }
--    
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
-     }
-+}```
-+
-+###### Directory: validator/src/traits
-+
-+####### File: validator/src/traits/mod.rs
-+####*Size: 4.0K, Lines: 25, Type: ASCII text*
-+
-+```rust
-+// Path: crates/validator/src/traits/mod.rs
-+
-+use depin_sdk_core::commitment::CommitmentScheme;
-+use depin_sdk_core::error::ValidatorError;
-+use depin_sdk_core::state::{StateManager, StateTree};
-+use depin_sdk_core::transaction::TransactionModel;
-+use std::future::Future;
-+
-+/// Defines the logic for a workload execution container.
-+pub trait WorkloadLogic<ST: StateTree + ?Sized> {
-+    /// Executes a single transaction, validating it and applying it to the state tree.
-+    fn execute_transaction<CS, TM>(
-+        &self,
-+        tx: &TM::Transaction,
-+        model: &TM,
-+    ) -> impl Future<Output = Result<(), ValidatorError>> + Send
-+    where
-+        CS: CommitmentScheme<
-+            Commitment = <ST as StateTree>::Commitment,
-+            Proof = <ST as StateTree>::Proof,
-+        >,
-+        // FIX: Add Sync bounds to ensure thread safety for captured references.
-+        TM: TransactionModel<CommitmentScheme = CS> + Sync,
-+        TM::Transaction: Sync,
-+        ST: StateManager;
-+}```
-+
-+###### File: validator/src/config.rs
-+###*Size: 4.0K, Lines: 49, Type: ASCII text*
-+
-+```rust
-+//! Configuration structures for validator containers.
-+
-+use serde::Deserialize;
-+
-+/// Configuration for the Guardian container (`guardian.toml`).
-+#[derive(Debug, Deserialize)]
-+pub struct GuardianConfig {
-+    pub signature_policy: AttestationSignaturePolicy,
- }
--```
-+
-+#[derive(Debug, Deserialize)]
-+#[serde(rename_all = "PascalCase")]
-+pub enum AttestationSignaturePolicy {
-+    FollowChain,
-+    Fixed,
-+}
-+
-+/// Configuration for the Orchestration container (`orchestration.toml`).
-+#[derive(Debug, Deserialize)]
-+pub struct OrchestrationConfig {
-+    pub consensus_type: ConsensusType,
-+}
-+
-+#[derive(Debug, Deserialize)]
-+#[serde(rename_all = "PascalCase")]
-+pub enum ConsensusType {
-+    ProofOfStake,
-+    ProofOfWork,
-+    ProofOfAuthority,
-+}
-+
-+/// Configuration for the Workload container (`workload.toml`).
-+#[derive(Debug, Deserialize)]
-+pub struct WorkloadConfig {
-+    pub enabled_vms: Vec<String>,
-+}
-+
-+/// Configuration for the Interface container (`interface.toml`).
-+#[derive(Debug, Deserialize)]
-+pub struct InterfaceConfig {
-+    pub listen_address: String,
-+    pub max_connections: u32,
-+}
-+
-+/// Configuration for the API container (`api.toml`).
-+#[derive(Debug, Deserialize)]
-+pub struct ApiConfig {
-+    pub listen_address: String,
-+    pub enabled_endpoints: Vec<String>,
-+}```
- 
- ###### File: validator/src/lib.rs
--###*Size: 4.0K, Lines: 10, Type: ASCII text*
-+###*Size: 4.0K, Lines: 12, Type: ASCII text*
- 
- ```rust
- //! # DePIN SDK Validator
- //!
- //! Validator implementation with container architecture for the DePIN SDK.
- 
-+pub mod config;
- pub mod common;
- pub mod standard;
- pub mod hybrid;
-+// NEW: Public traits for this crate are defined here.
-+pub mod traits;
- 
--use std::error::Error;
--use depin_sdk_core::validator::ValidatorModel;
--```
-+// Re-export the new public trait.
-+pub use traits::WorkloadLogic;```
- 
- ##### File: validator/Cargo.toml
--##*Size: 4.0K, Lines: 24, Type: ASCII text*
-+##*Size: 4.0K, Lines: 44, Type: ASCII text*
- 
- ```toml
-+# Path: crates/validator/Cargo.toml
-+
- [package]
- name = "depin-sdk-validator"
- version = "0.1.0"
- edition = "2021"
--description = "Validator implementation with container architecture for the DePIN SDK"
-+description = "Validator container implementations for the DePIN SDK"
- license = "MIT OR Apache-2.0"
- 
- [dependencies]
- depin-sdk-core = { path = "../core" }
- log = { workspace = true }
--serde = { workspace = true }
--thiserror = { workspace = true }
--bytes = { workspace = true }
- anyhow = { workspace = true }
--tokio = { version = "1.28", features = ["full"] }
--toml = "0.7"
-+serde = { workspace = true, features = ["derive"] }
-+serde_json = { workspace = true }
-+# FIX: The `sync` feature is required for tokio::sync::watch
-+tokio = { workspace = true, features = ["full", "sync"] }
-+libp2p = { workspace = true }
-+futures = { workspace = true }
-+async-trait = { workspace = true }
-+toml = { workspace = true }
-+clap = { workspace = true, features = ["derive"], optional = true }
-+env_logger = { workspace = true, optional = true }
-+depin-sdk-state-trees = { path = "../state_trees", optional = true }
-+depin-sdk-commitment-schemes = { path = "../commitment_schemes", optional = true }
-+
-+[features]
-+default = []
-+validator-bins = [
-+    "dep:clap",
-+    "dep:env_logger",
-+    "dep:depin-sdk-state-trees",
-+    "dep:depin-sdk-commitment-schemes",
-+]
- 
- [[bin]]
--name = "depin-sdk-validator"
-+name = "validator"
- path = "src/bin/validator.rs"
-+required-features = ["validator-bins"]
- 
- [[bin]]
--name = "depin-sdk-validator-hybrid"
-+name = "validator_hybrid"
- path = "src/bin/validator_hybrid.rs"
-+required-features = ["validator-bins"]
- ```
- 
-diff --git a/crates/chain/Cargo.toml b/crates/chain/Cargo.toml
-index 7963b22..273b38c 100644
---- a/crates/chain/Cargo.toml
-+++ b/crates/chain/Cargo.toml
-@@ -1,3 +1,5 @@
-+# Path: crates/chain/Cargo.toml
-+
- [package]
- name = "depin-sdk-chain"
- version = "0.1.0"
-@@ -17,32 +19,19 @@ serde = { workspace = true, features = ["derive"] }
- serde_json = { workspace = true }
- thiserror = { workspace = true }
- anyhow = { workspace = true }
--
--# Dependencies added for the mvsc binary, made optional
--depin-sdk-crypto = { path = "../crypto", optional = true }
- tokio = { workspace = true, features = ["full"], optional = true }
- futures = { workspace = true, optional = true }
--hex = { version = "0.4", optional = true }
--clap = { version = "4.3", features = ["derive"], optional = true }
--env_logger = { version = "0.10", optional = true }
--libp2p = { version = "0.52", features = [
--    "tokio",
--    "gossipsub",
--    "mdns",
--    "macros",
--    "tcp",
--    "noise",
--    "yamux",
--], optional = true }
--
-+hex = { workspace = true, optional = true }
-+clap = { workspace = true, features = ["derive"], optional = true }
-+env_logger = { workspace = true, optional = true }
-+libp2p = { workspace = true, optional = true }
-+async-trait = { workspace = true }
- 
- [features]
- default = []
- tendermint = []
- custom-consensus = []
--# Feature to enable building the binary and its dependencies
- mvsc-bin = [
--    "dep:depin-sdk-crypto",
-     "dep:tokio",
-     "dep:futures",
-     "dep:hex",
-diff --git a/crates/chain/src/app/mod.rs b/crates/chain/src/app/mod.rs
-index 88a35c0..b778c64 100644
---- a/crates/chain/src/app/mod.rs
-+++ b/crates/chain/src/app/mod.rs
-@@ -1,585 +1,226 @@
-+// Path: crates/chain/src/app/mod.rs
-+
-+//! The private implementation for the `SovereignChain` trait.
-+
-+use crate::upgrade_manager::ModuleUpgradeManager;
-+use async_trait::async_trait;
-+use depin_sdk_core::app::{Block, BlockHeader, ChainError, ChainStatus, SovereignAppChain};
-+use depin_sdk_core::chain::SovereignChain;
- use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::CoreError;
--use depin_sdk_core::services::{ServiceType, UpgradableService};
--use depin_sdk_core::state::{StateManager, StateTree};
-+// REMOVED: Unused import `StateError`
-+use depin_sdk_core::services::UpgradableService;
-+// REMOVED: Unused import `StateTree`
-+use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use depin_sdk_core::validator::ValidatorModel;
--use crate::upgrade_manager::ModuleUpgradeManager;
--use depin_sdk_state_trees::file::FileStateTree;
--use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
--
-+use depin_sdk_core::validator::WorkloadContainer;
-+use depin_sdk_validator::traits::WorkloadLogic;
-+use std::fmt::Debug;
- use std::sync::Arc;
--use std::time::{Duration, SystemTime, UNIX_EPOCH};
--
--/// Custom error type for chain operations.
--#[derive(Debug, thiserror::Error)]
--pub enum ChainError {
--    #[error("Validator operation failed: {0}")]
--    Validator(String),
--    #[error("Service operation failed: {0}")]
--    Service(String),
--    #[error("State operation failed: {0}")]
--    State(#[from] depin_sdk_core::error::StateError),
--    #[error("Transaction processing failed: {0}")]
--    Transaction(String),
--    #[error("Block processing failed: {0}")]
--    Block(String),
--    #[error("Module upgrade failed: {0}")]
--    Upgrade(String),
--}
--
--/// Block header containing metadata
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct BlockHeader {
--    /// Block height
--    pub height: u64,
--    /// Previous block hash
--    pub prev_hash: Vec<u8>,
--    /// State root commitment
--    pub state_root: Vec<u8>,
--    /// Transactions root (e.g., Merkle root of transactions)
--    pub transactions_root: Vec<u8>,
--    /// Block timestamp (Unix timestamp in seconds)
--    pub timestamp: u64,
--}
--
--/// Block structure containing transactions
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct Block<T> {
--    /// Block header
--    pub header: BlockHeader,
--    /// Transactions included in this block
--    pub transactions: Vec<T>,
--}
--
--/// Chain status information
--#[derive(Debug, Clone)]
--pub struct ChainStatus {
--    /// Current block height
--    pub height: u64,
--    /// Latest block timestamp
--    pub latest_timestamp: u64,
--    /// Number of transactions processed
--    pub total_transactions: u64,
--    /// Chain running status
--    pub is_running: bool,
--}
--
--/// Implementation of sovereign app chain with runtime-swappable modules
--pub struct SovereignAppChain<CS, ST, TM, VM>
--where
--    CS: CommitmentScheme,
--    // Specify that ST implements both StateTree and StateManager with the specific commitment types
--    ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
--        + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>,
--    TM: TransactionModel,
--    VM: ValidatorModel,
--    // Ensure the transaction model's commitment scheme uses the same types
--    TM::CommitmentScheme: CommitmentScheme<Commitment = CS::Commitment, Proof = CS::Proof>,
--{
--    /// Commitment scheme
--    commitment_scheme: CS,
--    /// State tree
--    state_tree: ST,
--    /// Transaction model
--    transaction_model: TM,
--    /// Validator model
--    validator_model: VM,
--    /// Module upgrade manager for runtime-swappable services
-+use std::time::{SystemTime, UNIX_EPOCH};
-+
-+// Define a well-known key for storing the chain status in the state tree.
-+const STATUS_KEY: &[u8] = b"chain::status";
-+
-+/// A container struct that holds the chain's data (`SovereignAppChain`) and its
-+/// associated logic managers (`ModuleUpgradeManager`).
-+/// This struct implements the `SovereignChain` trait.
-+#[derive(Debug)]
-+pub struct ChainLogic<CS, TM: TransactionModel> {
-+    app_chain: SovereignAppChain<CS, TM>,
-+    #[allow(dead_code)]
-     service_manager: ModuleUpgradeManager,
--    /// Chain ID
--    chain_id: String,
--    /// Current status
--    status: ChainStatus,
--    /// Latest blocks (limited cache)
--    recent_blocks: Vec<Block<TM::Transaction>>,
--    /// Maximum blocks to keep in memory
--    max_recent_blocks: usize,
- }
- 
--impl<CS, ST, TM, VM> SovereignAppChain<CS, ST, TM, VM>
-+impl<CS, TM> ChainLogic<CS, TM>
- where
-     CS: CommitmentScheme,
--    ST: StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
--        + StateManager<Commitment = CS::Commitment, Proof = CS::Proof>,
--    TM: TransactionModel,
--    VM: ValidatorModel,
--    TM::CommitmentScheme: CommitmentScheme<Commitment = CS::Commitment, Proof = CS::Proof>,
-+    TM: TransactionModel<CommitmentScheme = CS>,
- {
--    /// Create a new sovereign app chain with runtime-swappable services
-+    /// The `new` constructor is an inherent method on the logic struct,
-+    /// which allows the `SovereignChain` trait to be object-safe.
-     pub fn new(
-         commitment_scheme: CS,
--        state_tree: ST,
-         transaction_model: TM,
--        validator_model: VM,
-         chain_id: &str,
-         initial_services: Vec<Arc<dyn UpgradableService>>,
-     ) -> Self {
-+        // This now creates a default/genesis status, which will be overwritten
-+        // by load_or_initialize_status if state exists.
-         let status = ChainStatus {
-             height: 0,
-             latest_timestamp: SystemTime::now()
-                 .duration_since(UNIX_EPOCH)
--                .unwrap_or(Duration::from_secs(0))
-+                .unwrap()
-                 .as_secs(),
-             total_transactions: 0,
-             is_running: false,
-         };
- 
--        // Initialize the module upgrade manager with initial services
-         let mut service_manager = ModuleUpgradeManager::new();
-         for service in initial_services {
-             service_manager.register_service(service);
-         }
- 
--        Self {
-+        let app_chain = SovereignAppChain {
-             commitment_scheme,
--            state_tree,
-             transaction_model,
--            validator_model,
--            service_manager,
-             chain_id: chain_id.to_string(),
-             status,
-             recent_blocks: Vec::new(),
--            max_recent_blocks: 100, // Default to storing last 100 blocks
--        }
--    }
--
--    /// Get the chain ID
--    pub fn chain_id(&self) -> &str {
--        &self.chain_id
--    }
--
--    /// Get the current chain status
--    pub fn status(&self) -> &ChainStatus {
--        &self.status
--    }
--
--    /// Get a reference to the service manager
--    pub fn service_manager(&self) -> &ModuleUpgradeManager {
--        &self.service_manager
--    }
--
--    /// Get a mutable reference to the service manager
--    pub fn service_manager_mut(&mut self) -> &mut ModuleUpgradeManager {
--        &mut self.service_manager
--    }
--
--    //
--    // Service Interaction Methods
--    //
--
--    /// Get a service by type
--    pub fn get_service(&self, service_type: &ServiceType) -> Option<Arc<dyn UpgradableService>> {
--        self.service_manager.get_service(service_type)
--    }
--
--    /// Submit a governance proposal (if governance service is available)
--    pub fn submit_governance_proposal(&self, proposal_data: &[u8]) -> Result<(), CoreError> {
--        let governance = self
--            .service_manager
--            .get_service(&ServiceType::Governance)
--            .ok_or(CoreError::ServiceNotFound("Governance".to_string()))?;
--
--        // Call the governance service's proposal submission method
--        // Note: This assumes a GovernanceService trait with submit_proposal method
--        // governance.submit_proposal(proposal_data)
--
--        // For now, return Ok as we don't have the actual trait definition
--        Ok(())
--    }
--
--    /// Query external data (if external data service is available)
--    pub fn query_external_data(&self, query: &str) -> Result<Vec<u8>, CoreError> {
--        let external_data = self
--            .service_manager
--            .get_service(&ServiceType::ExternalData)
--            .ok_or(CoreError::ServiceNotFound("ExternalData".to_string()))?;
--
--        // Call the external data service's query method
--        // external_data.fetch_data(query)
--
--        // For now, return placeholder
--        Ok(vec![])
--    }
--
--    /// Execute semantic interpretation (if semantic service is available)
--    pub fn interpret_semantic(&self, input: &str) -> Result<String, CoreError> {
--        let semantic = self
--            .service_manager
--            .get_service(&ServiceType::Semantic)
--            .ok_or(CoreError::ServiceNotFound("Semantic".to_string()))?;
--
--        // Call the semantic service's interpretation method
--        // semantic.interpret(input)
--
--        // For now, return placeholder
--        Ok("Interpretation not implemented".to_string())
--    }
--
--    //
--    // 1. State Management Methods
--    //
--
--    /// Query a value from the state tree
--    pub fn query_state(&self, key: &[u8]) -> Option<Vec<u8>> {
--        // Use expect to handle the Result and extract the Option
--        <ST as StateTree>::get(&self.state_tree, key).expect("State access error")
--    }
--
--    /// Get the current state root commitment
--    pub fn get_state_commitment(&self) -> CS::Commitment {
--        <ST as StateTree>::root_commitment(&self.state_tree)
--    }
--
--    /// Create a proof for a key
--    pub fn create_state_proof(&self, key: &[u8]) -> Option<CS::Proof> {
--        <ST as StateTree>::create_proof(&self.state_tree, key)
--    }
--
--    /// Verify a state proof
--    pub fn verify_state_proof(
--        &self,
--        commitment: &CS::Commitment,
--        proof: &CS::Proof,
--        key: &[u8],
--        value: &[u8],
--    ) -> bool {
--        <ST as StateTree>::verify_proof(&self.state_tree, commitment, proof, key, value)
--    }
--
--    /// Update state directly (administrative function)
--    pub fn update_state(&mut self, key: &[u8], value: &[u8]) -> Result<(), ChainError> {
--        <ST as StateTree>::insert(&mut self.state_tree, key, value).map_err(ChainError::from)
--    }
-+            max_recent_blocks: 100,
-+        };
- 
--    /// Delete a key from state (administrative function)
--    pub fn delete_state(&mut self, key: &[u8]) -> Result<(), ChainError> {
--        <ST as StateTree>::delete(&mut self.state_tree, key).map_err(ChainError::from)
-+        Self {
-+            app_chain,
-+            service_manager,
-+        }
-     }
- 
--    //
--    // 2. Transaction Processing Methods
--    //
--
--    /// Process a transaction
--    pub fn process_transaction(&mut self, tx: &TM::Transaction) -> Result<(), ChainError> {
--        // Validate the transaction against current state
--        // Pass the state_tree itself, not just the commitment
--        match self.transaction_model.validate(tx, &self.state_tree) {
--            Ok(valid) => {
--                if !valid {
--                    return Err(ChainError::Transaction("Transaction validation failed".to_string()));
--                }
-+    /// [NEW METHOD] Loads chain status from the state manager, or initializes it if not found.
-+    pub async fn load_or_initialize_status<ST>(
-+        &mut self,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError>
-+    where
-+        ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static,
-+    {
-+        // FIX: Create a longer-lived binding for the Arc<Mutex> to solve the lifetime error.
-+        let state_tree = workload.state_tree();
-+        let mut state = state_tree.lock().await;
-+
-+        match state.get(STATUS_KEY) {
-+            Ok(Some(status_bytes)) => {
-+                let status: ChainStatus = serde_json::from_slice(&status_bytes)
-+                    .map_err(|e| ChainError::Transaction(format!("Failed to deserialize status: {}", e)))?;
-+                log::info!("Loaded chain status: height {}", status.height);
-+                self.app_chain.status = status;
-             }
--            Err(e) => return Err(ChainError::Transaction(format!("Validation error: {}", e))),
--        }
--
--        // Apply the transaction to state - map error to String
--        match self.transaction_model.apply(tx, &mut self.state_tree) {
--            Ok(_) => {
--                // Update statistics on success
--                self.status.total_transactions += 1;
--                Ok(())
-+            Ok(None) => {
-+                log::info!("No existing chain status found. Initializing and saving genesis status.");
-+                let status_bytes = serde_json::to_vec(&self.app_chain.status).unwrap();
-+                state
-+                    .insert(STATUS_KEY, &status_bytes)
-+                    .map_err(|e| ChainError::Transaction(e.to_string()))?;
-             }
--            Err(e) => Err(ChainError::Transaction(format!("Transaction application failed: {}", e))),
-+            Err(e) => return Err(ChainError::Transaction(e.to_string())),
-         }
-+        Ok(())
-     }
-+}
- 
--    /// Process a batch of transactions
--    pub fn process_transactions(&mut self, txs: &[TM::Transaction]) -> Result<Vec<String>, ChainError> {
--        let mut results = Vec::with_capacity(txs.len());
--
--        for tx in txs {
--            match self.process_transaction(tx) {
--                Ok(()) => results.push("Success".to_string()),
--                Err(e) => results.push(e.to_string()),
--            }
--        }
--
--        Ok(results)
-+/// Implements the `dyn`-safe `SovereignChain` trait for the `ChainLogic` struct.
-+#[async_trait]
-+impl<CS, TM, ST> SovereignChain<CS, TM, ST> for ChainLogic<CS, TM>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static + Debug,
-+    TM::Transaction: Clone + Send + Sync + Debug,
-+    CS::Commitment: Send + Sync + Debug,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
-+{
-+    fn status(&self) -> &ChainStatus {
-+        &self.app_chain.status
-     }
- 
--    //
--    // 3. Block Processing Methods
--    //
--
--    /// Process a block
--    pub fn process_block(&mut self, mut block: Block<TM::Transaction>) -> Result<(), ChainError>
--    where
--        CS: Clone,
--        CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--    {
--        // Ensure block is built on current chain state
--        if block.header.height != self.status.height + 1 {
--            return Err(ChainError::Block(format!(
--                "Invalid block height: expected {}, got {}",
--                self.status.height + 1,
--                block.header.height
--            )));
--        }
-+    fn transaction_model(&self) -> &TM {
-+        &self.app_chain.transaction_model
-+    }
- 
--        // Verify block timestamp is reasonable
--        let now = SystemTime::now()
--            .duration_since(UNIX_EPOCH)
--            .unwrap_or(Duration::from_secs(0))
--            .as_secs();
-+    /// Processes a transaction by delegating execution to the WorkloadContainer.
-+    async fn process_transaction(
-+        &mut self,
-+        tx: &TM::Transaction,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError> {
-+        workload
-+            .execute_transaction(
-+                tx,
-+                <Self as SovereignChain<CS, TM, ST>>::transaction_model(self),
-+            )
-+            .await
-+            .map_err(|e| ChainError::Transaction(e.to_string()))?;
- 
--        if block.header.timestamp > now + 60 {
--            // Allow 1 minute clock drift
--            return Err(ChainError::Block("Block timestamp is in the future".to_string()));
--        }
-+        self.app_chain.status.total_transactions += 1;
-+        Ok(())
-+    }
- 
--        // Validate block using validator_model
--        if !self.validator_model.is_running() {
--            self.validator_model
--                .start()
--                .map_err(|e| ChainError::Validator(format!("Failed to start validator: {}", e)))?;
-+    /// Processes a full block by iterating through its transactions and delegating
-+    /// each one to the WorkloadContainer for execution.
-+    async fn process_block(
-+        &mut self,
-+        mut block: Block<TM::Transaction>,
-+        workload: &WorkloadContainer<ST>,
-+    ) -> Result<(), ChainError> {
-+        if block.header.height != self.app_chain.status.height + 1 {
-+            return Err(ChainError::Block("Invalid block height".to_string()));
-         }
- 
--        // Process all transactions
--        let mut tx_results = Vec::new();
-         for tx in &block.transactions {
--            match self.process_transaction(tx) {
--                Ok(()) => tx_results.push(true),
--                Err(e) => {
--                    tx_results.push(false);
--                    return Err(ChainError::Transaction(format!("Transaction processing failed: {}", e)));
--                }
--            }
-+            self.process_transaction(tx, workload).await?;
-         }
- 
--        // Update state root in block header to match current state
--        let current_state_root = <ST as StateTree>::root_commitment(&self.state_tree);
--        block.header.state_root = current_state_root.as_ref().to_vec();
-+        // After all transactions are processed, get the final state root from the workload container.
-+        let state_root =
-+            workload.state_tree().lock().await.root_commitment();
-+        block.header.state_root = state_root.as_ref().to_vec();
- 
--        // Check for and apply any module upgrades scheduled for this block height
--        // This happens after transaction processing but before finalizing the block
--        match self
--            .service_manager
--            .apply_upgrades_at_height(block.header.height)
--        {
--            Ok(upgrades_applied) => {
--                if upgrades_applied > 0 {
--                    println!(
--                        "Applied {} module upgrades at height {}",
--                        upgrades_applied, block.header.height
--                    );
--                }
--            }
--            Err(e) => {
--                return Err(ChainError::Upgrade(format!("Failed to apply module upgrades: {}", e)));
--            }
--        }
--
--        // Update chain status
--        self.status.height = block.header.height;
--        self.status.latest_timestamp = block.header.timestamp;
--
--        // Add block to recent blocks cache
--        self.recent_blocks.push(block);
--        if self.recent_blocks.len() > self.max_recent_blocks {
--            self.recent_blocks.remove(0); // Remove oldest block
--        }
--
--        // Periodically save state if the state tree supports it (e.g., FileStateTree)
--        if self.status.height % 10 == 0 {
--            // This uses `as_any()` and `downcast_ref` to check if the state tree is a `FileStateTree`
--            // without breaking the generic `ST` constraint. This is a common pattern for
--            // accessing concrete type features from generic code.
--            if let Some(persistable_tree) = self.state_tree.as_any().downcast_ref::<FileStateTree<CS>>() {
--                // Now valid because of the `where` clause on this method
--                if let Err(e) = persistable_tree.save() {
--                    eprintln!("[Warning] Periodic state save failed at height {}: {}", self.status.height, e);
--                } else {
--                    println!("State periodically saved at height {}", self.status.height);
--                }
--            }
-+        self.app_chain.status.height = block.header.height;
-+        self.app_chain.status.latest_timestamp = block.header.timestamp;
-+        self.app_chain.recent_blocks.push(block);
-+        if self.app_chain.recent_blocks.len() > self.app_chain.max_recent_blocks {
-+            self.app_chain.recent_blocks.remove(0);
-         }
- 
-+        // [MODIFIED] Persist the updated status to the state tree.
-+        let status_bytes = serde_json::to_vec(&self.app_chain.status)
-+            .map_err(|e| ChainError::Transaction(format!("Failed to serialize status: {}", e)))?;
-+        workload
-+            .state_tree()
-+            .lock()
-+            .await
-+            .insert(STATUS_KEY, &status_bytes)
-+            .map_err(|e| ChainError::Transaction(e.to_string()))?;
- 
-         Ok(())
-     }
- 
--    /// Create a new block (for validators/block producers)
--    pub fn create_block(&self, transactions: Vec<TM::Transaction>) -> Block<TM::Transaction> {
--        let prev_hash = if self.recent_blocks.is_empty() {
--            vec![0; 32] // Genesis block
--        } else {
--            // In a real implementation, this would be the hash of the latest block
--            // For simplicity, we'll use the serialized state root as the prev hash
--            <ST as StateTree>::root_commitment(&self.state_tree)
--                .as_ref()
--                .to_vec()
--        };
-+    /// Creates a new block template to be filled by a block producer.
-+    fn create_block(
-+        &self,
-+        transactions: Vec<TM::Transaction>,
-+        _workload: &WorkloadContainer<ST>,
-+    ) -> Block<TM::Transaction> {
-+        let prev_hash = self
-+            .app_chain
-+            .recent_blocks
-+            .last()
-+            .map_or(vec![0; 32], |b| b.header.state_root.clone());
-+
-+        // FIX: The state_root here is just a placeholder. The real root is calculated
-+        // and overwritten in `process_block` after all transactions are executed.
-+        // We remove the illegal `block_on` call and just use the previous hash as the initial value.
-+        let state_root = prev_hash.clone();
- 
-         let header = BlockHeader {
--            height: self.status.height + 1,
-+            height: self.app_chain.status.height + 1,
-             prev_hash,
--            state_root: <ST as StateTree>::root_commitment(&self.state_tree)
--                .as_ref()
--                .to_vec(),
--            transactions_root: vec![0; 32], // Simplified - would compute actual Merkle root
-+            state_root,
-+            transactions_root: vec![0; 32],
-             timestamp: SystemTime::now()
-                 .duration_since(UNIX_EPOCH)
--                .unwrap_or(Duration::from_secs(0))
-+                .unwrap()
-                 .as_secs(),
-         };
--
-         Block {
-             header,
-             transactions,
-         }
-     }
- 
--    /// Get a recent block by height
--    pub fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>> {
--        self.recent_blocks
-+    fn get_block(&self, height: u64) -> Option<&Block<TM::Transaction>> {
-+        self.app_chain
-+            .recent_blocks
-             .iter()
--            .find(|block| block.header.height == height)
--    }
--
--    /// Get the latest block
--    pub fn get_latest_block(&self) -> Option<&Block<TM::Transaction>> {
--        self.recent_blocks.last()
--    }
--
--    //
--    // 4. Enhanced Start/Stop Methods
--    //
--
--    /// Start the chain with proper initialization
--    pub fn start(&mut self) -> Result<(), ChainError> {
--        println!("Starting sovereign app chain: {}", self.chain_id);
--
--        // Initialize validator
--        self.validator_model
--            .start()
--            .map_err(|e| ChainError::Validator(format!("Failed to start validator: {}", e)))?;
--
--        // Start all registered services
--        self.service_manager
--            .start_all_services()
--            .map_err(|e| ChainError::Service(format!("Failed to start services: {}", e)))?;
--
--        // Initialize state (in a real implementation, would load from persistent storage)
--        // For now, we'll just use the existing state
--
--        // Update status
--        self.status.is_running = true;
--        self.status.latest_timestamp = SystemTime::now()
--            .duration_since(UNIX_EPOCH)
--            .unwrap_or(Duration::from_secs(0))
--            .as_secs();
--
--        println!(
--            "Sovereign app chain started successfully: {}",
--            self.chain_id
--        );
--
--        Ok(())
--    }
--
--    /// Stop the chain
--    pub fn stop(&mut self) -> Result<(), ChainError> {
--        println!("Stopping sovereign app chain: {}", self.chain_id);
--
--        // Stop all services
--        self.service_manager
--            .stop_all_services()
--            .map_err(|e| ChainError::Service(format!("Failed to stop services: {}", e)))?;
--
--        // Stop the validator
--        self.validator_model
--            .stop()
--            .map_err(|e| ChainError::Validator(format!("Failed to stop validator: {}", e)))?;
--
--        // In a real implementation, we would:
--        // 1. Persist state to storage
--        // 2. Close connections
--        // 3. Shutdown properly
--
--        // Update status
--        self.status.is_running = false;
--
--        println!(
--            "Sovereign app chain stopped successfully: {}",
--            self.chain_id
--        );
--
--        Ok(())
--    }
--
--    /// Reset the chain (for testing purposes)
--    pub fn reset(&mut self) -> Result<(), ChainError> {
--        // Stop the chain if running
--        if self.status.is_running {
--            self.stop()?;
--        }
--
--        // Reset service manager
--        self.service_manager.reset()
--            .map_err(|e| ChainError::Service(format!("Failed to reset service manager: {}", e)))?;
--
--        // Reset state (implementation would depend on how ST can be reset)
--        // For demonstration purposes, assuming ST has no reset method
--
--        // Reset chain status
--        self.status = ChainStatus {
--            height: 0,
--            latest_timestamp: SystemTime::now()
--                .duration_since(UNIX_EPOCH)
--                .unwrap_or(Duration::from_secs(0))
--                .as_secs(),
--            total_transactions: 0,
--            is_running: false,
--        };
--
--        // Clear recent blocks
--        self.recent_blocks.clear();
--
--        Ok(())
-+            .find(|b| b.header.height == height)
-     }
--
--    /// Configure the maximum number of recent blocks to keep in memory
--    pub fn set_max_recent_blocks(&mut self, count: usize) {
--        self.max_recent_blocks = count;
--
--        // Trim if needed
--        while self.recent_blocks.len() > self.max_recent_blocks {
--            self.recent_blocks.remove(0);
--        }
--    }
--
--    /// Get the commitment scheme
--    pub fn commitment_scheme(&self) -> &CS {
--        &self.commitment_scheme
--    }
--
--    /// Get the state tree
--    pub fn state_tree(&self) -> &ST {
--        &self.state_tree
--    }
--
--    /// Get the transaction model
--    pub fn transaction_model(&self) -> &TM {
--        &self.transaction_model
--    }
--
--    /// Get the validator model
--    pub fn validator_model(&self) -> &VM {
--        &self.validator_model
--    }
--
--    /// Check service health
--    pub fn check_service_health(&self) -> Vec<(ServiceType, bool)> {
--        self.service_manager.check_all_health()
--    }
--
--    /// Get upgrade history for a service
--    pub fn get_service_history(&self, service_type: &ServiceType) -> Vec<u64> {
--        self.service_manager.get_upgrade_history(service_type)
--    }
--}
--
--#[cfg(test)]
--mod tests;
-\ No newline at end of file
-+}
-\ No newline at end of file
-diff --git a/crates/chain/src/app/tests/mod.rs b/crates/chain/src/app/tests/mod.rs
-deleted file mode 100644
-index 112ea78..0000000
---- a/crates/chain/src/app/tests/mod.rs
-+++ /dev/null
-@@ -1,354 +0,0 @@
--use crate::app::*;
--use depin_sdk_commitment_schemes::merkle::MerkleCommitmentScheme;
--use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::{StateError, TransactionError};
--use depin_sdk_core::services::{ServiceType, UpgradableService};
--use depin_sdk_core::state::{StateManager, StateTree};
--use depin_sdk_core::transaction::TransactionModel;
--use depin_sdk_core::validator::{ValidatorModel, ValidatorType};
--use std::sync::Arc;
--use std::collections::HashMap;
--
--// Mock state tree implementation for testing
--struct MockStateTree {
--    data: HashMap<Vec<u8>, Vec<u8>>,
--    commitment_scheme: MerkleCommitmentScheme,
--}
--
--impl MockStateTree {
--    fn new(commitment_scheme: MerkleCommitmentScheme) -> Self {
--        Self {
--            data: HashMap::new(),
--            commitment_scheme,
--        }
--    }
--}
--
--impl StateTree for MockStateTree {
--    type Commitment = <MerkleCommitmentScheme as CommitmentScheme>::Commitment;
--    type Proof = <MerkleCommitmentScheme as CommitmentScheme>::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        Ok(self.data.get(key).cloned())
--    }
--
--    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        self.data.insert(key.to_vec(), value.to_vec());
--        Ok(())
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        self.data.remove(key);
--        Ok(())
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        // Simple implementation for testing
--        let values: Vec<Option<Vec<u8>>> = self.data.values()
--            .map(|v| Some(v.clone()))
--            .collect();
--        self.commitment_scheme.commit(&values)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        None // Simplified for testing
--    }
--
--    fn verify_proof(
--        &self,
--        _commitment: &Self::Commitment,
--        _proof: &Self::Proof,
--        _key: &[u8],
--        _value: &[u8],
--    ) -> bool {
--        true // Simplified for testing
--    }
--}
--
--impl StateManager for MockStateTree {
--    type Commitment = <MerkleCommitmentScheme as CommitmentScheme>::Commitment;
--    type Proof = <MerkleCommitmentScheme as CommitmentScheme>::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        <Self as StateTree>::get(self, key)
--    }
--
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::insert(self, key, value)
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::delete(self, key)
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        <Self as StateTree>::root_commitment(self)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        <Self as StateTree>::create_proof(self, key)
--    }
--
--    fn verify_proof(
--        &self,
--        commitment: &Self::Commitment,
--        proof: &Self::Proof,
--        key: &[u8],
--        value: &[u8],
--    ) -> bool {
--        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
--    }
--}
--
--// Mock transaction model for testing
--struct MockTransactionModel {
--    commitment_scheme: MerkleCommitmentScheme,
--}
--
--impl MockTransactionModel {
--    fn new(commitment_scheme: MerkleCommitmentScheme) -> Self {
--        Self { commitment_scheme }
--    }
--}
--
--#[derive(Clone)]
--struct MockTransaction {
--    id: Vec<u8>,
--}
--
--struct MockProof;
--
--impl TransactionModel for MockTransactionModel {
--    type Transaction = MockTransaction;
--    type Proof = MockProof;
--    type CommitmentScheme = MerkleCommitmentScheme;
--
--    fn validate<S>(&self, _tx: &Self::Transaction, _state: &S) -> Result<bool, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(true) // Always valid for testing
--    }
--
--    fn apply<S>(&self, _tx: &Self::Transaction, _state: &mut S) -> Result<(), TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(()) // No-op for testing
--    }
--
--    fn generate_proof<S>(&self, _tx: &Self::Transaction, _state: &S) -> Result<Self::Proof, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(MockProof)
--    }
--
--    fn verify_proof<S>(&self, _proof: &Self::Proof, _state: &S) -> Result<bool, TransactionError>
--    where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized
--    {
--        Ok(true)
--    }
--
--    fn serialize_transaction(&self, _tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        Ok(vec![])
--    }
--
--    fn deserialize_transaction(&self, _data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        Ok(MockTransaction { id: vec![] })
--    }
--}
--
--// Mock validator model for testing
--struct MockValidatorModel {
--    running: std::cell::RefCell<bool>,
--}
--
--impl MockValidatorModel {
--    fn new() -> Self {
--        Self {
--            running: std::cell::RefCell::new(false),
--        }
--    }
--}
--
--impl ValidatorModel for MockValidatorModel {
--    fn start(&self) -> Result<(), String> {
--        *self.running.borrow_mut() = true;
--        Ok(())
--    }
--
--    fn stop(&self) -> Result<(), String> {
--        *self.running.borrow_mut() = false;
--        Ok(())
--    }
--
--    fn is_running(&self) -> bool {
--        *self.running.borrow()
--    }
--
--    fn validator_type(&self) -> ValidatorType {
--        ValidatorType::Standard
--    }
--}
--
--// Helper function to create a test chain
--fn create_test_chain() -> SovereignAppChain<
--    MerkleCommitmentScheme,
--    MockStateTree,
--    MockTransactionModel,
--    MockValidatorModel,
--> {
--    let commitment_scheme = MerkleCommitmentScheme;
--    let state_tree = MockStateTree::new(commitment_scheme.clone());
--    let transaction_model = MockTransactionModel::new(commitment_scheme.clone());
--    let validator_model = MockValidatorModel::new();
--
--    SovereignAppChain::new(
--        commitment_scheme,
--        state_tree,
--        transaction_model,
--        validator_model,
--        "test-chain",
--        vec![], // No initial services for testing
--    )
--}
--
--// Helper function to create a sample transaction
--fn create_sample_transaction() -> MockTransaction {
--    MockTransaction {
--        id: vec![1, 2, 3],
--    }
--}
--
--#[test]
--fn test_chain_initialization() {
--    let chain = create_test_chain();
--
--    assert_eq!(chain.chain_id(), "test-chain");
--    assert_eq!(chain.status().height, 0);
--    assert_eq!(chain.status().total_transactions, 0);
--    assert_eq!(chain.status().is_running, false);
--}
--
--#[test]
--fn test_state_operations() {
--    let mut chain = create_test_chain();
--
--    // Test state update
--    let key = b"test-key";
--    let value = b"test-value";
--    chain.update_state(key, value).unwrap();
--
--    // Test state query
--    let retrieved = chain.query_state(key).unwrap();
--    assert_eq!(retrieved.unwrap(), value);
--
--    // Test state deletion
--    chain.delete_state(key).unwrap();
--    assert!(chain.query_state(key).is_none());
--}
--
--#[test]
--fn test_transaction_processing() {
--    let mut chain = create_test_chain();
--
--    let tx = create_sample_transaction();
--
--    // Test processing a single transaction
--    assert!(chain.process_transaction(&tx).is_ok());
--
--    // Test processing a batch of transactions
--    let txs = vec![tx.clone(), tx.clone()];
--    let results = chain.process_transactions(&txs).unwrap();
--
--    assert_eq!(results.len(), 2);
--    for result in results {
--        assert_eq!(result, "Success");
--    }
--}
--
--#[test]
--fn test_block_processing() {
--    let mut chain = create_test_chain();
--
--    // Start the chain
--    chain.start().unwrap();
--
--    // Create a block with transactions
--    let txs = vec![create_sample_transaction(), create_sample_transaction()];
--    let block = chain.create_block(txs);
--
--    // Verify the block height is correct
--    assert_eq!(block.header.height, 1);
--
--    // Process the block
--    assert!(chain.process_block(block).is_ok());
--
--    // Verify chain height increased
--    assert_eq!(chain.status().height, 1);
--
--    // Verify the block is in recent blocks
--    let retrieved_block = chain.get_block(1).unwrap();
--    assert_eq!(retrieved_block.header.height, 1);
--
--    // Verify latest block is accessible
--    let latest = chain.get_latest_block().unwrap();
--    assert_eq!(latest.header.height, 1);
--}
--
--#[test]
--fn test_chain_lifecycle() {
--    let mut chain = create_test_chain();
--
--    // Test start
--    chain.start().unwrap();
--    assert!(chain.status().is_running);
--
--    // Test stop
--    chain.stop().unwrap();
--    assert!(!chain.status().is_running);
--
--    // Test reset
--    chain.update_state(b"key", b"value").unwrap();
--    chain.reset().unwrap();
--    assert_eq!(chain.status().height, 0);
--    assert_eq!(chain.status().total_transactions, 0);
--    assert!(!chain.status().is_running);
--}
--
--#[test]
--fn test_max_recent_blocks() {
--    let mut chain = create_test_chain();
--
--    // Set a small limit
--    chain.set_max_recent_blocks(2);
--
--    // Start the chain
--    chain.start().unwrap();
--
--    // Process several blocks
--    for _ in 0..3 {
--        let txs = vec![create_sample_transaction()];
--        let block = chain.create_block(txs);
--        chain.process_block(block).unwrap();
--    }
--
--    // Verify we only have the latest 2 blocks
--    assert!(chain.get_block(1).is_none()); // Should be removed
--    assert!(chain.get_block(2).is_some()); // Should be present
--    assert!(chain.get_block(3).is_some()); // Should be present
--}
-\ No newline at end of file
-diff --git a/crates/chain/src/bin/mvsc.rs b/crates/chain/src/bin/mvsc.rs
-index 45253d9..ccc8c32 100644
---- a/crates/chain/src/bin/mvsc.rs
-+++ b/crates/chain/src/bin/mvsc.rs
-@@ -1,187 +1,116 @@
-+// Path: crates/chain/src/bin/mvsc.rs
-+
- //! # Minimum Viable Single-Node Chain (MVSC)
- //!
--//! Now with persistence and P2P networking!
--//!
--//! This binary runs a blockchain node that can:
--//! 1. Persist its state to `state.json` and resume after a restart.
--//! 2. Discover other nodes on the local network using mDNS.
--//! 3. Gossip new blocks to peers using libp2p.
--//! 4. Process blocks received from peers.
-+//! This binary acts as the composition root for the validator node. It initializes
-+//! all core components (chain logic, state, containers) and wires them together.
- 
- use anyhow::anyhow;
- use clap::Parser;
--use depin_sdk_chain::app::SovereignAppChain;
-+use depin_sdk_chain::ChainLogic;
- use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
--use depin_sdk_state_trees::file::FileStateTree; // Use our new FileStateTree
--use depin_sdk_transaction_models::utxo::{UTXOModel, UTXOTransaction};
--use depin_sdk_validator::standard::StandardValidator;
--
--use futures::stream::StreamExt;
--use libp2p::{gossipsub, mdns, swarm::SwarmEvent};
--use std::hash::{Hash, Hasher};
-+use depin_sdk_core::config::WorkloadConfig;
-+use depin_sdk_core::validator::WorkloadContainer;
-+use depin_sdk_core::Container;
-+// MODIFIED: Import Multiaddr directly from the top-level libp2p crate.
-+use libp2p::Multiaddr;
-+use depin_sdk_state_trees::file::FileStateTree;
-+use depin_sdk_transaction_models::utxo::UTXOModel;
-+use depin_sdk_validator::common::GuardianContainer;
-+use depin_sdk_validator::standard::OrchestrationContainer;
-+use std::path::PathBuf;
- use std::sync::Arc;
--use std::time::Duration;
- use tokio::sync::Mutex;
- 
--// --- LIBP2P NETWORKING SETUP ---
--
--// We create a custom network behaviour that combines Gossipsub and Mdns.
--#[derive(libp2p::swarm::NetworkBehaviour)]
--struct MyBehaviour {
--    gossipsub: gossipsub::Behaviour,
--    mdns: mdns::tokio::Behaviour,
--}
--
--const BLOCK_TOPIC: &str = "blocks";
--
--// --- COMMAND LINE ARGUMENTS ---
--
- #[derive(Parser, Debug)]
- #[clap(name = "mvsc", about = "A minimum viable sovereign chain node.")]
- struct Opts {
--    /// Listening port for the p2p network.
--    #[clap(long, default_value = "0")]
--    listen_port: u16,
--
--    /// Path to the state file.
-     #[clap(long, default_value = "state.json")]
-     state_file: String,
--
--    /// Path to the directory containing validator configuration files (guardian.toml, orchestration.toml, workload.toml).
-     #[clap(long, default_value = "./config")]
-     config_dir: String,
-+    #[clap(long)]
-+    peer: Option<String>,
- }
- 
--// --- MAIN APPLICATION ---
- #[tokio::main]
- async fn main() -> anyhow::Result<()> {
-     env_logger::builder().filter_level(log::LevelFilter::Info).init();
-     let opts = Opts::parse();
-+    log::info!("Initializing DePIN SDK Node...");
-+    log::info!("Using state file: {}", &opts.state_file);
- 
--    // --- CHAIN SETUP ---
--    log::info!("Starting Minimum Viable Sovereign Chain (MVSC)...");
-+    // --- 1. Initialize Independent Components ---
-     let commitment_scheme = HashCommitmentScheme::new();
--    let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
-     let transaction_model = UTXOModel::new(commitment_scheme.clone());
--    let validator_model =
--        StandardValidator::new(&opts.config_dir).map_err(|e| anyhow!(e))?;
--
--    let chain = Arc::new(Mutex::new(SovereignAppChain::new(
--        commitment_scheme,
--        state_tree,
-+    let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
-+    let workload_config = WorkloadConfig {
-+        enabled_vms: vec!["WASM".to_string()],
-+    };
-+
-+    // --- 2. Build the Validator Containers ---
-+    let workload_container = Arc::new(WorkloadContainer::new(workload_config, state_tree));
-+
-+    let config_path = PathBuf::from(&opts.config_dir);
-+    let orchestration_container = Arc::new(
-+        OrchestrationContainer::<
-+            HashCommitmentScheme,
-+            UTXOModel<HashCommitmentScheme>,
-+            FileStateTree<HashCommitmentScheme>,
-+        >::new(&config_path.join("orchestration.toml"))
-+        .await?,
-+    );
-+    let guardian_container = GuardianContainer::new(&config_path.join("guardian.toml"))?;
-+
-+    // --- 3. Create and Initialize the SovereignChain Logic ---
-+    let mut chain_logic = ChainLogic::new(
-+        commitment_scheme.clone(),
-         transaction_model,
--        validator_model,
-         "mvsc-chain-1",
-         vec![],
--    )));
--
--    // Start the validator model, which in turn starts its containers.
--    chain.lock().await.start().map_err(|e| anyhow!(e))?;
--
--    // --- P2P NETWORK SETUP ---
--    let mut swarm = libp2p::SwarmBuilder::with_new_identity()
--        .with_tokio()
--        .with_tcp(
--            libp2p::tcp::Config::default(),
--            libp2p::noise::Config::new,
--            libp2p::yamux::Config::default,
--        )?
--        .with_behaviour(|key| {
--            let message_id_fn = |message: &gossipsub::Message| {
--                let mut s = std::hash::DefaultHasher::new();
--                message.data.hash(&mut s);
--                gossipsub::MessageId::from(s.finish().to_string())
--            };
--            let gossipsub_config = gossipsub::ConfigBuilder::default()
--                .message_id_fn(message_id_fn)
--                // For a small test network, we don't need to wait for a mesh to form to publish.
--                .mesh_outbound_min(1)
--                .build()?;
--            Ok(MyBehaviour {
--                gossipsub: gossipsub::Behaviour::new(
--                    gossipsub::MessageAuthenticity::Signed(key.clone()),
--                    gossipsub_config,
--                )?,
--                mdns: mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?,
--            })
--        })?
--        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
--        .build();
--
--    let topic = gossipsub::IdentTopic::new(BLOCK_TOPIC);
--    swarm.behaviour_mut().gossipsub.subscribe(&topic)?;
--
--    let listen_addr = format!("/ip4/0.0.0.0/tcp/{}", opts.listen_port);
--    swarm.listen_on(listen_addr.parse()?)?;
--    log::info!("Local Peer ID: {}", swarm.local_peer_id());
-+    );
-+    chain_logic
-+        .load_or_initialize_status(&workload_container)
-+        .await
-+        .map_err(|e| anyhow!("Failed to load or initialize chain status: {:?}", e))?;
-+    let chain_ref: Arc<Mutex<ChainLogic<HashCommitmentScheme, UTXOModel<HashCommitmentScheme>>>> =
-+        Arc::new(Mutex::new(chain_logic));
-+
-+    // --- 4. Wire Up the Components (Inversion of Control) ---
-+    orchestration_container.set_chain_and_workload_ref(
-+        chain_ref.clone(),
-+        workload_container.clone(),
-+    );
-+
-+    // --- 5. Start the Validator Services ---
-+    guardian_container.start().await.map_err(|e| anyhow!(e))?;
-+    orchestration_container.start().await.map_err(|e| anyhow!(e))?;
-+    workload_container.start().await.map_err(|e| anyhow!(e))?;
-+
-+    // --- DIAL PEER IF PROVIDED ---
-+    if let Some(peer_addr_str) = opts.peer {
-+        let peer_addr: Multiaddr = peer_addr_str.parse()?;
-+        log::info!("Attempting to dial peer: {}", peer_addr_str);
-+        
-+        // MODIFIED: Revert to the simple, direct dial call. This now works because
-+        // `peer_addr` is of the correct type (`libp2p::Multiaddr`).
-+        orchestration_container
-+            .swarm
-+            .lock()
-+            .await
-+            .dial(peer_addr)?;
-+    }
- 
--    // --- MAIN EVENT LOOP ---
--    loop {
--        tokio::select! {
--            // Handle events from the p2p network
--            event = swarm.select_next_some() => {
--                match event {
--                    SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {
--                        for (peer_id, _multiaddr) in list {
--                            log::info!("mDNS discovered a new peer: {}", peer_id);
--                            swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
--                        }
--                    }
--                    SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
--                        for (peer_id, _multiaddr) in list {
--                            log::info!("mDNS discover peer has expired: {}", peer_id);
--                            swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);
--                        }
--                    }
--                    SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {
--                        propagation_source: peer_id,
--                        message_id: id,
--                        message,
--                    })) => {
--                        log::info!(
--                            "Got new gossip message with id: {} from peer: {}",
--                            id,
--                            peer_id
--                        );
-+    log::info!("Node successfully started. Running indefinitely...");
- 
--                        type AppBlock = depin_sdk_chain::app::Block<UTXOTransaction>;
--                        match serde_json::from_slice::<AppBlock>(&message.data) {
--                            Ok(block) => {
--                                let mut chain_lock = chain.lock().await;
--                                log::info!("Received Block #{} from network.", block.header.height);
-+    // 6. Keep the main thread alive.
-+    tokio::signal::ctrl_c().await?;
- 
--                                if block.header.height <= chain_lock.status().height {
--                                    log::info!("Ignoring old or duplicate block (height {}). Current height is {}.", block.header.height, chain_lock.status().height);
--                                    continue;
--                                }
-+    log::info!("Shutdown signal received. Stopping node...");
-+    orchestration_container.stop().await.map_err(|e| anyhow!(e))?;
-+    workload_container.stop().await.map_err(|e| anyhow!(e))?;
-+    guardian_container.stop().await.map_err(|e| anyhow!(e))?;
-+    log::info!("Node stopped gracefully.");
- 
--                                match chain_lock.process_block(block) {
--                                    Ok(_) => {
--                                        let status = chain_lock.status();
--                                        let state_commitment = chain_lock.get_state_commitment();
--                                        let state_root: &[u8] = state_commitment.as_ref();
--                                        log::info!(
--                                            "Processed network Block #{}. New State Root: 0x{}",
--                                            status.height,
--                                            hex::encode(state_root)
--                                        );
--                                    }
--                                    Err(e) => {
--                                        log::error!("Error processing block from network: {}", e);
--                                    }
--                                }
--                            }
--                            Err(e) => {
--                                log::error!("Failed to deserialize block: {:?}", e);
--                            }
--                        }
--                    }
--                    SwarmEvent::NewListenAddr { address, .. } => {
--                        log::info!("Local node is listening on {}", address);
--                    }
--                    _ => {}
--                }
--            },
--        }
--    }
-+    Ok(())
- }
-\ No newline at end of file
-diff --git a/crates/chain/src/lib.rs b/crates/chain/src/lib.rs
-index 908ca80..0133ca6 100644
---- a/crates/chain/src/lib.rs
-+++ b/crates/chain/src/lib.rs
-@@ -1,15 +1,11 @@
- //! # DePIN SDK Chain
- //!
--//! Chain implementation components for the DePIN SDK.
-+//! This crate provides the implementation logic for the `SovereignAppChain` state machine.
- 
--pub mod app;
-+mod app;
- pub mod upgrade_manager;
-+pub mod traits;
- 
--// Re-export for convenience
--pub use upgrade_manager::ModuleUpgradeManager;
--
--// Re-export consensus from its crate
--pub use depin_sdk_consensus as consensus;
--
--// TODO: Add governance crate when it's implemented
--// pub use depin_sdk_governance as governance;
-\ No newline at end of file
-+// FIX: Corrected the path to ChainLogic, removing the non-existent 'logic' module.
-+pub use app::ChainLogic;
-+pub use upgrade_manager::ModuleUpgradeManager;
-\ No newline at end of file
-diff --git a/crates/chain/src/upgrade_manager.rs b/crates/chain/src/upgrade_manager.rs
-deleted file mode 100644
-index 7ec12b6..0000000
---- a/crates/chain/src/upgrade_manager.rs
-+++ /dev/null
-@@ -1,185 +0,0 @@
--use depin_sdk_core::services::{ServiceType, UpgradableService};
--use depin_sdk_core::error::CoreError;
--use std::collections::HashMap;
--use std::sync::Arc;
--
--/// Manages runtime upgrades of blockchain services
--pub struct ModuleUpgradeManager {
--    /// Holds the currently active, concrete service implementations
--    active_services: HashMap<ServiceType, Arc<dyn UpgradableService>>,
--    /// Tracks upgrade history for each service type
--    upgrade_history: HashMap<ServiceType, Vec<u64>>,
--    /// Scheduled upgrades by block height
--    scheduled_upgrades: HashMap<u64, Vec<(ServiceType, Vec<u8>)>>,
--}
--
--impl ModuleUpgradeManager {
--    /// Create a new module upgrade manager
--    pub fn new() -> Self {
--        Self {
--            active_services: HashMap::new(),
--            upgrade_history: HashMap::new(),
--            scheduled_upgrades: HashMap::new(),
--        }
--    }
--
--    /// Register a service with the manager
--    pub fn register_service(&mut self, service: Arc<dyn UpgradableService>) {
--        let service_type = service.service_type();
--        self.active_services.insert(service_type.clone(), service);
--        
--        // Initialize upgrade history if not present
--        self.upgrade_history.entry(service_type).or_insert_with(Vec::new);
--    }
--
--    /// Get a service by type
--    pub fn get_service(&self, service_type: &ServiceType) -> Option<Arc<dyn UpgradableService>> {
--        self.active_services.get(service_type).cloned()
--    }
--
--    /// Schedule an upgrade for a specific block height
--    pub fn schedule_upgrade(
--        &mut self,
--        service_type: ServiceType,
--        upgrade_data: Vec<u8>,
--        activation_height: u64,
--    ) -> Result<(), CoreError> {
--        self.scheduled_upgrades
--            .entry(activation_height)
--            .or_insert_with(Vec::new)
--            .push((service_type, upgrade_data));
--        
--        Ok(())
--    }
--
--    /// Apply any upgrades scheduled for the given block height
--    pub fn apply_upgrades_at_height(&mut self, height: u64) -> Result<usize, CoreError> {
--        let upgrades = match self.scheduled_upgrades.remove(&height) {
--            Some(upgrades) => upgrades,
--            None => return Ok(0),
--        };
--
--        let mut applied_count = 0;
--        
--        for (service_type, upgrade_data) in upgrades {
--            match self.execute_upgrade(&service_type, &upgrade_data) {
--                Ok(()) => {
--                    applied_count += 1;
--                    // Record the upgrade in history
--                    if let Some(history) = self.upgrade_history.get_mut(&service_type) {
--                        history.push(height);
--                    }
--                }
--                Err(e) => {
--                    // Log error but continue with other upgrades
--                    eprintln!("Failed to upgrade service {:?}: {}", service_type, e);
--                }
--            }
--        }
--
--        Ok(applied_count)
--    }
--
--    /// Execute an upgrade for a specific service
--    pub fn execute_upgrade(
--        &mut self,
--        service_type: &ServiceType,
--        new_module_wasm: &[u8],
--    ) -> Result<(), CoreError> {
--        let active_service = self
--            .active_services
--            .get_mut(service_type)
--            .ok_or_else(|| CoreError::ServiceNotFound(format!("{:?}", service_type)))?;
--
--        // 1. Prepare: Get the state snapshot from the current service
--        let snapshot = active_service.prepare_upgrade(new_module_wasm)
--            .map_err(|e| CoreError::UpgradeError(e.to_string()))?;
--
--        // 2. TODO: Instantiate new service from WASM (or other format)
--        // This would require a proper WASM loading mechanism
--        // For now, we'll create a placeholder
--        
--        // 3. TODO: Complete the upgrade by migrating state to new service
--        // new_service.complete_upgrade(&snapshot)?;
--
--        // 4. TODO: Atomically swap the implementation
--        // self.active_services.insert(service_type.clone(), Arc::new(new_service));
--
--        // For now, just return success as this is a stub implementation
--        Ok(())
--    }
--
--    /// Get upgrade history for a service
--    pub fn get_upgrade_history(&self, service_type: &ServiceType) -> Vec<u64> {
--        self.upgrade_history
--            .get(service_type)
--            .cloned()
--            .unwrap_or_default()
--    }
--
--    /// Check health status of all services
--    pub fn check_all_health(&self) -> Vec<(ServiceType, bool)> {
--        self.active_services
--            .iter()
--            .map(|(service_type, service)| {
--                let is_healthy = match service.health_check() {
--                    Ok(_) => true,
--                    Err(_) => false,
--                };
--                (service_type.clone(), is_healthy)
--            })
--            .collect()
--    }
--
--    /// Start all registered services
--    pub fn start_all_services(&mut self) -> Result<(), CoreError> {
--        for (service_type, service) in &self.active_services {
--            service.start()
--                .map_err(|e| CoreError::Custom(format!(
--                    "Failed to start service {:?}: {}", 
--                    service_type, 
--                    e
--                )))?;
--        }
--        Ok(())
--    }
--
--    /// Stop all registered services
--    pub fn stop_all_services(&mut self) -> Result<(), CoreError> {
--        for (service_type, service) in &self.active_services {
--            service.stop()
--                .map_err(|e| CoreError::Custom(format!(
--                    "Failed to stop service {:?}: {}", 
--                    service_type, 
--                    e
--                )))?;
--        }
--        Ok(())
--    }
--
--    /// Reset the manager to initial state
--    pub fn reset(&mut self) -> Result<(), CoreError> {
--        // Stop all services first
--        self.stop_all_services()?;
--        
--        // Clear all state
--        self.active_services.clear();
--        self.upgrade_history.clear();
--        self.scheduled_upgrades.clear();
--        
--        Ok(())
--    }
--}
--
--/// Helper function to load a service from WASM bytes
--/// TODO: Implement actual WASM loading logic
--fn load_service_from_wasm(_wasm_bytes: &[u8]) -> Result<Box<dyn UpgradableService>, CoreError> {
--    Err(CoreError::Custom("WASM loading not implemented yet".to_string()))
--}
--
--#[cfg(test)]
--mod tests {
--    use super::*;
--
--    // TODO: Add tests when the implementation is complete
--}
-\ No newline at end of file
-diff --git a/crates/commitment_schemes/Cargo.toml b/crates/commitment_schemes/Cargo.toml
-index 228c617..5ec6766 100644
---- a/crates/commitment_schemes/Cargo.toml
-+++ b/crates/commitment_schemes/Cargo.toml
-@@ -7,12 +7,12 @@ license = "MIT OR Apache-2.0"
- 
- [dependencies]
- depin-sdk-core = { path = "../core" }
-+depin-sdk-crypto = { path = "../crypto" }
-+dcrypt = { version = "0.12.0-beta.1", features = ["full"] }
- log = { workspace = true }
- serde = { workspace = true }
- thiserror = { workspace = true }
- bytes = { workspace = true }
--sha2 = { workspace = true }
--curve25519-dalek = { workspace = true }
- rand = { workspace = true }
- 
- [features]
-diff --git a/crates/commitment_schemes/src/elliptical_curve/mod.rs b/crates/commitment_schemes/src/elliptical_curve/mod.rs
-index 2c5b3c6..efb66e0 100644
---- a/crates/commitment_schemes/src/elliptical_curve/mod.rs
-+++ b/crates/commitment_schemes/src/elliptical_curve/mod.rs
-@@ -2,12 +2,9 @@
- // File: crates/commitment_schemes/src/elliptical_curve/mod.rs
- //! Elliptical curve commitment implementation
- 
--use curve25519_dalek::ristretto::{CompressedRistretto, RistrettoPoint};
--use curve25519_dalek::scalar::Scalar;
--use curve25519_dalek::traits::Identity;
-+use depin_sdk_crypto::algorithms::hash;
-+use dcrypt::algorithms::ec::k256::{self as k256, Point, Scalar};
- use rand::{rngs::OsRng, RngCore};
--use sha2::{Digest, Sha512};
--use std::fmt::Debug;
- 
- use depin_sdk_core::commitment::{
-     CommitmentScheme, HomomorphicCommitmentScheme, HomomorphicOperation, ProofContext,
-@@ -18,16 +15,16 @@ use depin_sdk_core::commitment::{
- #[derive(Debug, Clone)]
- pub struct EllipticalCurveCommitmentScheme {
-     /// Generator points
--    generators: Vec<RistrettoPoint>,
-+    generators: Vec<Point>,
- }
- 
- /// Elliptical curve commitment
- #[derive(Debug, Clone, PartialEq, Eq)]
--pub struct EllipticalCurveCommitment(CompressedRistretto);
-+pub struct EllipticalCurveCommitment([u8; k256::K256_POINT_COMPRESSED_SIZE]);
- 
- impl AsRef<[u8]> for EllipticalCurveCommitment {
-     fn as_ref(&self) -> &[u8] {
--        self.0.as_bytes()
-+        &self.0
-     }
- }
- 
-@@ -47,39 +44,46 @@ impl EllipticalCurveCommitmentScheme {
-     pub fn new(num_generators: usize) -> Self {
-         // Generate deterministic generators for reproducible tests
-         let mut generators = Vec::with_capacity(num_generators);
-+        let g = k256::base_point_g();
-         for i in 0..num_generators {
--            // Use a SHA-512 hash to derive each generator point
--            let mut hasher = Sha512::new();
--            hasher.update(format!("generator-{}", i).as_bytes());
--            let hash = hasher.finalize();
--
--            let mut seed = [0u8; 64];
--            seed.copy_from_slice(&hash);
--
--            generators.push(RistrettoPoint::from_uniform_bytes(&seed));
-+            // Use a SHA-256 hash to derive a scalar for each generator point
-+            let scalar = Self::hash_to_scalar(format!("generator-{}", i).as_bytes());
-+            generators.push(g.mul(&scalar).expect("Failed to create generator"));
-         }
- 
-         Self { generators }
-     }
- 
-     /// Generate a random blinding factor
--    fn random_blinding() -> Scalar {
-+    fn random_blinding() -> k256::Scalar {
-         let mut rng = OsRng;
--        let mut bytes = [0u8; 64];
--        rng.fill_bytes(&mut bytes);
--        Scalar::from_bytes_mod_order_wide(&bytes)
-+        loop {
-+            let mut bytes = [0u8; 32];
-+            rng.fill_bytes(&mut bytes);
-+            if let Ok(scalar) = Scalar::new(bytes) {
-+                return scalar;
-+            }
-+        }
-     }
- 
-     /// Convert value to scalar
--    fn value_to_scalar(value: &impl AsRef<[u8]>) -> Scalar {
--        let mut hasher = Sha512::new();
--        hasher.update(value.as_ref());
--        let hash = hasher.finalize();
--
--        let mut scalar_bytes = [0u8; 64];
--        scalar_bytes.copy_from_slice(&hash);
-+    fn value_to_scalar(value: &impl AsRef<[u8]>) -> k256::Scalar {
-+        Self::hash_to_scalar(value.as_ref())
-+    }
- 
--        Scalar::from_bytes_mod_order_wide(&scalar_bytes)
-+    /// Helper to convert a hash to a valid scalar, retrying if needed.
-+    fn hash_to_scalar(data: &[u8]) -> k256::Scalar {
-+        let mut hash_bytes = hash::sha256(data);
-+        loop {
-+            // Create a fixed-size array from the vector's slice to avoid moving hash_bytes.
-+            let mut array = [0u8; 32];
-+            array.copy_from_slice(&hash_bytes);
-+            if let Ok(scalar) = Scalar::new(array) {
-+                return scalar;
-+            }
-+            // Re-hash if the hash corresponds to an invalid scalar (e.g., zero)
-+            hash_bytes = hash::sha256(&hash_bytes);
-+        }
-     }
- }
- 
-@@ -90,7 +94,7 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
- 
-     fn commit(&self, values: &[Option<Self::Value>]) -> Self::Commitment {
-         // Start with identity point
--        let mut commitment_point = RistrettoPoint::identity();
-+        let mut commitment_point = Point::identity();
- 
-         // Use generators for each value
-         for (i, value_opt) in values.iter().enumerate() {
-@@ -102,19 +106,21 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
-                 // Convert value to scalar
-                 let scalar = Self::value_to_scalar(value);
- 
--                // Add generator_i * value_scalar to commitment
--                commitment_point += self.generators[i] * scalar;
-+                // Add generator_i * value_scalar to the commitment point
-+                let term = self.generators[i].mul(&scalar).expect("Scalar mul failed");
-+                commitment_point = commitment_point.add(&term);
-             }
-         }
- 
-         // Add a random blinding factor with the last generator if we have one
-         if !self.generators.is_empty() {
-             let blinding = Self::random_blinding();
--            commitment_point += self.generators[self.generators.len() - 1] * blinding;
-+            let blinding_term = self.generators[self.generators.len() - 1].mul(&blinding).expect("Blinding failed");
-+            commitment_point = commitment_point.add(&blinding_term);
-         }
- 
--        // Return the compressed point
--        EllipticalCurveCommitment(commitment_point.compress())
-+        // Return the compressed point representation
-+        EllipticalCurveCommitment(commitment_point.serialize_compressed())
-     }
- 
-     fn create_proof(
-@@ -205,17 +211,18 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
-         // Convert value to scalar
-         let value_scalar = Self::value_to_scalar(value);
- 
--        // Create a commitment to this single value with the provided blinding
--        let blinding_generator = self.generators[self.generators.len() - 1];
--        let computed_point =
--            (self.generators[position] * value_scalar) + (blinding_generator * proof.blinding);
-+        // Recreate the point for the value and blinding factor
-+        let blinding_generator = &self.generators[self.generators.len() - 1];
-+        let value_term = self.generators[position].mul(&value_scalar).expect("Scalar mul failed");
-+        let blinding_term = blinding_generator.mul(&proof.blinding).expect("Blinding failed");
-+        let computed_point = value_term.add(&blinding_term);
- 
-         // Check if the computed commitment matches the provided one
--        let computed_commitment = EllipticalCurveCommitment(computed_point.compress());
-+        let computed_commitment = EllipticalCurveCommitment(computed_point.serialize_compressed());
- 
-         // This is a simplified check - a real implementation would be more complex
-         // for multiple values
--        commitment.0 == computed_commitment.0
-+        commitment.as_ref() == computed_commitment.as_ref()
-     }
- 
-     fn scheme_id() -> SchemeIdentifier {
-@@ -226,17 +233,13 @@ impl CommitmentScheme for EllipticalCurveCommitmentScheme {
- impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
-     fn add(&self, a: &Self::Commitment, b: &Self::Commitment) -> Result<Self::Commitment, String> {
-         // Decompress points
--        let point_a =
--            a.0.decompress()
--                .ok_or_else(|| "Invalid point in commitment A".to_string())?;
--        let point_b =
--            b.0.decompress()
--                .ok_or_else(|| "Invalid point in commitment B".to_string())?;
-+        let point_a = Point::deserialize_compressed(a.as_ref()).map_err(|e| e.to_string())?;
-+        let point_b = Point::deserialize_compressed(b.as_ref()).map_err(|e| e.to_string())?;
- 
-         // Homomorphic addition is point addition
--        let result_point = point_a + point_b;
-+        let result_point = point_a.add(&point_b);
- 
--        Ok(EllipticalCurveCommitment(result_point.compress()))
-+        Ok(EllipticalCurveCommitment(result_point.serialize_compressed()))
-     }
- 
-     fn scalar_multiply(
-@@ -249,17 +252,17 @@ impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
-         }
- 
-         // Decompress point
--        let point =
--            a.0.decompress()
--                .ok_or_else(|| "Invalid point in commitment".to_string())?;
-+        let point = Point::deserialize_compressed(a.as_ref()).map_err(|e| e.to_string())?;
- 
--        // Convert i32 to Scalar
--        let s = Scalar::from(scalar as u64);
-+        // Convert i32 to Scalar. This is a simplified conversion for small, positive integers.
-+        let mut scalar_bytes = [0u8; 32];
-+        scalar_bytes[..8].copy_from_slice(&(scalar as u64).to_le_bytes());
-+        let s = Scalar::new(scalar_bytes).map_err(|e| e.to_string())?;
- 
-         // Scalar multiplication
--        let result_point = point * s;
-+        let result_point = point.mul(&s).map_err(|e| e.to_string())?;
- 
--        Ok(EllipticalCurveCommitment(result_point.compress()))
-+        Ok(EllipticalCurveCommitment(result_point.serialize_compressed()))
-     }
- 
-     fn supports_operation(&self, operation: HomomorphicOperation) -> bool {
-@@ -273,30 +276,24 @@ impl HomomorphicCommitmentScheme for EllipticalCurveCommitmentScheme {
- // Add utility methods for EllipticalCurveCommitment
- impl EllipticalCurveCommitment {
-     /// Create a new EllipticalCurveCommitment from a compressed point
--    pub fn new(point: CompressedRistretto) -> Self {
-+    pub fn new(point: [u8; k256::K256_POINT_COMPRESSED_SIZE]) -> Self {
-         Self(point)
-     }
- 
-     /// Get the compressed point
--    pub fn point(&self) -> &CompressedRistretto {
-+    pub fn point(&self) -> &[u8; k256::K256_POINT_COMPRESSED_SIZE] {
-         &self.0
-     }
- 
-     /// Convert to a byte representation
-     pub fn to_bytes(&self) -> Vec<u8> {
--        self.0.as_bytes().to_vec()
-+        self.0.to_vec()
-     }
- 
-     /// Create from bytes
-     pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
--        if bytes.len() != 32 {
--            return Err("Invalid point length".to_string());
--        }
--
--        let mut array = [0u8; 32];
--        array.copy_from_slice(bytes);
--
--        Ok(Self(CompressedRistretto(array)))
-+        let array: [u8; k256::K256_POINT_COMPRESSED_SIZE] = bytes.try_into().map_err(|_| "Invalid point length".to_string())?;
-+        Ok(Self(array))
-     }
- }
- 
-@@ -331,7 +328,7 @@ impl EllipticalCurveProof {
-         let mut result = Vec::with_capacity(32 + 8 + self.value.len() + 4);
- 
-         // Serialize blinding factor (32 bytes)
--        result.extend_from_slice(self.blinding.as_bytes());
-+        result.extend_from_slice(self.blinding.serialize().as_ref());
- 
-         // Serialize position (8 bytes)
-         result.extend_from_slice(&self.position.to_le_bytes());
-@@ -355,12 +352,7 @@ impl EllipticalCurveProof {
-         // Read blinding
-         let mut blinding_bytes = [0u8; 32];
-         blinding_bytes.copy_from_slice(&bytes[pos..pos + 32]);
--        let maybe_blinding = Scalar::from_canonical_bytes(blinding_bytes);
--        let blinding = if maybe_blinding.is_some().into() {
--            maybe_blinding.unwrap()
--        } else {
--            return Err("Invalid blinding factor".to_string());
--        };
-+        let blinding = Scalar::new(blinding_bytes).map_err(|e| e.to_string())?;
-         pos += 32;
- 
-         // Read position
-@@ -387,4 +379,4 @@ impl EllipticalCurveProof {
-             value,
-         })
-     }
--}
-+}
-\ No newline at end of file
-diff --git a/crates/commitment_schemes/src/hash/mod.rs b/crates/commitment_schemes/src/hash/mod.rs
-index b19cb0b..435bbdc 100644
---- a/crates/commitment_schemes/src/hash/mod.rs
-+++ b/crates/commitment_schemes/src/hash/mod.rs
-@@ -1,7 +1,7 @@
- //! Hash-based commitment scheme implementations
- 
- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, SchemeIdentifier, Selector};
--use sha2::{Digest, Sha256};
-+use depin_sdk_crypto::algorithms::hash;
- use std::fmt::Debug;
- 
- /// Hash-based commitment scheme
-@@ -18,8 +18,6 @@ pub enum HashFunction {
-     Sha256,
-     /// SHA-512
-     Sha512,
--    /// Keccak-256
--    Keccak256,
- }
- 
- /// Hash-based commitment
-@@ -59,19 +57,8 @@ impl HashCommitmentScheme {
-     /// Helper function to hash data using the selected hash function
-     pub fn hash_data(&self, data: &[u8]) -> Vec<u8> {
-         match self.hash_function {
--            HashFunction::Sha256 => {
--                let mut hasher = Sha256::new();
--                hasher.update(data);
--                hasher.finalize().to_vec()
--            }
--            HashFunction::Sha512 => {
--                // Implementation for SHA-512 would go here
--                vec![0; 64] // Placeholder
--            }
--            HashFunction::Keccak256 => {
--                // Implementation for Keccak-256 would go here
--                vec![0; 32] // Placeholder
--            }
-+            HashFunction::Sha256 => hash::sha256(data),
-+            HashFunction::Sha512 => hash::sha512(data),
-         }
-     }
- 
-@@ -85,7 +72,6 @@ impl HashCommitmentScheme {
-         match self.hash_function {
-             HashFunction::Sha256 => 32,
-             HashFunction::Sha512 => 64,
--            HashFunction::Keccak256 => 32,
-         }
-     }
- }
-@@ -155,8 +141,9 @@ impl CommitmentScheme for HashCommitmentScheme {
-         value: &Self::Value,
-         context: &ProofContext,
-     ) -> bool {
--        // Verify that selectors match
--        if !matches!(&proof.selector, selector) {
-+        // FIX: The compiler detected that `selector` was being compared to itself.
-+        // We need to compare the proof's selector with the one passed to the function.
-+        if &proof.selector != selector {
-             return false;
-         }
- 
-@@ -386,4 +373,4 @@ impl HashProof {
-             additional_data,
-         })
-     }
--}
-+}
-\ No newline at end of file
-diff --git a/crates/core/Cargo.toml b/crates/core/Cargo.toml
-index 1593103..7ff57a3 100644
---- a/crates/core/Cargo.toml
-+++ b/crates/core/Cargo.toml
-@@ -1,18 +1,23 @@
-+# Path: crates/core/Cargo.toml
-+
- [package]
- name = "depin-sdk-core"
- version = "0.1.0"
- edition = "2021"
--description = "Core traits and interfaces for the DePIN SDK"
-+description = "Core types and traits for the DePIN SDK"
- license = "MIT OR Apache-2.0"
- 
- [dependencies]
-+# FIX: Add async-trait as a dependency, which is now required by the Container trait.
-+async-trait = { workspace = true }
- log = { workspace = true }
--serde = { workspace = true }
-+serde = { workspace = true, features = ["derive"] }
-+serde_json = { workspace = true }
- thiserror = { workspace = true }
- bytes = { workspace = true }
--anyhow = { workspace = true }
-+tokio = { workspace = true, features = ["sync"] }
- 
- [features]
- default = []
--post-quantum = []
- homomorphic = []
-+post-quantum = []
-diff --git a/crates/core/src/error/mod.rs b/crates/core/src/error/mod.rs
-index 94109af..85437bc 100644
---- a/crates/core/src/error/mod.rs
-+++ b/crates/core/src/error/mod.rs
-@@ -1,128 +1,57 @@
--//! Error types for the DePIN SDK Core.
-+// Path: crates/core/src/error/mod.rs
- 
--use std::fmt;
-+use thiserror::Error;
- 
--/// Error type for transaction operations
--#[derive(Debug, Clone, PartialEq, Eq)]
--pub enum TransactionError {
--    /// Invalid transaction format or data
--    InvalidTransaction(String),
--    
--    /// Failed to access or modify state
--    StateAccessFailed(String),
--    
--    /// Invalid input referenced in transaction
--    InvalidInput(String),
--    
--    /// Insufficient funds for transaction
--    InsufficientFunds(String),
--    
--    /// Invalid signature
--    InvalidSignature(String),
--    
--    /// Invalid nonce value
--    InvalidNonce(String),
--    
--    /// Serialization or deserialization error
--    SerializationError(String),
--    
--    /// Other transaction errors
--    Other(String),
--}
--
--impl fmt::Display for TransactionError {
--    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--        match self {
--            TransactionError::InvalidTransaction(msg) => write!(f, "Invalid transaction: {}", msg),
--            TransactionError::StateAccessFailed(msg) => write!(f, "State access failed: {}", msg),
--            TransactionError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
--            TransactionError::InsufficientFunds(msg) => write!(f, "Insufficient funds: {}", msg),
--            TransactionError::InvalidSignature(msg) => write!(f, "Invalid signature: {}", msg),
--            TransactionError::InvalidNonce(msg) => write!(f, "Invalid nonce: {}", msg),
--            TransactionError::SerializationError(msg) => write!(f, "Serialization error: {}", msg),
--            TransactionError::Other(msg) => write!(f, "Other error: {}", msg),
--        }
--    }
--}
--
--impl std::error::Error for TransactionError {}
--
--/// Error type for state operations
--#[derive(Debug, Clone, PartialEq, Eq)]
-+#[derive(Error, Debug)]
- pub enum StateError {
--    /// Key not found in state
-+    #[error("Key not found: {0}")]
-     KeyNotFound(String),
--    
--    /// Failed to read from storage
--    ReadError(String),
--    
--    /// Failed to write to storage
-+    #[error("Validation failed: {0}")]
-+    Validation(String),
-+    #[error("Apply failed: {0}")]
-+    Apply(String),
-+    #[error("State backend error: {0}")]
-+    Backend(String),
-+    // FIX: Add variants for errors that occur in state tree implementations.
-+    // The `WriteError` is used by `FileStateTree` when file I/O fails.
-+    // The `InvalidValue` is used by `VerkleTree` when a value can't be converted.
-+    #[error("State write error: {0}")]
-     WriteError(String),
--    
--    /// Invalid key format
--    InvalidKey(String),
--    
--    /// Invalid value format
-+    #[error("Invalid value: {0}")]
-     InvalidValue(String),
--    
--    /// Other state errors
--    Other(String),
- }
- 
--impl fmt::Display for StateError {
--    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
--        match self {
--            StateError::KeyNotFound(msg) => write!(f, "Key not found: {}", msg),
--            StateError::ReadError(msg) => write!(f, "Read error: {}", msg),
--            StateError::WriteError(msg) => write!(f, "Write error: {}", msg),
--            StateError::InvalidKey(msg) => write!(f, "Invalid key: {}", msg),
--            StateError::InvalidValue(msg) => write!(f, "Invalid value: {}", msg),
--            StateError::Other(msg) => write!(f, "Other error: {}", msg),
--        }
--    }
--}
--
--impl std::error::Error for StateError {}
--
--impl From<StateError> for TransactionError {
--    fn from(error: StateError) -> Self {
--        TransactionError::StateAccessFailed(error.to_string())
--    }
-+#[derive(Error, Debug)]
-+pub enum TransactionError {
-+    #[error("Serialization error: {0}")]
-+    Serialization(String),
-+    #[error("Deserialization error: {0}")]
-+    Deserialization(String),
-+    #[error("Invalid transaction: {0}")]
-+    Invalid(String),
-+    // FIX: Add a variant to wrap StateErrors, which will allow `?` to work.
-+    #[error("State error: {0}")]
-+    State(#[from] StateError),
- }
- 
--/// Error type for validator operations.
--#[derive(Debug, thiserror::Error)]
-+#[derive(Error, Debug)]
- pub enum ValidatorError {
--    #[error("Container operation failed: {0}")]
--    Container(String),
-+    #[error("Container '{0}' is already running")]
-+    AlreadyRunning(String),
-+    #[error("IO error: {0}")]
-+    Io(#[from] std::io::Error),
-     #[error("Configuration error: {0}")]
-     Config(String),
--    #[error("Lifecycle error: {0}")]
--    Lifecycle(String),
-+    #[error("Other error: {0}")]
-+    Other(String),
- }
- 
--
--/// Core error type for the SDK
--#[derive(Debug, thiserror::Error)]
-+#[derive(Debug, Error)]
- pub enum CoreError {
-     #[error("Service not found: {0}")]
-     ServiceNotFound(String),
--    
--    #[error("Invalid block: {0}")]
--    InvalidBlock(String),
--    
--    #[error("Consensus error: {0}")]
--    ConsensusError(String),
--    
--    #[error("Cryptographic error: {0}")]
--    CryptoError(String),
--    
-     #[error("Upgrade error: {0}")]
-     UpgradeError(String),
--    
-     #[error("Custom error: {0}")]
-     Custom(String),
--}
--
--/// Result type used throughout the SDK
--pub type Result<T> = std::result::Result<T, CoreError>;
-\ No newline at end of file
-+}
-\ No newline at end of file
-diff --git a/crates/core/src/lib.rs b/crates/core/src/lib.rs
-index 86b9a40..e556e69 100644
---- a/crates/core/src/lib.rs
-+++ b/crates/core/src/lib.rs
-@@ -2,25 +2,31 @@
- //!
- //! Core traits and interfaces for the DePIN SDK.
- 
-+pub mod app;
-+pub mod chain;
-+pub mod commitment;
- pub mod component;
-+// NEW: A module for shared configuration structs.
-+pub mod config;
- pub mod crypto;
- pub mod error;
- pub mod homomorphic;
-+pub mod ibc;
- pub mod services;
--pub mod commitment;
- pub mod state;
--pub mod types;
--pub mod ibc;
- pub mod transaction;
-+pub mod types;
- pub mod validator;
- 
--// Only include test utilities when running tests
- #[cfg(test)]
- pub mod test_utils;
- 
- // Re-export key traits and types for convenience
-+pub use app::*;
-+pub use chain::*;
- pub use commitment::*;
- pub use component::*;
-+pub use config::*;
- pub use crypto::*;
- pub use error::*;
- pub use homomorphic::*;
-diff --git a/crates/core/src/state/manager.rs b/crates/core/src/state/manager.rs
-index d72d7a8..0d835ed 100644
---- a/crates/core/src/state/manager.rs
-+++ b/crates/core/src/state/manager.rs
-@@ -1,79 +1,22 @@
--// File: crates/core/src/state/manager.rs
-+// Path: crates/core/src/state/manager.rs
- 
- use crate::error::StateError;
-+use crate::state::StateTree;
- 
--/// State manager interface for the DePIN SDK
-+/// State manager interface for the DePIN SDK.
- ///
--/// The StateManager provides a higher-level interface for state operations,
--/// potentially wrapping one or more state trees or other storage mechanisms.
--/// It provides key-value access with optional commitment scheme capabilities.
--pub trait StateManager {
--    /// The commitment type this manager uses
--    type Commitment;
--    
--    /// The proof type this manager uses
--    type Proof;
--    
--    /// Get a value by key
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError>;
--    
--    /// Set a value for a key
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError>;
--    
--    /// Delete a key-value pair
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError>;
--    
--    /// Set multiple key-value pairs in a single batch operation
--    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
--        // Default implementation applies updates one by one
--        for (key, value) in updates {
--            self.set(key, value)?;
--        }
--        Ok(())
--    }
--    
--    /// Get multiple values by keys in a single batch operation
--    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
--        // Default implementation retrieves values one by one
--        let mut values = Vec::with_capacity(keys.len());
--        for key in keys {
--            values.push(self.get(key)?);
--        }
--        Ok(values)
--    }
--    
--    /// Get the current root commitment
--    ///
--    /// # Returns
--    /// * The current root commitment
--    fn root_commitment(&self) -> Self::Commitment;
--    
--    /// Create a proof for a specific key
--    ///
--    /// # Arguments
--    /// * `key` - The key to create a proof for
--    ///
--    /// # Returns
--    /// * `Some(proof)` - If proof creation succeeded
--    /// * `None` - If the key doesn't exist or proof creation isn't supported
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof>;
--    
--    /// Verify a proof against the root commitment
--    ///
--    /// # Arguments
--    /// * `commitment` - The commitment to verify against
--    /// * `proof` - The proof to verify
--    /// * `key` - The key the proof is for
--    /// * `value` - The value to verify
--    ///
--    /// # Returns
--    /// * `true` - If the proof is valid
--    /// * `false` - If the proof is invalid or verification isn't supported
--    fn verify_proof(
--        &self,
--        commitment: &Self::Commitment,
--        proof: &Self::Proof,
--        key: &[u8],
--        value: &[u8]
--    ) -> bool;
-+/// `StateManager` is a higher-level abstraction that must also be a `StateTree`.
-+/// It provides all the same core methods as `StateTree` (via inheritance) and
-+/// adds batching capabilities.
-+pub trait StateManager: StateTree {
-+    // REMOVED: All redundant associated types and method signatures from StateTree are gone.
-+    // They are inherited automatically.
-+
-+    /// Set multiple key-value pairs in a single batch operation.
-+    /// This is now a required method for any implementor of StateManager.
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError>;
-+
-+    /// Get multiple values by keys in a single batch operation.
-+    /// This is now a required method.
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError>;
- }
-\ No newline at end of file
-diff --git a/crates/core/src/state/mod.rs b/crates/core/src/state/mod.rs
-index 9eb2d2b..7a5ab82 100644
---- a/crates/core/src/state/mod.rs
-+++ b/crates/core/src/state/mod.rs
-@@ -1,3 +1,5 @@
-+// Path: crates/core/src/state/mod.rs
-+
- //! State management interfaces for the DePIN SDK Core.
- 
- mod manager;
-@@ -11,14 +13,14 @@ pub use tree::*;
- 
- use crate::commitment::CommitmentScheme;
- 
--/// Type alias for a StateManager compatible with a specific CommitmentScheme
-+/// Type alias for a StateManager trait object compatible with a specific CommitmentScheme.
- pub type StateManagerFor<CS> = dyn StateManager<
-     Commitment = <CS as CommitmentScheme>::Commitment,
-     Proof = <CS as CommitmentScheme>::Proof,
- >;
- 
--/// Type alias for a StateTree compatible with a specific CommitmentScheme
-+/// Type alias for a StateTree trait object compatible with a specific CommitmentScheme.
- pub type StateTreeFor<CS> = dyn StateTree<
-     Commitment = <CS as CommitmentScheme>::Commitment,
-     Proof = <CS as CommitmentScheme>::Proof,
-->;
-+>;
-\ No newline at end of file
-diff --git a/crates/core/src/transaction/mod.rs b/crates/core/src/transaction/mod.rs
-index bc7cafa..331f4d1 100644
---- a/crates/core/src/transaction/mod.rs
-+++ b/crates/core/src/transaction/mod.rs
-@@ -1,24 +1,44 @@
- // File: crates/core/src/transaction/mod.rs
- 
--use std::any::Any;
-+use crate::commitment::CommitmentScheme;
- use crate::error::TransactionError;
- use crate::state::StateManager;
--use crate::commitment::CommitmentScheme;
-+use std::any::Any;
-+use std::fmt::Debug;
- 
- /// Core transaction model trait that defines the interface for all transaction models.
- ///
- /// This trait is intentionally model-agnostic, allowing for different implementations
- /// (UTXO, account-based, hybrid, etc.) while providing a consistent interface.
- pub trait TransactionModel {
--    /// The transaction type for this model
--    type Transaction;
--    
--    /// The proof type for this model
-+    /// The transaction type for this model.
-+    type Transaction: Debug;
-+
-+    /// The proof type for this model.
-     type Proof;
--    
--    /// The commitment scheme used by this model
-+
-+    /// The commitment scheme used by this model.
-     type CommitmentScheme: CommitmentScheme;
- 
-+    /// Creates a "coinbase" or block reward transaction.
-+    ///
-+    /// This provides a generic way for a block producer (like the OrchestrationContainer)
-+    /// to create the first, special transaction in a block without needing to know the
-+    /// specific details of the transaction model.
-+    ///
-+    /// # Arguments
-+    /// * `block_height` - The height of the block this transaction will be in.
-+    /// * `recipient` - The public key or address of the block producer who should receive the reward.
-+    ///
-+    /// # Returns
-+    /// * `Ok(transaction)` - A valid coinbase transaction.
-+    /// * `Err(TransactionError)` - If the coinbase transaction could not be created.
-+    fn create_coinbase_transaction(
-+        &self,
-+        block_height: u64,
-+        recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError>;
-+
-     /// Validate a transaction against the current state.
-     ///
-     /// # Arguments
-@@ -32,9 +52,9 @@ pub trait TransactionModel {
-     fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
- 
-     /// Apply a transaction to the state.
-     ///
-@@ -48,10 +68,10 @@ pub trait TransactionModel {
-     fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
--    
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
-+
-     /// Generate a proof for a transaction.
-     ///
-     /// # Arguments
-@@ -61,13 +81,17 @@ pub trait TransactionModel {
-     /// # Returns
-     /// * `Ok(proof)` - If the proof was successfully generated.
-     /// * `Err(TransactionError)` - If an error occurred during proof generation.
--    fn generate_proof<S>(&self, tx: &Self::Transaction, state: &S) -> Result<Self::Proof, TransactionError>
-+    fn generate_proof<S>(
-+        &self,
-+        tx: &Self::Transaction,
-+        state: &S,
-+    ) -> Result<Self::Proof, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
--    
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
-+
-     /// Verify a proof for a transaction.
-     ///
-     /// # Arguments
-@@ -81,47 +105,23 @@ pub trait TransactionModel {
-     fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof
--        > + ?Sized;
--    
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized;
-+
-     /// Serialize a transaction to bytes.
--    ///
--    /// # Arguments
--    /// * `tx` - The transaction to serialize.
--    ///
--    /// # Returns
--    /// * `Ok(bytes)` - The serialized transaction.
--    /// * `Err(TransactionError)` - If an error occurred during serialization.
-     fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError>;
--    
-+
-     /// Deserialize bytes to a transaction.
--    ///
--    /// # Arguments
--    /// * `data` - The serialized transaction.
--    ///
--    /// # Returns
--    /// * `Ok(transaction)` - The deserialized transaction.
--    /// * `Err(TransactionError)` - If an error occurred during deserialization.
-     fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError>;
- 
-     /// Optional extension point for model-specific functionality.
--    ///
--    /// This allows models to expose additional functionality beyond the core interface
--    /// without breaking the common abstraction.
--    ///
--    /// # Returns
--    /// * `Some(extensions)` - A reference to model-specific extensions.
--    /// * `None` - If no extensions are available.
-     fn get_model_extensions(&self) -> Option<&dyn Any> {
-         None
-     }
- }
- 
--/// Registry for managing multiple transaction models.
--///
--/// This provides runtime selection capabilities when compile-time selection
--/// through feature flags is not feasible.
-+/// Registry for managing multiple transaction models at runtime.
- #[derive(Default)]
- pub struct TransactionModelRegistry {
-     models: std::collections::HashMap<String, Box<dyn Any>>,
-@@ -134,37 +134,20 @@ impl TransactionModelRegistry {
-             models: std::collections::HashMap::new(),
-         }
-     }
--    
-+
-     /// Register a transaction model.
--    ///
--    /// # Arguments
--    /// * `name` - The name to register the model under.
--    /// * `model` - The model to register.
-     pub fn register<T: TransactionModel + 'static>(&mut self, name: &str, model: T) {
-         self.models.insert(name.to_string(), Box::new(model));
-     }
--    
-+
-     /// Get a registered transaction model.
--    ///
--    /// # Arguments
--    /// * `name` - The name of the model to retrieve.
--    ///
--    /// # Returns
--    /// * `Some(model)` - The requested model.
--    /// * `None` - If no model is registered under the given name.
-     pub fn get<T: 'static>(&self, name: &str) -> Option<&T> {
--        self.models.get(name)
-+        self.models
-+            .get(name)
-             .and_then(|model| model.downcast_ref::<T>())
-     }
--    
-+
-     /// Check if a model is registered.
--    ///
--    /// # Arguments
--    /// * `name` - The name to check.
--    ///
--    /// # Returns
--    /// * `true` - If a model is registered under the given name.
--    /// * `false` - Otherwise.
-     pub fn has_model(&self, name: &str) -> bool {
-         self.models.contains_key(name)
-     }
-diff --git a/crates/core/src/types/mod.rs b/crates/core/src/types/mod.rs
-index a03207e..b107216 100644
---- a/crates/core/src/types/mod.rs
-+++ b/crates/core/src/types/mod.rs
-@@ -1,30 +1,34 @@
-+// Path: crates/core/src/types/mod.rs
-+
- //! Type aliases and common types for the DePIN SDK
- 
- use crate::commitment::CommitmentScheme;
- use crate::state::StateManager;
- use crate::transaction::TransactionModel;
- 
--/// Type aliases for commitment schemes
-+/// Type aliases for commitment schemes.
- pub mod commitment {
-     use super::*;
- 
--    /// The commitment type for a given commitment scheme
-+    /// The commitment type for a given commitment scheme.
-     pub type CommitmentOf<CS> = <CS as CommitmentScheme>::Commitment;
- 
--    /// The proof type for a given commitment scheme  
-+    /// The proof type for a given commitment scheme.
-     pub type ProofOf<CS> = <CS as CommitmentScheme>::Proof;
- 
--    /// The value type for a given commitment scheme
-+    /// The value type for a given commitment scheme.
-     pub type ValueOf<CS> = <CS as CommitmentScheme>::Value;
- }
- 
--/// Type aliases for state management
-+/// Type aliases for state management.
- pub mod state {
-     use super::*;
- 
--    /// Type alias for a state manager that uses a specific commitment scheme
--    pub type StateManagerFor<CS> 
--    where 
-+    /// Type alias for a `StateManager` trait object that is compatible with a
-+    /// specific `CommitmentScheme`. This is now unambiguous because `StateManager`
-+    /// inherits its associated types directly from its `StateTree` supertrait.
-+    pub type StateManagerFor<CS>
-+    where
-         CS: CommitmentScheme,
-     = dyn StateManager<
-         Commitment = <CS as CommitmentScheme>::Commitment,
-@@ -32,16 +36,16 @@ pub mod state {
-     >;
- }
- 
--/// Type aliases for transaction models
-+/// Type aliases for transaction models.
- pub mod transaction {
-     use super::*;
- 
--    /// Transaction type for a transaction model
-+    /// The transaction type for a given transaction model.
-     pub type TransactionOf<TM> = <TM as TransactionModel>::Transaction;
- 
--    /// Proof type for a transaction model
-+    /// The proof type for a given transaction model.
-     pub type ProofOf<TM> = <TM as TransactionModel>::Proof;
- 
--    /// Commitment scheme type for a transaction model
-+    /// The commitment scheme type for a given transaction model.
-     pub type CommitmentSchemeOf<TM> = <TM as TransactionModel>::CommitmentScheme;
- }
-\ No newline at end of file
-diff --git a/crates/core/src/validator/container.rs b/crates/core/src/validator/container.rs
-deleted file mode 100644
-index 34be8ae..0000000
---- a/crates/core/src/validator/container.rs
-+++ /dev/null
-@@ -1,26 +0,0 @@
--//! Container interface definitions
--use crate::error::ValidatorError;
--
--/// Container interface
--pub trait Container {
--    /// Start the container
--    fn start(&self) -> Result<(), ValidatorError>;
--    
--    /// Stop the container
--    fn stop(&self) -> Result<(), ValidatorError>;
--    
--    /// Check if the container is running
--    fn is_running(&self) -> bool;
--    
--    /// Get the container ID
--    fn id(&self) -> &str;
--}
--
--/// Guardian container interface
--pub trait GuardianContainer: Container {
--    /// Start the boot process
--    fn start_boot(&self) -> Result<(), ValidatorError>;
--    
--    /// Verify attestation
--    fn verify_attestation(&self) -> Result<bool, ValidatorError>;
--}
-\ No newline at end of file
-diff --git a/crates/core/src/validator/mod.rs b/crates/core/src/validator/mod.rs
-index d7c8d33..ef62152 100644
---- a/crates/core/src/validator/mod.rs
-+++ b/crates/core/src/validator/mod.rs
-@@ -1,10 +1,63 @@
--//! Validator architecture trait definitions
-+// Path: crates/core/src/validator/mod.rs
- 
--mod container;
--mod types;
-+use crate::{
-+    config::WorkloadConfig,
-+    error::ValidatorError,
-+    state::{StateManager, StateTree},
-+};
-+use std::fmt::Debug;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
- 
--#[cfg(test)]
--mod tests;
-+// FIX: Declare the container module so it's part of the `validator` module.
-+pub mod container;
- 
--pub use container::*;
--pub use types::*;
-+// FIX: Publicly re-export the traits using a relative path.
-+pub use container::{Container, GuardianContainer};
-+
-+/// A container responsible for executing transactions and managing state.
-+#[derive(Debug)]
-+pub struct WorkloadContainer<ST: StateManager> {
-+    _config: WorkloadConfig,
-+    state_tree: Arc<Mutex<ST>>,
-+}
-+
-+impl<ST> WorkloadContainer<ST>
-+where
-+    ST: StateManager,
-+{
-+    pub fn new(config: WorkloadConfig, state_tree: ST) -> Self {
-+        Self {
-+            _config: config,
-+            state_tree: Arc::new(Mutex::new(state_tree)),
-+        }
-+    }
-+
-+    pub fn state_tree(&self) -> Arc<Mutex<ST>> {
-+        self.state_tree.clone()
-+    }
-+}
-+
-+#[async_trait::async_trait]
-+impl<ST> Container for WorkloadContainer<ST>
-+where
-+    ST: StateManager + StateTree + Send + Sync + 'static,
-+{
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!("WorkloadContainer started.");
-+        Ok(())
-+    }
-+
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("WorkloadContainer stopped.");
-+        Ok(())
-+    }
-+
-+    fn is_running(&self) -> bool {
-+        true
-+    }
-+
-+    fn id(&self) -> &'static str {
-+        "workload_container"
-+    }
-+}
-\ No newline at end of file
-diff --git a/crates/core/src/validator/types.rs b/crates/core/src/validator/types.rs
-index bc5af6a..90e5337 100644
---- a/crates/core/src/validator/types.rs
-+++ b/crates/core/src/validator/types.rs
-@@ -3,17 +3,24 @@ use crate::error::ValidatorError;
- 
- /// Validator model trait
- pub trait ValidatorModel {
-+    /// An associated type representing the specific WorkloadContainer implementation this validator uses.
-+    /// This allows us to access it generically without knowing the validator's concrete type.
-+    type WorkloadContainerType;
-+
-     /// Start the validator
-     fn start(&self) -> Result<(), ValidatorError>;
--    
-+
-     /// Stop the validator
-     fn stop(&self) -> Result<(), ValidatorError>;
--    
-+
-     /// Check if the validator is running
-     fn is_running(&self) -> bool;
--    
-+
-     /// Get the validator type
-     fn validator_type(&self) -> ValidatorType;
-+
-+    /// Provides generic access to the validator's workload container.
-+    fn workload_container(&self) -> &Self::WorkloadContainerType;
- }
- 
- /// Validator types
-diff --git a/crates/homomorphic/Cargo.toml b/crates/homomorphic/Cargo.toml
-index 906a36e..fd48aa9 100644
---- a/crates/homomorphic/Cargo.toml
-+++ b/crates/homomorphic/Cargo.toml
-@@ -11,9 +11,6 @@ depin-sdk-commitment-schemes = { path = "../commitment_schemes" }
- log = { workspace = true }
- serde = { workspace = true }
- thiserror = { workspace = true }
--rand = "0.8"
--sha2 = "0.10"
--curve25519-dalek = "4.0"
- 
- [features]
- default = []
-diff --git a/crates/homomorphic/src/proof.rs b/crates/homomorphic/src/proof.rs
-index 9cf856a..bf776a6 100644
---- a/crates/homomorphic/src/proof.rs
-+++ b/crates/homomorphic/src/proof.rs
-@@ -1,9 +1,9 @@
- use crate::error::{HomomorphicError, HomomorphicResult};
- use depin_sdk_core::commitment::HomomorphicCommitmentScheme;
- use depin_sdk_core::commitment::HomomorphicOperation;
--use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-+// FIX: Remove unused imports.
-+use depin_sdk_core::commitment::{ProofContext, Selector};
- use depin_sdk_core::homomorphic::CommitmentOperation;
--use std::collections::HashMap;
- use std::fmt::Debug;
- use std::marker::PhantomData;
- 
-@@ -354,4 +354,4 @@ impl<CS: HomomorphicCommitmentScheme> ProofGenerator<CS> {
-             )),
-         }
-     }
--}
-+}
-\ No newline at end of file
-diff --git a/crates/state_trees/src/file/mod.rs b/crates/state_trees/src/file/mod.rs
-index 88f0c7d..2f439b7 100644
---- a/crates/state_trees/src/file/mod.rs
-+++ b/crates/state_trees/src/file/mod.rs
-@@ -1,133 +1,135 @@
--use depin_sdk_core::commitment::CommitmentScheme;
-+// Path: crates/state_trees/src/file/mod.rs
-+
-+use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
- use depin_sdk_core::error::StateError;
- use depin_sdk_core::state::{StateManager, StateTree};
--use crate::HashMapStateTree;
- use serde::{Deserialize, Serialize};
-+use std::any::Any;
- use std::collections::HashMap;
--use std::fs;
-+use std::fs::{File, OpenOptions};
-+use std::io::{self};
-+use std::marker::PhantomData;
- use std::path::{Path, PathBuf};
--use std::any::Any;
--use std::sync::{Arc, RwLock};
- 
--// A serializable representation of the state, using hex strings for keys and values.
--#[derive(Serialize, Deserialize, Default)]
--struct SerializableState(HashMap<String, String>);
--
--/// A state tree that persists its state to a JSON file.
--/// It wraps an in-memory HashMapStateTree and adds load/save functionality.
--pub struct FileStateTree<CS: CommitmentScheme + Clone>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--{
--    // The inner, in-memory state tree.
--    inner: HashMapStateTree<CS>,
--    // Path to the state file on disk.
-+/// A simple, file-backed state tree implementation for demonstration purposes.
-+/// It uses a HashMap internally and serializes to a JSON file.
-+///
-+/// FIX: The internal HashMap now uses `String` for keys to be compatible with
-+/// the JSON format, which requires string keys for objects. Binary keys are
-+/// hex-encoded before being used with the map.
-+#[derive(Serialize, Deserialize, Debug)]
-+pub struct FileStateTree<C: CommitmentScheme> {
-     path: PathBuf,
--    // We use an Arc<RwLock<()>> as a simple, cheap way to prevent saves
--    // from happening concurrently, which could corrupt the file.
--    save_lock: Arc<RwLock<()>>,
-+    #[serde(skip, default)]
-+    scheme: C,
-+    // FIX: Changed key type from Vec<u8> to String.
-+    data: HashMap<String, Vec<u8>>,
-+    #[serde(skip)]
-+    _phantom: PhantomData<C::Value>,
- }
- 
--impl<CS: CommitmentScheme + Clone> FileStateTree<CS>
-+impl<C> FileStateTree<C>
- where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+    C: CommitmentScheme + Clone + Default,
-+    C::Value: From<Vec<u8>>,
- {
--    /// Creates a new FileStateTree.
--    ///
--    /// It attempts to load the initial state from the file at `path`.
--    /// If the file doesn't exist, it starts with an empty state.
--    pub fn new<P: AsRef<Path>>(path: P, scheme: CS) -> Self {
--        let mut tree = Self {
--            inner: HashMapStateTree::new(scheme),
--            path: path.as_ref().to_path_buf(),
--            save_lock: Arc::new(RwLock::new(())),
--        };
--
--        if let Err(e) = tree.load() {
--            // Log a warning if loading fails, but don't panic.
--            // This allows the node to start fresh if the state file is corrupted or unreadable.
--            eprintln!("[Warning] Failed to load state from {:?}: {}. Starting with a fresh state.", tree.path, e);
--        }
--        tree
--    }
--
--    /// Loads the state from the JSON file.
--    pub fn load(&mut self) -> Result<(), StateError> {
--        if !self.path.exists() {
--            println!("State file not found at {:?}, starting new state.", self.path);
--            return Ok(());
--        }
--
--        let json_data = fs::read_to_string(&self.path)
--            .map_err(|e| StateError::ReadError(e.to_string()))?;
--            
--        let serializable_map: SerializableState = serde_json::from_str(&json_data)
--            .map_err(|e| StateError::ReadError(format!("JSON deserialization error: {}", e)))?;
--
--        self.inner.data.clear();
--        for (k_hex, v_hex) in serializable_map.0 {
--            let k = hex::decode(&k_hex)
--                .map_err(|e| StateError::InvalidKey(format!("Hex decode error: {}", e)))?;
--            let v_bytes = hex::decode(&v_hex)
--                .map_err(|e| StateError::InvalidValue(format!("Hex decode error: {}", e)))?;
--            
--            self.inner.data.insert(k, CS::Value::from(v_bytes));
--        }
--
--        println!("Successfully loaded state with {} entries from {:?}", self.inner.data.len(), self.path);
--        Ok(())
--    }
--
--    /// Saves the current state to the JSON file.
--    pub fn save(&self) -> Result<(), StateError> {
--        // Acquire a write lock to ensure only one save operation happens at a time.
--        let _lock = self.save_lock.write().unwrap();
--
--        let mut serializable_map = SerializableState::default();
--        for (k, v) in &self.inner.data {
--            serializable_map.0.insert(hex::encode(k), hex::encode(v.as_ref()));
--        }
--
--        let json_data = serde_json::to_string_pretty(&serializable_map)
--            .map_err(|e| StateError::WriteError(e.to_string()))?;
--        
--        fs::write(&self.path, json_data)
--            .map_err(|e| StateError::WriteError(e.to_string()))?;
--
--        Ok(())
-+    pub fn new<P: AsRef<Path>>(path: P, scheme: C) -> Self {
-+        let path_buf = path.as_ref().to_path_buf();
-+        Self::load(&path_buf, scheme.clone()).unwrap_or_else(|_| Self {
-+            path: path_buf,
-+            scheme,
-+            data: HashMap::new(),
-+            _phantom: PhantomData,
-+        })
-+    }
-+
-+    fn load<P: AsRef<Path>>(path: P, scheme: C) -> io::Result<Self> {
-+        let file = File::open(path)?;
-+        let mut loaded: Self = serde_json::from_reader(file)
-+            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
-+        loaded.scheme = scheme;
-+        Ok(loaded)
-+    }
-+
-+    fn save(&self) -> io::Result<()> {
-+        let file = OpenOptions::new()
-+            .write(true)
-+            .create(true)
-+            .truncate(true)
-+            .open(&self.path)?;
-+        serde_json::to_writer_pretty(file, self)
-+            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))
-     }
- }
- 
--// Delegate StateTree and StateManager traits to the inner HashMapStateTree.
--impl<CS: CommitmentScheme + Clone> StateTree for FileStateTree<CS>
-+impl<C> StateTree for FileStateTree<C>
- where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+    C: CommitmentScheme + Clone + Send + Sync + Default,
-+    C::Value: From<Vec<u8>>,
- {
--    type Commitment = CS::Commitment;
--    type Proof = CS::Proof;
-+    type Commitment = C::Commitment;
-+    type Proof = C::Proof;
- 
-     fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        StateTree::get(&self.inner, key)
-+        // FIX: Hex-encode the key for lookup.
-+        let key_hex = hex::encode(key);
-+        Ok(self.data.get(&key_hex).cloned())
-     }
- 
-     fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        StateTree::insert(&mut self.inner, key, value)
-+        // FIX: Hex-encode the key before insertion.
-+        let key_hex = hex::encode(key);
-+        self.data.insert(key_hex, value.to_vec());
-+        self.save()
-+            .map_err(|e| StateError::WriteError(e.to_string()))
-     }
- 
-     fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        StateTree::delete(&mut self.inner, key)
-+        // FIX: Hex-encode the key for removal.
-+        let key_hex = hex::encode(key);
-+        self.data.remove(&key_hex);
-+        self.save()
-+            .map_err(|e| StateError::WriteError(e.to_string()))
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        StateTree::root_commitment(&self.inner)
--    }
-+        let mut values_to_sort = self.data.values().cloned().collect::<Vec<_>>();
-+        values_to_sort.sort();
- 
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        StateTree::create_proof(&self.inner, key)
-+        let values_to_commit: Vec<Option<C::Value>> = values_to_sort
-+            .into_iter()
-+            .map(|v| Some(C::Value::from(v)))
-+            .collect();
-+
-+        self.scheme.commit(&values_to_commit)
-     }
- 
--    fn verify_proof(&self, commitment: &Self::Commitment, proof: &Self::Proof, key: &[u8], value: &[u8]) -> bool {
--        StateTree::verify_proof(&self.inner, commitment, proof, key, value)
-+    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-+        // FIX: Hex-encode the key for lookup.
-+        let key_hex = hex::encode(key);
-+        let value = self.data.get(&key_hex)?;
-+        self.scheme
-+            .create_proof(
-+                &Selector::Key(key.to_vec()),
-+                &C::Value::from(value.clone()),
-+            )
-+            .ok()
-+    }
-+
-+    fn verify_proof(
-+        &self,
-+        commitment: &Self::Commitment,
-+        proof: &Self::Proof,
-+        key: &[u8],
-+        value: &[u8],
-+    ) -> bool {
-+        self.scheme.verify(
-+            commitment,
-+            proof,
-+            &Selector::Key(key.to_vec()),
-+            &C::Value::from(value.to_vec()),
-+            &ProofContext::default(),
-+        )
-     }
- 
-     fn as_any(&self) -> &dyn Any {
-@@ -135,48 +137,31 @@ where
-     }
- }
- 
--impl<CS: CommitmentScheme + Clone> StateManager for FileStateTree<CS>
-+impl<C> StateManager for FileStateTree<C>
- where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
-+    C: CommitmentScheme + Clone + Send + Sync + Default,
-+    C::Commitment: Send + Sync,
-+    C::Proof: Send + Sync,
-+    C::Value: From<Vec<u8>> + Send + Sync,
- {
--    type Commitment = CS::Commitment;
--    type Proof = CS::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        <Self as StateTree>::get(self, key)
--    }
--
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::insert(self, key, value)
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::delete(self, key)
--    }
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            // FIX: Hex-encode each key before batch insertion.
-+            let key_hex = hex::encode(key);
- 
--    fn root_commitment(&self) -> Self::Commitment {
--        <Self as StateTree>::root_commitment(self)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        <Self as StateTree>::create_proof(self, key)
--    }
--
--    fn verify_proof(&self, commitment: &Self::Commitment, proof: &Self::Proof, key: &[u8], value: &[u8]) -> bool {
--        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
-+            self.data.insert(key_hex, value.to_vec());
-+        }
-+        self.save()
-+            .map_err(|e| StateError::WriteError(e.to_string()))
-     }
--}
- 
--// Automatically save the state when the FileStateTree is dropped.
--// This is a safety net for graceful shutdowns.
--impl<CS: CommitmentScheme + Clone> Drop for FileStateTree<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--{
--    fn drop(&mut self) {
--        println!("Shutting down... saving final state to {:?}", self.path);
--        if let Err(e) = self.save() {
--            eprintln!("[Error] Failed to save state on shutdown: {}", e);
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut values = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            // FIX: Hex-encode each key for batch lookup.
-+            let key_hex = hex::encode(key);
-+            values.push(self.data.get(&key_hex).cloned());
-         }
-+        Ok(values)
-     }
- }
-\ No newline at end of file
-diff --git a/crates/state_trees/src/hashmap/mod.rs b/crates/state_trees/src/hashmap/mod.rs
-index 6605c43..de0ca43 100644
---- a/crates/state_trees/src/hashmap/mod.rs
-+++ b/crates/state_trees/src/hashmap/mod.rs
-@@ -64,10 +64,7 @@ where
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        // Fixed ambiguous method call by explicitly specifying which trait's method to use
--        let value = <Self as StateTree>::get(self, key)
--            .ok()?
--            .map(|v| self.to_value(&v))?;
-+        let value = self.get(key).ok()?.map(|v| self.to_value(&v))?;
-         let selector = Selector::Key(key.to_vec());
-         self.scheme.create_proof(&selector, &value).ok()
-     }
-@@ -96,36 +93,19 @@ impl<CS: CommitmentScheme> StateManager for HashMapStateTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    type Commitment = CS::Commitment;
--    type Proof = CS::Proof;
--
--    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        <Self as StateTree>::get(self, key)
--    }
--
--    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::insert(self, key, value)
--    }
--
--    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--        <Self as StateTree>::delete(self, key)
--    }
--
--    fn root_commitment(&self) -> Self::Commitment {
--        <Self as StateTree>::root_commitment(self)
--    }
--
--    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        <Self as StateTree>::create_proof(self, key)
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            let value_typed = self.to_value(value);
-+            self.data.insert(key.to_vec(), value_typed);
-+        }
-+        Ok(())
-     }
- 
--    fn verify_proof(
--        &self,
--        commitment: &Self::Commitment,
--        proof: &Self::Proof,
--        key: &[u8],
--        value: &[u8],
--    ) -> bool {
--        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut values = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            values.push(self.data.get(key).map(|v| v.as_ref().to_vec()));
-+        }
-+        Ok(values)
-     }
--}
-+}
-\ No newline at end of file
-diff --git a/crates/state_trees/src/iavl/mod.rs b/crates/state_trees/src/iavl/mod.rs
-index ab125d7..41424a0 100644
---- a/crates/state_trees/src/iavl/mod.rs
-+++ b/crates/state_trees/src/iavl/mod.rs
-@@ -45,7 +45,6 @@ where
-     type Proof = CS::Proof;
- 
-     fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        // Convert to the appropriate value type for this commitment scheme
-         let scheme_value = self.to_value(value);
-         self.data.insert(key.to_vec(), scheme_value);
-         Ok(())
-@@ -61,18 +60,13 @@ where
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        // Convert data to format expected by commitment scheme
-         let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-         self.scheme.commit(&values)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-         let value = self.data.get(key)?;
--
--        // Create a key-based selector for the proof
-         let selector = Selector::Key(key.to_vec());
--
--        // Create the proof using the selector
-         self.scheme.create_proof(&selector, value).ok()
-     }
- 
-@@ -83,16 +77,9 @@ where
-         key: &[u8],
-         value: &[u8],
-     ) -> bool {
--        // Create a key-based selector for verification
-         let selector = Selector::Key(key.to_vec());
--
--        // Create an empty context for now
-         let context = ProofContext::default();
--
--        // Convert the raw value to the scheme's value type
-         let scheme_value = self.to_value(value);
--
--        // Verify the proof using the selector and context
-         self.scheme
-             .verify(commitment, proof, &selector, &scheme_value, &context)
-     }
-@@ -102,50 +89,23 @@ where
-     }
- }
- 
--// Add support for tree-specific operations for IAVL
--impl<CS: CommitmentScheme> IAVLTree<CS>
-+// FIX: Implement the StateManager trait.
-+impl<CS: CommitmentScheme> StateManager for IAVLTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    /// Get the height of the tree
--    pub fn height(&self) -> usize {
--        // This would be a real implementation in a complete IAVL tree
--        // For now, we just return a placeholder value
--        let size = self.data.len();
--        if size == 0 {
--            0
--        } else {
--            (size as f64).log2().ceil() as usize
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            self.insert(key, value)?;
-         }
-+        Ok(())
-     }
- 
--    /// Get the number of nodes in the tree
--    pub fn size(&self) -> usize {
--        self.data.len()
--    }
--
--    /// Check if the tree is balanced
--    pub fn is_balanced(&self) -> bool {
--        // This would be a real implementation in a complete IAVL tree
--        // For now, we just return true
--        true
--    }
--
--    /// Create a proof with additional path information
--    pub fn create_path_proof(&self, key: &[u8]) -> Option<(CS::Proof, Vec<Vec<u8>>)> {
--        // This would create a proof with the complete path from root to leaf
--        let value = self.data.get(key)?;
--
--        // Create a key-based selector
--        let selector = Selector::Key(key.to_vec());
--
--        // Create the proof
--        let proof = self.scheme.create_proof(&selector, value).ok()?;
--
--        // In a real implementation, we would compute the path
--        // For now, we just return an empty path
--        let path = Vec::new();
--
--        Some((proof, path))
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut results = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            results.push(self.get(key)?);
-+        }
-+        Ok(results)
-     }
- }
-\ No newline at end of file
-diff --git a/crates/state_trees/src/lib.rs b/crates/state_trees/src/lib.rs
-index d54abfe..6dc5f41 100644
---- a/crates/state_trees/src/lib.rs
-+++ b/crates/state_trees/src/lib.rs
-@@ -2,20 +2,15 @@
- //!
- //! Implementations of various state tree structures for the DePIN SDK.
- 
-+pub mod file;
- pub mod hashmap;
- pub mod iavl;
- pub mod sparse_merkle;
- pub mod verkle;
--pub mod file;
- 
- // Re-export concrete implementations for convenience
- pub use file::FileStateTree;
- pub use hashmap::HashMapStateTree;
- pub use iavl::IAVLTree;
- pub use sparse_merkle::SparseMerkleTree;
--pub use verkle::VerkleTree;
--
--// Import core traits for use in the implementations
--use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::state::StateTree;
--use std::any::Any;
-\ No newline at end of file
-+pub use verkle::VerkleTree;
-\ No newline at end of file
-diff --git a/crates/state_trees/src/sparse_merkle/mod.rs b/crates/state_trees/src/sparse_merkle/mod.rs
-index 0c9261d..56af1df 100644
---- a/crates/state_trees/src/sparse_merkle/mod.rs
-+++ b/crates/state_trees/src/sparse_merkle/mod.rs
-@@ -26,7 +26,6 @@ where
-         }
-     }
- 
--    /// Helper to convert raw bytes to the commitment scheme's Value type
-     fn to_value(&self, bytes: &[u8]) -> CS::Value {
-         CS::Value::from(bytes.to_vec())
-     }
-@@ -55,20 +54,14 @@ where
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        // Convert data to format expected by commitment scheme
-         let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-         self.scheme.commit(&values)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--        // Get the value as an Option<Vec<u8>>
-         let value_result = self.get(key).ok()?;
-         let value = value_result?;
--        
--        // Now convert value to the typed value and create the proof
-         let value_typed = self.to_value(&value);
--
--        // Use key-based selector for sparse Merkle trees
-         self.scheme
-             .create_proof(&Selector::Key(key.to_vec()), &value_typed)
-             .ok()
-@@ -82,11 +75,7 @@ where
-         value: &[u8],
-     ) -> bool {
-         let value_typed = self.to_value(value);
--
--        // Create context (empty for now, could be extended with tree-specific data)
-         let context = ProofContext::default();
--
--        // Use key-based selector for verification
-         self.scheme.verify(
-             commitment,
-             proof,
-@@ -97,44 +86,27 @@ where
-     }
- 
-     fn as_any(&self) -> &dyn Any {
--        self        
-+        self
-     }
- }
- 
--// Add some utility methods for sparse Merkle trees
--impl<CS: CommitmentScheme> SparseMerkleTree<CS>
-+// FIX: Implement the StateManager trait.
-+impl<CS: CommitmentScheme> StateManager for SparseMerkleTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    /// Get the number of key-value pairs in the tree
--    pub fn len(&self) -> usize {
--        self.data.len()
--    }
--
--    /// Check if the tree is empty
--    pub fn is_empty(&self) -> bool {
--        self.data.is_empty()
--    }
--
--    /// Get all keys in the tree
--    pub fn keys(&self) -> Vec<Vec<u8>> {
--        self.data.keys().cloned().collect()
--    }
--
--    /// Clear all data in the tree
--    pub fn clear(&mut self) {
--        self.data.clear()
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            self.insert(key, value)?;
-+        }
-+        Ok(())
-     }
- 
--    /// Create a proof for multiple keys at once
--    pub fn create_multi_proof(&self, keys: &[&[u8]]) -> HashMap<Vec<u8>, Option<CS::Proof>> {
--        let mut proofs = HashMap::new();
--
--        for &key in keys {
--            let proof = self.create_proof(key);
--            proofs.insert(key.to_vec(), proof);
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut results = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            results.push(self.get(key)?);
-         }
--
--        proofs
-+        Ok(results)
-     }
- }
-\ No newline at end of file
-diff --git a/crates/state_trees/src/verkle/mod.rs b/crates/state_trees/src/verkle/mod.rs
-index b908468..7c3bee2 100644
---- a/crates/state_trees/src/verkle/mod.rs
-+++ b/crates/state_trees/src/verkle/mod.rs
-@@ -58,7 +58,6 @@ where
-     type Proof = CS::Proof;
- 
-     fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--        // Convert value to the appropriate type for the commitment scheme
-         let cs_value = self
-             .convert_value(value)
-             .map_err(|e| StateError::InvalidValue(e))?;
-@@ -67,7 +66,6 @@ where
-     }
- 
-     fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--        // Convert back from CS::Value to Vec<u8>
-         Ok(self.data.get(key).map(|v| self.extract_value(v)))
-     }
- 
-@@ -77,15 +75,12 @@ where
-     }
- 
-     fn root_commitment(&self) -> Self::Commitment {
--        // Convert data to format expected by commitment scheme
-         let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
-         self.scheme.commit(&values)
-     }
- 
-     fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
-         let value = self.data.get(key)?;
--
--        // Create a key-based proof using the new selector API
-         self.scheme
-             .create_proof(&Selector::Key(key.to_vec()), value)
-             .ok()
-@@ -98,18 +93,12 @@ where
-         key: &[u8],
-         value: &[u8],
-     ) -> bool {
--        // Convert value to the appropriate type
-         if let Ok(cs_value) = self.convert_value(value) {
--            // Create verification context with additional data if needed
-             let mut context = ProofContext::new();
--
--            // For Verkle trees, we might need the branching factor in the context
-             context.add_data(
-                 "branching_factor",
-                 self.branching_factor.to_le_bytes().to_vec(),
-             );
--
--            // Use Key selector for verification
-             self.scheme.verify(
-                 commitment,
-                 proof,
-@@ -123,27 +112,40 @@ where
-     }
- 
-     fn as_any(&self) -> &dyn Any {
--        self        
-+        self
-+    }
-+}
-+
-+// FIX: Implement the StateManager trait.
-+impl<CS: CommitmentScheme> StateManager for VerkleTree<CS>
-+where
-+    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
-+{
-+    fn batch_set(&mut self, updates: &[(Vec<u8>, Vec<u8>)]) -> Result<(), StateError> {
-+        for (key, value) in updates {
-+            self.insert(key, value)?;
-+        }
-+        Ok(())
-+    }
-+
-+    fn batch_get(&self, keys: &[Vec<u8>]) -> Result<Vec<Option<Vec<u8>>>, StateError> {
-+        let mut results = Vec::with_capacity(keys.len());
-+        for key in keys {
-+            results.push(self.get(key)?);
-+        }
-+        Ok(results)
-     }
- }
- 
--// Helper methods to convert between Vec<u8> and CS::Value
- impl<CS: CommitmentScheme> VerkleTree<CS>
- where
-     CS::Value: From<Vec<u8>> + AsRef<[u8]>,
- {
--    /// Convert a Vec<u8> to CS::Value
-     fn convert_value(&self, value: &[u8]) -> Result<CS::Value, String> {
-         Ok(CS::Value::from(value.to_vec()))
-     }
- 
--    /// Extract a Vec<u8> from CS::Value
-     fn extract_value(&self, value: &CS::Value) -> Vec<u8> {
-         value.as_ref().to_vec()
-     }
--
--    /// Create a CS::Value from bytes - implement appropriate conversion logic
--    fn create_cs_value(&self, bytes: &[u8]) -> Result<CS::Value, String> {
--        Ok(CS::Value::from(bytes.to_vec()))
--    }
- }
-\ No newline at end of file
-diff --git a/crates/transaction_models/Cargo.toml b/crates/transaction_models/Cargo.toml
-index 90ea83c..966ff6d 100644
---- a/crates/transaction_models/Cargo.toml
-+++ b/crates/transaction_models/Cargo.toml
-@@ -6,17 +6,14 @@ description = "Transaction model implementations for the DePIN SDK"
- license = "MIT OR Apache-2.0"
- 
- [dependencies]
--depin-sdk-crypto = { path = "../crypto", optional = true }
- depin-sdk-core = { path = "../core" }
- log = { workspace = true }
--serde = { workspace = true }
-+serde = { workspace = true, features = ["derive"] }
-+serde_json = { workspace = true }
- thiserror = { workspace = true }
--bytes = { workspace = true }
--anyhow = { workspace = true }
--
-+sha2 = { workspace = true }
-+# FIX: Add the missing 'hex' dependency used for logging UTXO hashes.
-+hex = { workspace = true }
- 
- [features]
--default = ["dep:depin-sdk-crypto"]
--utxo-model = []
--account-model = []
--hybrid-model = []
-+default = []
-diff --git a/crates/transaction_models/src/account/mod.rs b/crates/transaction_models/src/account/mod.rs
-index 9ce6bcd..42dc184 100644
---- a/crates/transaction_models/src/account/mod.rs
-+++ b/crates/transaction_models/src/account/mod.rs
-@@ -1,504 +1,179 @@
--//! Account-based transaction model implementation.
--
-+// Path: crates/transaction_models/src/account/mod.rs
- 
- use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::TransactionError;
-+use depin_sdk_core::error::{StateError, TransactionError};
- use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use std::any::Any;
--use std::collections::HashMap;
-+use serde::{Deserialize, Serialize};
- 
--/// Account transaction
--#[derive(Debug, Clone)]
-+// FIX: Add derive macros for PartialEq and Eq, required by HybridTransaction.
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
- pub struct AccountTransaction {
--    /// Transaction ID
--    pub txid: Vec<u8>,
--    /// Sender account
-     pub from: Vec<u8>,
--    /// Receiver account
-     pub to: Vec<u8>,
--    /// Value to transfer
--    pub value: u64,
--    /// Nonce to prevent replay
-+    pub amount: u64,
-     pub nonce: u64,
--    /// Signature from sender
--    pub signature: Vec<u8>,
--}
--
--/// Account proof for transaction verification
--#[derive(Debug, Clone)]
--pub struct AccountProof {
--    /// Proof for sender's account
--    pub sender_proof: Vec<u8>,
--    /// Proof for sender's nonce
--    pub nonce_proof: Vec<u8>,
--    /// Additional data for verification
--    pub metadata: HashMap<String, Vec<u8>>,
- }
- 
--/// Account state stored in the state manager
--#[derive(Debug, Clone)]
--pub struct AccountState {
--    /// Account balance
-+#[derive(Serialize, Deserialize, Debug, Clone)]
-+pub struct Account {
-     pub balance: u64,
--    /// Account nonce (for replay protection)
-     pub nonce: u64,
- }
- 
--/// Account-specific operations
--pub trait AccountOperations {
--    /// Create a key for an account in the state store.
--    ///
--    /// # Arguments
--    /// * `account` - Account identifier.
--    ///
--    /// # Returns
--    /// * `Ok(key)` - The generated key.
--    /// * `Err(TransactionError)` - If key creation failed.
--    fn create_account_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError>;
--
--    /// Create a key for an account nonce in the state store.
--    ///
--    /// # Arguments
--    /// * `account` - Account identifier.
--    ///
--    /// # Returns
--    /// * `Ok(key)` - The generated key.
--    /// * `Err(TransactionError)` - If key creation failed.
--    fn create_nonce_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError>;
--}
--
--/// Account model configuration
--#[derive(Clone)]
-+// FIX: Add derive(Debug) as required by HybridConfig.
-+#[derive(Debug, Clone, Default)]
- pub struct AccountConfig {
--    /// Maximum transaction value
--    pub max_value: u64,
--    /// Initial balance for new accounts (if auto-create is enabled)
-     pub initial_balance: u64,
--    /// Whether to automatically create accounts on first receive
--    pub auto_create_accounts: bool,
--}
--
--impl Default for AccountConfig {
--    fn default() -> Self {
--        Self {
--            max_value: u64::MAX,
--            initial_balance: 0,
--            auto_create_accounts: true,
--        }
--    }
- }
- 
--/// Account transaction model implementation
-+// FIX: Add derive(Debug, Clone) as required by HybridModel.
-+#[derive(Debug, Clone)]
- pub struct AccountModel<CS: CommitmentScheme> {
--    /// Model configuration
-     config: AccountConfig,
--    /// Commitment scheme
--    scheme: CS,
-+    _commitment_scheme: CS,
- }
- 
--impl<CS: CommitmentScheme> AccountModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    /// Create a new account model with default configuration.
--    pub fn new(scheme: CS) -> Self {
-+impl<CS: CommitmentScheme> AccountModel<CS> {
-+    pub fn new(commitment_scheme: CS) -> Self {
-         Self {
-             config: AccountConfig::default(),
--            scheme,
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
- 
--    /// Create a new account model with custom configuration.
--    pub fn with_config(scheme: CS, config: AccountConfig) -> Self {
-+    pub fn with_config(commitment_scheme: CS, config: AccountConfig) -> Self {
-         Self {
-             config,
--            scheme,
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
- 
--    /// Get model configuration.
--    pub fn config(&self) -> &AccountConfig {
--        &self.config
--    }
--
--    /// Get the commitment scheme
--    pub fn scheme(&self) -> &CS {
--        &self.scheme
--    }
--
--    /// Convert a value to the commitment scheme's value type
--    fn to_value(&self, bytes: &[u8]) -> CS::Value {
--        CS::Value::from(bytes.to_vec())
--    }
--
--    /// Helper method to get an account from the state.
--    fn get_account<S>(
--        &self,
--        state: &S,
--        account: &[u8],
--    ) -> Result<Option<AccountState>, TransactionError>
--    where
--        S: StateManager<
--            Commitment = CS::Commitment,
--            Proof = CS::Proof,
--        > + ?Sized,
--    {
--        let key = self.create_account_key(account)?;
--        let value = state
--            .get(&key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--
-+    fn get_account<S: StateManager + ?Sized>(&self, state: &S, key: &[u8]) -> Result<Account, TransactionError> {
-+        let value = state.get(key)?;
-         match value {
-             Some(data) => self.decode_account(&data),
--            None => Ok(None),
-+            None => Ok(Account {
-+                balance: self.config.initial_balance,
-+                nonce: 0,
-+            }),
-         }
-     }
- 
--    /// Helper method to decode an account from bytes.
--    fn decode_account(&self, data: &[u8]) -> Result<Option<AccountState>, TransactionError> {
--        if data.len() < 16 {
--            return Err(TransactionError::SerializationError(
--                "Account data too short".to_string(),
--            ));
--        }
--
--        let mut balance_bytes = [0u8; 8];
--        balance_bytes.copy_from_slice(&data[0..8]);
--        let balance = u64::from_le_bytes(balance_bytes);
--
--        let mut nonce_bytes = [0u8; 8];
--        nonce_bytes.copy_from_slice(&data[8..16]);
--        let nonce = u64::from_le_bytes(nonce_bytes);
--
--        Ok(Some(AccountState { balance, nonce }))
-+    fn decode_account(&self, data: &[u8]) -> Result<Account, TransactionError> {
-+        // FIX: Use the correct `Serialization` variant.
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
--    /// Helper method to encode an account to bytes.
--    fn encode_account(&self, account: &AccountState) -> Vec<u8> {
--        let mut data = Vec::with_capacity(16);
--        data.extend_from_slice(&account.balance.to_le_bytes());
--        data.extend_from_slice(&account.nonce.to_le_bytes());
--        data
-+    fn encode_account(&self, account: &Account) -> Vec<u8> {
-+        serde_json::to_vec(account).unwrap()
-     }
- }
- 
--impl<CS: CommitmentScheme> TransactionModel for AccountModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
-+impl<CS: CommitmentScheme + Send + Sync> TransactionModel for AccountModel<CS> {
-     type Transaction = AccountTransaction;
--    type Proof = AccountProof;
-     type CommitmentScheme = CS;
-+    type Proof = ();
- 
-+    // FIX: Add the required `where` clause to the method signature.
-     fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Check transaction structure
--        if tx.value == 0 {
--            return Ok(false);
-+        let sender_account = self.get_account(state, &tx.from)?;
-+        if sender_account.balance < tx.amount {
-+            // FIX: Use the correct `Invalid` variant.
-+            return Err(TransactionError::Invalid("Insufficient balance".to_string()));
-         }
--
--        if tx.value > self.config.max_value {
--            return Ok(false);
--        }
--
--        // Get sender account
--        let sender = self.get_account(state, &tx.from)?;
--
--        match sender {
--            Some(account) => {
--                // Check balance
--                if account.balance < tx.value {
--                    return Ok(false);
--                }
--
--                // Check nonce
--                if account.nonce != tx.nonce {
--                    return Ok(false);
--                }
--
--                // TODO: Validate signature
--
--                Ok(true)
--            }
--            None => Ok(false), // Sender doesn't exist
-+        if sender_account.nonce != tx.nonce {
-+            return Err(TransactionError::Invalid("Invalid nonce".to_string()));
-         }
-+        Ok(true)
-     }
- 
-+    // FIX: Add the required `where` clause.
-     fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Validate transaction first
-+        // Since we now have `From<StateError>` for `TransactionError`, `?` works.
-         if !self.validate(tx, state)? {
--            return Err(TransactionError::InvalidTransaction(
--                "Transaction validation failed".to_string(),
--            ));
-+            // FIX: Use the correct `Invalid` variant.
-+            return Err(TransactionError::Invalid("Validation failed".to_string()));
-         }
- 
--        // Get sender account
--        let sender_key = self.create_account_key(&tx.from)?;
--        let sender = self.get_account(state, &tx.from)?.ok_or_else(|| {
--            TransactionError::InvalidTransaction("Sender account not found".to_string())
--        })?;
--
--        // Update sender account
--        let new_sender = AccountState {
--            balance: sender.balance - tx.value,
--            nonce: sender.nonce + 1,
--        };
--
--        state
--            .set(&sender_key, &self.encode_account(&new_sender))
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--
--        // Get or create receiver account
--        let receiver_key = self.create_account_key(&tx.to)?;
--        let receiver = match self.get_account(state, &tx.to)? {
--            Some(account) => account,
--            None => {
--                if !self.config.auto_create_accounts {
--                    return Err(TransactionError::InvalidTransaction(
--                        "Receiver account not found".to_string(),
--                    ));
--                }
--
--                AccountState {
--                    balance: self.config.initial_balance,
--                    nonce: 0,
--                }
--            }
--        };
-+        let sender_key = tx.from.clone();
-+        let mut sender_account = self.get_account(state, &sender_key)?;
-+        sender_account.balance -= tx.amount;
-+        sender_account.nonce += 1;
-+        state.insert(&sender_key, &self.encode_account(&sender_account))?;
- 
--        // Update receiver account
--        let new_receiver = AccountState {
--            balance: receiver.balance.checked_add(tx.value).ok_or_else(|| {
--                TransactionError::InvalidTransaction("Balance overflow".to_string())
--            })?,
--            nonce: receiver.nonce,
--        };
--
--        state
--            .set(&receiver_key, &self.encode_account(&new_receiver))
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
-+        let receiver_key = tx.to.clone();
-+        let mut receiver_account = self.get_account(state, &receiver_key)?;
-+        receiver_account.balance = receiver_account
-+            .balance
-+            .checked_add(tx.amount)
-+            // FIX: Use the correct `Invalid` variant.
-+            .ok_or(TransactionError::Invalid("Balance overflow".to_string()))?;
-+        state.insert(&receiver_key, &self.encode_account(&receiver_account))?;
- 
-         Ok(())
-     }
- 
-+    fn create_coinbase_transaction(
-+        &self,
-+        _block_height: u64,
-+        _recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError> {
-+        // Account models don't typically have coinbase transactions.
-+        Err(TransactionError::Invalid(
-+            "Coinbase not supported for account model".to_string(),
-+        ))
-+    }
-+
-+    // FIX: Add the required `where` clause.
-     fn generate_proof<S>(
-         &self,
--        tx: &Self::Transaction,
--        state: &S,
-+        _tx: &Self::Transaction,
-+        _state: &S,
-     ) -> Result<Self::Proof, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        let sender_key = self.create_account_key(&tx.from)?;
--        let nonce_key = self.create_nonce_key(&tx.from)?;
--
--        // In a real implementation, we would create cryptographic proofs
--        // For this example, we'll just get the raw account data
--        let sender_data = state
--            .get(&sender_key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?
--            .ok_or_else(|| {
--                TransactionError::InvalidInput("Sender account not found".to_string())
--            })?;
--
--        let nonce_data = state
--            .get(&nonce_key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?
--            .unwrap_or_else(|| vec![0; 8]); // Default nonce is 0
--
--        Ok(AccountProof {
--            sender_proof: sender_data,
--            nonce_proof: nonce_data,
--            metadata: HashMap::new(),
--        })
-+        Ok(())
-     }
- 
--    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-+    // FIX: Add the required `where` clause.
-+    fn verify_proof<S>(
-+        &self,
-+        _proof: &Self::Proof,
-+        _state: &S,
-+    ) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // In a real implementation, this would verify cryptographic proofs
--        // For this example, we'll just return true
-         Ok(true)
-     }
- 
-     fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        // Simple manual serialization for demonstration
--        let mut data = Vec::new();
--
--        // Serialize txid
--        data.extend_from_slice(&(tx.txid.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.txid);
--
--        // Serialize from
--        data.extend_from_slice(&(tx.from.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.from);
--
--        // Serialize to
--        data.extend_from_slice(&(tx.to.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.to);
--
--        // Serialize value and nonce
--        data.extend_from_slice(&tx.value.to_le_bytes());
--        data.extend_from_slice(&tx.nonce.to_le_bytes());
--
--        // Serialize signature
--        data.extend_from_slice(&(tx.signature.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.signature);
--
--        Ok(data)
-+        // FIX: Use the correct `Serialization` variant.
-+        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
-     fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        if data.len() < 4 {
--            return Err(TransactionError::SerializationError(
--                "Data too short".to_string(),
--            ));
--        }
--
--        let mut pos = 0;
--
--        // Deserialize txid
--        let txid_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + txid_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid txid length".to_string(),
--            ));
--        }
--
--        let txid = data[pos..pos + txid_len].to_vec();
--        pos += txid_len;
--
--        // Deserialize from
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let from_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + from_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid from length".to_string(),
--            ));
--        }
--
--        let from = data[pos..pos + from_len].to_vec();
--        pos += from_len;
--
--        // Deserialize to
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let to_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + to_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid to length".to_string(),
--            ));
--        }
--
--        let to = data[pos..pos + to_len].to_vec();
--        pos += to_len;
--
--        // Deserialize value and nonce
--        if pos + 16 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let mut value_bytes = [0u8; 8];
--        value_bytes.copy_from_slice(&data[pos..pos + 8]);
--        let value = u64::from_le_bytes(value_bytes);
--        pos += 8;
--
--        let mut nonce_bytes = [0u8; 8];
--        nonce_bytes.copy_from_slice(&data[pos..pos + 8]);
--        let nonce = u64::from_le_bytes(nonce_bytes);
--        pos += 8;
--
--        // Deserialize signature
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let signature_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + signature_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid signature length".to_string(),
--            ));
--        }
--
--        let signature = data[pos..pos + signature_len].to_vec();
--
--        Ok(AccountTransaction {
--            txid,
--            from,
--            to,
--            value,
--            nonce,
--            signature,
--        })
--    }
--
--    fn get_model_extensions(&self) -> Option<&dyn Any> {
--        Some(self as &dyn Any)
-+        // FIX: Use the correct `Deserialization` variant.
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-     }
--}
--
--impl<CS: CommitmentScheme> AccountOperations for AccountModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    fn create_account_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError> {
--        let mut key = Vec::with_capacity(account.len() + 1);
--        key.push(b'a'); // Prefix 'a' for account
--        key.extend_from_slice(account);
--        Ok(key)
--    }
--
--    fn create_nonce_key(&self, account: &[u8]) -> Result<Vec<u8>, TransactionError> {
--        let mut key = Vec::with_capacity(account.len() + 1);
--        key.push(b'n'); // Prefix 'n' for nonce
--        key.extend_from_slice(account);
--        Ok(key)
--    }
--}
--
--/// Helper function to read a u32 from a byte slice
--fn read_u32(data: &[u8]) -> u32 {
--    let mut bytes = [0u8; 4];
--    bytes.copy_from_slice(data);
--    u32::from_le_bytes(bytes)
- }
-\ No newline at end of file
-diff --git a/crates/transaction_models/src/account/mod.rs:131:8 b/crates/transaction_models/src/account/mod.rs:131:8
-deleted file mode 100644
-index e69de29..0000000
-diff --git a/crates/transaction_models/src/account/mod.rs:331:31 b/crates/transaction_models/src/account/mod.rs:331:31
-deleted file mode 100644
-index e69de29..0000000
-diff --git a/crates/transaction_models/src/account/mod.rs:331:52 b/crates/transaction_models/src/account/mod.rs:331:52
-deleted file mode 100644
-index e69de29..0000000
-diff --git a/crates/transaction_models/src/hybrid/mod.rs b/crates/transaction_models/src/hybrid/mod.rs
-index 36163bc..49f3fd9 100644
---- a/crates/transaction_models/src/hybrid/mod.rs
-+++ b/crates/transaction_models/src/hybrid/mod.rs
-@@ -1,130 +1,70 @@
--// Fixed implementation for hybrid transaction model
-+// Path: crates/transaction_models/src/hybrid/mod.rs
- 
--use crate::account::{AccountModel, AccountProof, AccountTransaction};
--use crate::utxo::{UTXOModel, UTXOProof, UTXOTransaction};
-+use crate::account::{AccountConfig, AccountModel, AccountTransaction};
-+use crate::utxo::{UTXOConfig, UTXOModel, UTXOTransaction};
- use depin_sdk_core::commitment::CommitmentScheme;
- use depin_sdk_core::error::TransactionError;
- use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use std::any::Any;
-+use serde::{Deserialize, Serialize};
- 
--/// Hybrid transaction that can be either UTXO or account-based
--#[derive(Debug, Clone)]
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
- pub enum HybridTransaction {
--    /// UTXO-based transaction
--    UTXO(UTXOTransaction),
--    /// Account-based transaction
-     Account(AccountTransaction),
-+    UTXO(UTXOTransaction),
- }
- 
--/// Hybrid proof that can be either UTXO or account-based
- #[derive(Debug, Clone)]
- pub enum HybridProof {
--    /// UTXO-based proof
--    UTXO(UTXOProof),
--    /// Account-based proof
--    Account(AccountProof),
-+    // FIX: Match the inner models' proof types, which are now `()`.
-+    Account(()),
-+    UTXO(()),
- }
- 
--/// Hybrid transaction model configuration
--#[derive(Clone)]
-+#[derive(Debug, Clone, Default)]
- pub struct HybridConfig {
--    /// UTXO model configuration
--    pub utxo_config: crate::utxo::UTXOConfig,
--    /// Account model configuration
--    pub account_config: crate::account::AccountConfig,
--    /// Whether to enforce fee payment in UTXO mode
--    pub require_fee: bool,
--    /// Minimum fee amount (if required)
--    pub min_fee: u64,
-+    pub account_config: AccountConfig,
-+    pub utxo_config: UTXOConfig,
- }
- 
--impl Default for HybridConfig {
--    fn default() -> Self {
--        Self {
--            utxo_config: crate::utxo::UTXOConfig::default(),
--            account_config: crate::account::AccountConfig::default(),
--            require_fee: false,
--            min_fee: 0,
--        }
--    }
--}
--
--/// Hybrid-specific operations
--pub trait HybridOperations {
--    /// Get access to the underlying UTXO model.
--    fn utxo_model(&self) -> &UTXOModel<Self::CommitmentScheme>;
--
--    /// Get access to the underlying account model.
--    fn account_model(&self) -> &AccountModel<Self::CommitmentScheme>;
--
--    /// Associated type for the commitment scheme
--    type CommitmentScheme: CommitmentScheme;
--
--    /// Create a cross-model transaction (e.g., UTXO input with account output).
--    ///
--    /// This is a placeholder for more complex hybrid operations that might be
--    /// supported in a real implementation.
--    fn create_cross_model_transaction(&self) -> Result<HybridTransaction, TransactionError> {
--        Err(TransactionError::Other("Not implemented".to_string()))
--    }
--}
--
--/// Hybrid transaction model implementation
--pub struct HybridModel<CS: CommitmentScheme + Clone> {
--    /// UTXO model
--    utxo_model: UTXOModel<CS>,
--    /// Account model
-+#[derive(Debug, Clone)]
-+pub struct HybridModel<CS: CommitmentScheme> {
-     account_model: AccountModel<CS>,
--    /// Model configuration
--    config: HybridConfig,
--    /// Commitment scheme
--    scheme: CS,
-+    utxo_model: UTXOModel<CS>,
- }
- 
--impl<CS: CommitmentScheme + Clone> HybridModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    /// Create a new hybrid model with default configuration.
-+impl<CS: CommitmentScheme + Clone> HybridModel<CS> {
-     pub fn new(scheme: CS) -> Self {
-         Self {
--            utxo_model: UTXOModel::new(scheme.clone()),
-             account_model: AccountModel::new(scheme.clone()),
--            config: HybridConfig::default(),
--            scheme,
-+            utxo_model: UTXOModel::new(scheme),
-         }
-     }
--
--    /// Create a new hybrid model with custom configuration.
-     pub fn with_config(scheme: CS, config: HybridConfig) -> Self {
-         Self {
--            utxo_model: UTXOModel::with_config(scheme.clone(), config.utxo_config.clone()),
--            account_model: AccountModel::with_config(scheme.clone(), config.account_config.clone()),
--            config,
--            scheme,
-+            account_model: AccountModel::with_config(scheme.clone(), config.account_config),
-+            utxo_model: UTXOModel::with_config(scheme, config.utxo_config),
-         }
-     }
--
--    /// Get model configuration.
--    pub fn config(&self) -> &HybridConfig {
--        &self.config
--    }
--
--    /// Get the commitment scheme
--    pub fn scheme(&self) -> &CS {
--        &self.scheme
--    }
- }
- 
--impl<CS: CommitmentScheme + Clone> TransactionModel for HybridModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
-+impl<CS: CommitmentScheme + Clone + Send + Sync> TransactionModel for HybridModel<CS> {
-     type Transaction = HybridTransaction;
--    type Proof = HybridProof;
-     type CommitmentScheme = CS;
-+    type Proof = HybridProof;
- 
-+    fn create_coinbase_transaction(
-+        &self,
-+        block_height: u64,
-+        recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError> {
-+        let utxo_coinbase = self
-+            .utxo_model
-+            .create_coinbase_transaction(block_height, recipient)?;
-+        Ok(HybridTransaction::UTXO(utxo_coinbase))
-+    }
-+
-+    // FIX: Add the required `where` clause to the method signature.
-     fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
-@@ -133,13 +73,12 @@ where
-             > + ?Sized,
-     {
-         match tx {
-+            HybridTransaction::Account(account_tx) => self.account_model.validate(account_tx, state),
-             HybridTransaction::UTXO(utxo_tx) => self.utxo_model.validate(utxo_tx, state),
--            HybridTransaction::Account(account_tx) => {
--                self.account_model.validate(account_tx, state)
--            }
-         }
-     }
- 
-+    // FIX: Add the required `where` clause.
-     fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-     where
-         S: StateManager<
-@@ -147,30 +86,13 @@ where
-                 Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-             > + ?Sized,
-     {
--        // Additional hybrid-specific validation
--        if self.config.require_fee {
--            // Check if fee is paid (implementation depends on fee model)
--            // This is a placeholder for a real fee verification
--            let _fee_paid = match tx {
--                HybridTransaction::UTXO(_utxo_tx) => {
--                    // For UTXO, fee is implicit (input value - output value)
--                    true
--                }
--                HybridTransaction::Account(_account_tx) => {
--                    // For account, fee might be explicit or implicit
--                    // This is a simplified check
--                    true
--                }
--            };
--        }
--
--        // Delegate to appropriate model
-         match tx {
--            HybridTransaction::UTXO(utxo_tx) => self.utxo_model.apply(utxo_tx, state),
-             HybridTransaction::Account(account_tx) => self.account_model.apply(account_tx, state),
-+            HybridTransaction::UTXO(utxo_tx) => self.utxo_model.apply(utxo_tx, state),
-         }
-     }
- 
-+    // FIX: Add the required `where` clause.
-     fn generate_proof<S>(
-         &self,
-         tx: &Self::Transaction,
-@@ -183,18 +105,23 @@ where
-             > + ?Sized,
-     {
-         match tx {
--            HybridTransaction::UTXO(utxo_tx) => self
--                .utxo_model
--                .generate_proof(utxo_tx, state)
--                .map(HybridProof::UTXO),
--            HybridTransaction::Account(account_tx) => self
--                .account_model
--                .generate_proof(account_tx, state)
--                .map(HybridProof::Account),
-+            HybridTransaction::Account(account_tx) => {
-+                let proof = self.account_model.generate_proof(account_tx, state)?;
-+                Ok(HybridProof::Account(proof))
-+            }
-+            HybridTransaction::UTXO(utxo_tx) => {
-+                let proof = self.utxo_model.generate_proof(utxo_tx, state)?;
-+                Ok(HybridProof::UTXO(proof))
-+            }
-         }
-     }
- 
--    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-+    // FIX: Add the required `where` clause.
-+    fn verify_proof<S>(
-+        &self,
-+        proof: &Self::Proof,
-+        state: &S,
-+    ) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
-                 Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-@@ -202,82 +129,18 @@ where
-             > + ?Sized,
-     {
-         match proof {
--            HybridProof::UTXO(utxo_proof) => self.utxo_model.verify_proof(utxo_proof, state),
-             HybridProof::Account(account_proof) => {
-                 self.account_model.verify_proof(account_proof, state)
-             }
-+            HybridProof::UTXO(utxo_proof) => self.utxo_model.verify_proof(utxo_proof, state),
-         }
-     }
- 
-     fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        let mut data = Vec::new();
--
--        match tx {
--            HybridTransaction::UTXO(utxo_tx) => {
--                // Add type byte (0 for UTXO)
--                data.push(0);
--
--                // Serialize UTXO transaction
--                let utxo_data = self.utxo_model.serialize_transaction(utxo_tx)?;
--                data.extend_from_slice(&utxo_data);
--            }
--            HybridTransaction::Account(account_tx) => {
--                // Add type byte (1 for Account)
--                data.push(1);
--
--                // Serialize account transaction
--                let account_data = self.account_model.serialize_transaction(account_tx)?;
--                data.extend_from_slice(&account_data);
--            }
--        }
--
--        Ok(data)
-+        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
-     fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        if data.is_empty() {
--            return Err(TransactionError::SerializationError(
--                "Empty data".to_string(),
--            ));
--        }
--
--        let tx_type = data[0];
--        let tx_data = &data[1..];
--
--        match tx_type {
--            0 => {
--                // UTXO transaction
--                let utxo_tx = self.utxo_model.deserialize_transaction(tx_data)?;
--                Ok(HybridTransaction::UTXO(utxo_tx))
--            }
--            1 => {
--                // Account transaction
--                let account_tx = self.account_model.deserialize_transaction(tx_data)?;
--                Ok(HybridTransaction::Account(account_tx))
--            }
--            _ => Err(TransactionError::SerializationError(format!(
--                "Unknown transaction type: {}",
--                tx_type
--            ))),
--        }
--    }
--
--    fn get_model_extensions(&self) -> Option<&dyn Any> {
--        Some(self as &dyn Any)
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-     }
--}
--
--impl<CS: CommitmentScheme + Clone> HybridOperations for HybridModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    type CommitmentScheme = CS;
--
--    fn utxo_model(&self) -> &UTXOModel<Self::CommitmentScheme> {
--        &self.utxo_model
--    }
--
--    fn account_model(&self) -> &AccountModel<Self::CommitmentScheme> {
--        &self.account_model
--    }
--}
-+}
-\ No newline at end of file
-diff --git a/crates/transaction_models/src/lib.rs b/crates/transaction_models/src/lib.rs
-index 7f79eb6..e4e9975 100644
---- a/crates/transaction_models/src/lib.rs
-+++ b/crates/transaction_models/src/lib.rs
-@@ -1,29 +1,11 @@
--//! # DePIN SDK Transaction Models
--//!
--//! Implementations of various transaction models for the DePIN SDK.
--//!
--//! This crate provides concrete implementations of the transaction model
--//! interfaces defined in the `depin_sdk_core` crate.
--//!
--//! ## Usage
--//!
--//! Each transaction model is implemented in its own module.
--//! Applications should import the specific model types they wish to use.
--//!
--//! ```rust
--//! // Example: Using the UTXO model
--//! use transaction_models::utxo::{UTXOModel, UTXOProof, UTXOTransaction};
--//!
--//! // Example: Using the account model
--//! use transaction_models::account::{AccountModel, AccountProof, AccountTransaction};
--//! ```
-+// Path: crates/transaction_models/src/lib.rs
- 
--// Modules for each transaction model
-+#![allow(clippy::new_without_default)]
- pub mod account;
- pub mod hybrid;
- pub mod utxo;
- 
--// Re-export operation traits for convenience
--pub use account::AccountOperations;
--pub use hybrid::HybridOperations;
--pub use utxo::UTXOOperations;
-+pub use account::{AccountConfig, AccountModel, AccountTransaction};
-+// FIX: The HybridOperations trait does not exist, so this line is removed.
-+pub use hybrid::{HybridConfig, HybridModel, HybridTransaction};
-+pub use utxo::{UTXOConfig, UTXOModel, UTXOTransaction};
-\ No newline at end of file
-diff --git a/crates/transaction_models/src/utxo/mod.rs b/crates/transaction_models/src/utxo/mod.rs
-index 39903b7..f862085 100644
---- a/crates/transaction_models/src/utxo/mod.rs
-+++ b/crates/transaction_models/src/utxo/mod.rs
-@@ -1,294 +1,116 @@
--//! UTXO-based transaction model implementation.
-+// Path: crates/transaction_models/src/utxo/mod.rs
- 
--use depin_sdk_core::crypto::SerializableKey;
--use depin_sdk_core::crypto::VerifyingKey;
--use depin_sdk_crypto::{algorithms::hash::sha256, sign::eddsa::{Ed25519PublicKey, Ed25519Signature}};
- use depin_sdk_core::commitment::CommitmentScheme;
--use depin_sdk_core::error::TransactionError;
-+use depin_sdk_core::error::{StateError, TransactionError};
- use depin_sdk_core::state::StateManager;
- use depin_sdk_core::transaction::TransactionModel;
--use std::any::Any;
--use std::collections::HashMap;
-+use serde::{Deserialize, Serialize};
-+use sha2::{Digest, Sha256};
- 
--/// UTXO transaction input
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct UTXOInput {
--    /// Previous transaction ID
--    pub prev_txid: Vec<u8>,
--    /// Output index in the previous transaction
--    pub prev_index: u32,
--    /// Signature unlocking the UTXO
-+#[derive(Debug, Clone, Default)]
-+pub struct UTXOConfig {
-+    pub max_inputs: usize,
-+    pub max_outputs: usize,
-+}
-+
-+pub trait UTXOOperations {
-+    fn create_utxo_key(&self, tx_hash: &[u8], index: u32) -> Vec<u8>;
-+}
-+
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-+pub struct Input {
-+    pub tx_hash: Vec<u8>,
-+    pub output_index: u32,
-     pub signature: Vec<u8>,
- }
- 
--/// UTXO transaction output
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
--pub struct UTXOOutput {
--    /// Value of the output
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
-+pub struct Output {
-     pub value: u64,
--    /// Locking script or public key hash
--    pub lock_script: Vec<u8>,
-+    pub public_key: Vec<u8>,
- }
- 
--/// UTXO transaction
--#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-+#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
- pub struct UTXOTransaction {
--    /// Transaction ID
--    pub txid: Vec<u8>,
--    /// Inputs (references to previous transaction outputs)
--    pub inputs: Vec<UTXOInput>,
--    /// Outputs (new unspent transaction outputs)
--    pub outputs: Vec<UTXOOutput>,
-+    pub inputs: Vec<Input>,
-+    pub outputs: Vec<Output>,
- }
- 
- impl UTXOTransaction {
--    /// Check if this is a coinbase transaction (has no inputs)
--    pub fn is_coinbase(&self) -> bool {
--        self.inputs.is_empty()
-+    pub fn hash(&self) -> Vec<u8> {
-+        let serialized = serde_json::to_vec(self).unwrap();
-+        Sha256::digest(&serialized).to_vec()
-     }
- }
- 
--/// UTXO proof data
- #[derive(Debug, Clone)]
--pub struct UTXOProof {
--    /// Proofs for transaction inputs
--    pub input_proofs: Vec<Vec<u8>>,
--    /// Additional data needed for verification
--    pub metadata: HashMap<String, Vec<u8>>,
--}
--
--/// UTXO-specific operations
--pub trait UTXOOperations {
--    /// Create a key for a UTXO in the state store.
--    ///
--    /// # Arguments
--    /// * `txid` - Transaction ID.
--    /// * `index` - Output index.
--    ///
--    /// # Returns
--    /// * `Ok(key)` - The generated key.
--    /// * `Err(TransactionError)` - If key creation failed.
--    fn create_utxo_key(&self, txid: &[u8], index: u32) -> Result<Vec<u8>, TransactionError>;
--}
--
--/// Configuration for the UTXO model
--#[derive(Clone)]
--pub struct UTXOConfig {
--    /// Minimum confirmations required for spending
--    pub min_confirmations: u32,
--    /// Maximum number of inputs per transaction
--    pub max_inputs: usize,
--    /// Maximum number of outputs per transaction
--    pub max_outputs: usize,
--    /// Maximum coinbase value (for block rewards)
--    pub max_coinbase_value: u64,
--    /// Whether to allow coinbase transactions
--    pub allow_coinbase: bool,
--}
--
--impl Default for UTXOConfig {
--    fn default() -> Self {
--        Self {
--            min_confirmations: 1,
--            max_inputs: 100,
--            max_outputs: 100,
--            max_coinbase_value: 50_000_000, // 50 coins with 6 decimal places
--            allow_coinbase: true,
--        }
--    }
--}
--
--/// UTXO transaction model implementation
- pub struct UTXOModel<CS: CommitmentScheme> {
--    /// Model configuration
-     config: UTXOConfig,
--    /// The commitment scheme
--    scheme: CS,
-+    _commitment_scheme: CS,
- }
- 
--impl<CS: CommitmentScheme> UTXOModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    /// Create a new UTXO model with default configuration.
--    pub fn new(scheme: CS) -> Self {
-+impl<CS: CommitmentScheme + Clone> UTXOModel<CS> {
-+    pub fn new(commitment_scheme: CS) -> Self {
-         Self {
-             config: UTXOConfig::default(),
--            scheme,
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
--
--    /// Create a new UTXO model with custom configuration.
--    pub fn with_config(scheme: CS, config: UTXOConfig) -> Self {
-+    pub fn with_config(commitment_scheme: CS, config: UTXOConfig) -> Self {
-         Self {
-             config,
--            scheme,
--        }
--    }
--
--    /// Get model configuration.
--    pub fn config(&self) -> &UTXOConfig {
--        &self.config
--    }
--
--    /// Get the commitment scheme
--    pub fn scheme(&self) -> &CS {
--        &self.scheme
--    }
--
--    /// Helper method to get a UTXO from the state.
--    fn get_utxo<S>(
--        &self,
--        state: &S,
--        txid: &[u8],
--        index: u32,
--    ) -> Result<Option<UTXOOutput>, TransactionError>
--    where
--        S: StateManager<
--            Commitment = CS::Commitment,
--            Proof = CS::Proof,
--        > + ?Sized,
--    {
--        let key = self.create_utxo_key(txid, index)?;
--        let value = state
--            .get(&key)
--            .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--
--        match value {
--            Some(data) => self.decode_utxo(&data),
--            None => Ok(None),
-+            _commitment_scheme: commitment_scheme,
-         }
-     }
-+}
- 
--    /// Helper method to decode a UTXO from bytes.
--    fn decode_utxo(&self, data: &[u8]) -> Result<Option<UTXOOutput>, TransactionError> {
--        if data.len() < 8 {
--            return Err(TransactionError::SerializationError(
--                "UTXO data too short".to_string(),
--            ));
--        }
--
--        let mut value_bytes = [0u8; 8];
--        value_bytes.copy_from_slice(&data[0..8]);
--        let value = u64::from_le_bytes(value_bytes);
--        let lock_script = data[8..].to_vec();
--
--        Ok(Some(UTXOOutput { value, lock_script }))
--    }
--
--    /// Helper method to encode a UTXO to bytes.
--    fn encode_utxo(&self, output: &UTXOOutput) -> Vec<u8> {
--        let mut data = Vec::with_capacity(8 + output.lock_script.len());
--        data.extend_from_slice(&output.value.to_le_bytes());
--        data.extend_from_slice(&output.lock_script);
--        data
--    }
--    
--    /// Convert raw bytes to the commitment scheme's value type
--    fn to_value(&self, bytes: &[u8]) -> CS::Value {
--        CS::Value::from(bytes.to_vec())
--    }
--
--    /// Validate a coinbase transaction
--    fn validate_coinbase(&self, tx: &UTXOTransaction) -> Result<bool, TransactionError> {
--        // Check if coinbase transactions are allowed
--        if !self.config.allow_coinbase {
--            return Ok(false);
--        }
--
--        // Verify total output value doesn't exceed maximum
--        let mut total_output = 0u64;
--        for output in &tx.outputs {
--            total_output = total_output.checked_add(output.value).ok_or_else(|| {
--                TransactionError::InvalidTransaction("Coinbase output value overflow".to_string())
--            })?;
--        }
--
--        if total_output > self.config.max_coinbase_value {
--            return Ok(false);
--        }
--
--        // Additional coinbase validation could go here:
--        // - Check block height for reward schedule
--        // - Verify only one coinbase per block
--        // - Validate special coinbase fields
--
--        Ok(true)
-+impl<CS: CommitmentScheme> UTXOOperations for UTXOModel<CS> {
-+    fn create_utxo_key(&self, tx_hash: &[u8], index: u32) -> Vec<u8> {
-+        let mut key = b"u".to_vec();
-+        key.extend_from_slice(tx_hash);
-+        key.extend_from_slice(&index.to_le_bytes());
-+        key
-     }
- }
- 
--impl<CS: CommitmentScheme> TransactionModel for UTXOModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
-+impl<CS: CommitmentScheme + Clone + Send + Sync> TransactionModel for UTXOModel<CS> {
-     type Transaction = UTXOTransaction;
--    type Proof = UTXOProof;
-     type CommitmentScheme = CS;
-+    type Proof = ();
- 
--    fn validate<S>(&self, tx: &Self::Transaction, state: &S) -> Result<bool, TransactionError>
-+    fn validate<SM>(&self, tx: &Self::Transaction, state: &SM) -> Result<bool, TransactionError>
-     where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+        SM: StateManager<
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Check transaction structure
--        if tx.outputs.is_empty() {
--            return Ok(false);
--        }
--
--        if tx.outputs.len() > self.config.max_outputs {
--            return Ok(false);
--        }
--
--        // Handle coinbase transactions (no inputs)
--        if tx.is_coinbase() {
--            return self.validate_coinbase(tx);
-+        // --- FIX: Add special validation logic for coinbase transactions ---
-+        // A coinbase transaction is the only valid transaction type with no inputs.
-+        if tx.inputs.is_empty() {
-+            // A valid coinbase should have at least one output to reward the miner.
-+            // More complex rules (e.g., exactly one output) could be added here.
-+            return Ok(!tx.outputs.is_empty());
-         }
-+        // --- End Fix ---
- 
--        // Regular transaction validation
--        if tx.inputs.len() > self.config.max_inputs {
-+        if tx.inputs.len() > self.config.max_inputs || tx.outputs.len() > self.config.max_outputs {
-             return Ok(false);
-         }
- 
--        // Validate inputs exist and are unspent
--        let mut total_input = 0u64;
--
-+        let mut total_input: u64 = 0;
-         for input in &tx.inputs {
--            let utxo = self.get_utxo(state, &input.prev_txid, input.prev_index)?;
--
--            match utxo {
--                Some(output) => {
--                    // Reconstruct the digest that was signed.
--                    let mut digest_data = Vec::new();
--                    digest_data.extend_from_slice(&input.prev_txid);
--                    let digest = sha256(&digest_data);
--
--                    let public_key = Ed25519PublicKey::from_bytes(&output.lock_script).map_err(|e| TransactionError::InvalidSignature(e))?;
--                    let signature = Ed25519Signature::from_bytes(&input.signature).map_err(|e| TransactionError::InvalidSignature(e))?;
--
--                    if !public_key.verify(&digest, &signature) {
--                        return Err(TransactionError::InvalidSignature("Signature verification failed".to_string()));
--                    }
--
--                    total_input = total_input.checked_add(output.value).ok_or_else(|| {
--                        TransactionError::InvalidTransaction("Input value overflow".to_string())
--                    })?;
--                }
--                None => return Ok(false), // Input UTXO not found
--            }
--        }
--
--        // Calculate total output
--        let mut total_output = 0u64;
--
--        for output in &tx.outputs {
--            total_output = total_output.checked_add(output.value).ok_or_else(|| {
--                TransactionError::InvalidTransaction("Output value overflow".to_string())
-+            let key = self.create_utxo_key(&input.tx_hash, input.output_index);
-+            let utxo_bytes = state.get(&key)?.ok_or_else(|| {
-+                TransactionError::Invalid(format!("Input UTXO not found"))
-             })?;
-+            let utxo: Output = serde_json::from_slice(&utxo_bytes)
-+                .map_err(|e| TransactionError::Invalid(format!("Deserialize error: {}", e)))?;
-+            total_input = total_input.checked_add(utxo.value)
-+                .ok_or_else(|| TransactionError::Invalid("Input value overflow".to_string()))?;
-         }
- 
--        // Ensure total input >= total output (the difference is the fee)
-+        let total_output: u64 = tx.outputs.iter().map(|o| o.value).sum();
-         if total_input < total_output {
-             return Ok(false);
-         }
-@@ -296,284 +118,74 @@ where
-         Ok(true)
-     }
- 
--    fn apply<S>(&self, tx: &Self::Transaction, state: &mut S) -> Result<(), TransactionError>
-+    fn apply<SM>(&self, tx: &Self::Transaction, state: &mut SM) -> Result<(), TransactionError>
-     where
--        S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+        SM: StateManager<
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // Validate transaction first
-         if !self.validate(tx, state)? {
--            return Err(TransactionError::InvalidTransaction(
--                "Transaction validation failed".to_string(),
--            ));
-+            return Err(TransactionError::Invalid("Validation failed".to_string()));
-         }
--
--        // Only remove spent inputs for non-coinbase transactions
--        if !tx.is_coinbase() {
--            for input in &tx.inputs {
--                let key = self.create_utxo_key(&input.prev_txid, input.prev_index)?;
--                state
--                    .delete(&key)
--                    .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
--            }
-+        for input in &tx.inputs {
-+            let key = self.create_utxo_key(&input.tx_hash, input.output_index);
-+            state.delete(&key)?;
-         }
--
--        // Add new outputs (for both coinbase and regular transactions)
--        for (i, output) in tx.outputs.iter().enumerate() {
--            let key = self.create_utxo_key(&tx.txid, i as u32)?;
--            let value = self.encode_utxo(output);
--
--            state
--                .set(&key, &value)
--                .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?;
-+        let tx_hash = tx.hash();
-+        for (index, output) in tx.outputs.iter().enumerate() {
-+            let key = self.create_utxo_key(&tx_hash, index as u32);
-+            let value = serde_json::to_vec(output)
-+                .map_err(|e| TransactionError::Serialization(e.to_string()))?;
-+            state.insert(&key, &value)?;
-         }
--
-         Ok(())
-     }
- 
-+    fn create_coinbase_transaction(
-+        &self,
-+        _block_height: u64,
-+        recipient: &[u8],
-+    ) -> Result<Self::Transaction, TransactionError> {
-+        Ok(UTXOTransaction {
-+            inputs: vec![],
-+            outputs: vec![Output { value: 50, public_key: recipient.to_vec() }],
-+        })
-+    }
-+
-     fn generate_proof<S>(
-         &self,
--        tx: &Self::Transaction,
--        state: &S,
-+        _tx: &Self::Transaction,
-+        _state: &S,
-     ) -> Result<Self::Proof, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        let mut input_proofs = Vec::with_capacity(tx.inputs.len());
--
--        // Coinbase transactions don't need input proofs
--        if tx.is_coinbase() {
--            return Ok(UTXOProof {
--                input_proofs,
--                metadata: HashMap::new(),
--            });
--        }
--
--        for input in &tx.inputs {
--            let key = self.create_utxo_key(&input.prev_txid, input.prev_index)?;
--
--            // In a real implementation, we would create cryptographic proofs
--            // For this example, we'll just get the raw UTXO data
--            let utxo_data = state
--                .get(&key)
--                .map_err(|e| TransactionError::StateAccessFailed(e.to_string()))?
--                .ok_or_else(|| {
--                    TransactionError::InvalidInput("Referenced UTXO not found".to_string())
--                })?;
--
--            input_proofs.push(utxo_data);
--        }
--
--        Ok(UTXOProof {
--            input_proofs,
--            metadata: HashMap::new(),
--        })
-+        Ok(())
-     }
- 
--    fn verify_proof<S>(&self, proof: &Self::Proof, state: &S) -> Result<bool, TransactionError>
-+    fn verify_proof<S>(
-+        &self,
-+        _proof: &Self::Proof,
-+        _state: &S,
-+    ) -> Result<bool, TransactionError>
-     where
-         S: StateManager<
--            Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
--            Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
--        > + ?Sized,
-+                Commitment = <Self::CommitmentScheme as CommitmentScheme>::Commitment,
-+                Proof = <Self::CommitmentScheme as CommitmentScheme>::Proof,
-+            > + ?Sized,
-     {
--        // In a real implementation, this would verify cryptographic proofs
--        // For this example, we'll just return true
-         Ok(true)
-     }
- 
-     fn serialize_transaction(&self, tx: &Self::Transaction) -> Result<Vec<u8>, TransactionError> {
--        // Simple manual serialization for demonstration
--        let mut data = Vec::new();
--
--        // Serialize txid
--        data.extend_from_slice(&(tx.txid.len() as u32).to_le_bytes());
--        data.extend_from_slice(&tx.txid);
--
--        // Serialize inputs
--        data.extend_from_slice(&(tx.inputs.len() as u32).to_le_bytes());
--        for input in &tx.inputs {
--            data.extend_from_slice(&(input.prev_txid.len() as u32).to_le_bytes());
--            data.extend_from_slice(&input.prev_txid);
--            data.extend_from_slice(&input.prev_index.to_le_bytes());
--            data.extend_from_slice(&(input.signature.len() as u32).to_le_bytes());
--            data.extend_from_slice(&input.signature);
--        }
--
--        // Serialize outputs
--        data.extend_from_slice(&(tx.outputs.len() as u32).to_le_bytes());
--        for output in &tx.outputs {
--            data.extend_from_slice(&output.value.to_le_bytes());
--            data.extend_from_slice(&(output.lock_script.len() as u32).to_le_bytes());
--            data.extend_from_slice(&output.lock_script);
--        }
--
--        Ok(data)
-+        serde_json::to_vec(tx).map_err(|e| TransactionError::Serialization(e.to_string()))
-     }
- 
-     fn deserialize_transaction(&self, data: &[u8]) -> Result<Self::Transaction, TransactionError> {
--        if data.len() < 4 {
--            return Err(TransactionError::SerializationError(
--                "Data too short".to_string(),
--            ));
--        }
--
--        let mut pos = 0;
--
--        // Deserialize txid
--        let txid_len = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        if pos + txid_len > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid txid length".to_string(),
--            ));
--        }
--
--        let txid = data[pos..pos + txid_len].to_vec();
--        pos += txid_len;
--
--        // Deserialize inputs
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let input_count = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        let mut inputs = Vec::with_capacity(input_count);
--        for _ in 0..input_count {
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let prev_txid_len = read_u32(&data[pos..pos + 4]) as usize;
--            pos += 4;
--
--            if pos + prev_txid_len > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid prev_txid length".to_string(),
--                ));
--            }
--
--            let prev_txid = data[pos..pos + prev_txid_len].to_vec();
--            pos += prev_txid_len;
--
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let prev_index = read_u32(&data[pos..pos + 4]);
--            pos += 4;
--
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let signature_len = read_u32(&data[pos..pos + 4]) as usize;
--            pos += 4;
--
--            if pos + signature_len > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid signature length".to_string(),
--                ));
--            }
--
--            let signature = data[pos..pos + signature_len].to_vec();
--            pos += signature_len;
--
--            inputs.push(UTXOInput {
--                prev_txid,
--                prev_index,
--                signature,
--            });
--        }
--
--        // Deserialize outputs
--        if pos + 4 > data.len() {
--            return Err(TransactionError::SerializationError(
--                "Invalid data format".to_string(),
--            ));
--        }
--
--        let output_count = read_u32(&data[pos..pos + 4]) as usize;
--        pos += 4;
--
--        let mut outputs = Vec::with_capacity(output_count);
--        for _ in 0..output_count {
--            if pos + 8 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let mut value_bytes = [0u8; 8];
--            value_bytes.copy_from_slice(&data[pos..pos + 8]);
--            let value = u64::from_le_bytes(value_bytes);
--            pos += 8;
--
--            if pos + 4 > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid data format".to_string(),
--                ));
--            }
--
--            let lock_script_len = read_u32(&data[pos..pos + 4]) as usize;
--            pos += 4;
--
--            if pos + lock_script_len > data.len() {
--                return Err(TransactionError::SerializationError(
--                    "Invalid lock_script length".to_string(),
--                ));
--            }
--
--            let lock_script = data[pos..pos + lock_script_len].to_vec();
--            pos += lock_script_len;
--
--            outputs.push(UTXOOutput { value, lock_script });
--        }
--
--        Ok(UTXOTransaction {
--            txid,
--            inputs,
--            outputs,
--        })
--    }
--
--    fn get_model_extensions(&self) -> Option<&dyn Any> {
--        Some(self as &dyn Any)
-+        serde_json::from_slice(data).map_err(|e| TransactionError::Deserialization(e.to_string()))
-     }
--}
--
--impl<CS: CommitmentScheme> UTXOOperations for UTXOModel<CS>
--where
--    CS::Value: From<Vec<u8>> + AsRef<[u8]>,
--{
--    fn create_utxo_key(&self, txid: &[u8], index: u32) -> Result<Vec<u8>, TransactionError> {
--        let mut key = Vec::with_capacity(txid.len() + 5);
--        key.push(b'u'); // Prefix 'u' for UTXO
--        key.extend_from_slice(txid);
--        key.extend_from_slice(&index.to_le_bytes());
--        Ok(key)
--    }
--}
--
--/// Helper function to read a u32 from a byte slice
--fn read_u32(data: &[u8]) -> u32 {
--    let mut bytes = [0u8; 4];
--    bytes.copy_from_slice(data);
--    u32::from_le_bytes(bytes)
- }
-\ No newline at end of file
-diff --git a/crates/validator/Cargo.toml b/crates/validator/Cargo.toml
-index 9cb957b..5fd730b 100644
---- a/crates/validator/Cargo.toml
-+++ b/crates/validator/Cargo.toml
-@@ -1,24 +1,44 @@
-+# Path: crates/validator/Cargo.toml
-+
- [package]
- name = "depin-sdk-validator"
- version = "0.1.0"
- edition = "2021"
--description = "Validator implementation with container architecture for the DePIN SDK"
-+description = "Validator container implementations for the DePIN SDK"
- license = "MIT OR Apache-2.0"
- 
- [dependencies]
- depin-sdk-core = { path = "../core" }
- log = { workspace = true }
--serde = { workspace = true }
--thiserror = { workspace = true }
--bytes = { workspace = true }
- anyhow = { workspace = true }
--tokio = { version = "1.28", features = ["full"] }
--toml = "0.7"
-+serde = { workspace = true, features = ["derive"] }
-+serde_json = { workspace = true }
-+# FIX: The `sync` feature is required for tokio::sync::watch
-+tokio = { workspace = true, features = ["full", "sync"] }
-+libp2p = { workspace = true }
-+futures = { workspace = true }
-+async-trait = { workspace = true }
-+toml = { workspace = true }
-+clap = { workspace = true, features = ["derive"], optional = true }
-+env_logger = { workspace = true, optional = true }
-+depin-sdk-state-trees = { path = "../state_trees", optional = true }
-+depin-sdk-commitment-schemes = { path = "../commitment_schemes", optional = true }
-+
-+[features]
-+default = []
-+validator-bins = [
-+    "dep:clap",
-+    "dep:env_logger",
-+    "dep:depin-sdk-state-trees",
-+    "dep:depin-sdk-commitment-schemes",
-+]
- 
- [[bin]]
--name = "depin-sdk-validator"
-+name = "validator"
- path = "src/bin/validator.rs"
-+required-features = ["validator-bins"]
- 
- [[bin]]
--name = "depin-sdk-validator-hybrid"
-+name = "validator_hybrid"
- path = "src/bin/validator_hybrid.rs"
-+required-features = ["validator-bins"]
-diff --git a/crates/validator/src/bin/validator.rs b/crates/validator/src/bin/validator.rs
-index 518aedf..35c05d8 100644
---- a/crates/validator/src/bin/validator.rs
-+++ b/crates/validator/src/bin/validator.rs
-@@ -1,83 +1,65 @@
--//! Standard validator binary
-+// Path: crates/validator/src/bin/validator.rs
- 
--use depin_sdk_core::validator::{Container, ValidatorModel};
--use depin_sdk_validator::standard::StandardValidator;
--use std::env;
--use std::path::Path;
-+use anyhow::anyhow;
-+use clap::Parser;
-+use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-+// FIX: core::Container is now async
-+use depin_sdk_core::validator::{Container, WorkloadContainer};
-+use depin_sdk_core::WorkloadConfig;
-+use depin_sdk_state_trees::file::FileStateTree;
-+use depin_sdk_validator::{common::GuardianContainer, standard::OrchestrationContainer};
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
-+
-+#[derive(Parser, Debug)]
-+#[clap(name = "validator", about = "A standard DePIN SDK validator node.")]
-+struct Opts {
-+    #[clap(long, default_value = "./config")]
-+    config_dir: String,
-+}
- 
- #[tokio::main]
--async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
--    // Parse command-line arguments
--    let args: Vec<String> = env::args().collect();
--    let container_type = if args.len() > 1 { &args[1] } else { "all" };
-+async fn main() -> anyhow::Result<()> {
-+    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-+    let opts = Opts::parse();
-+    let path = PathBuf::from(opts.config_dir);
-+
-+    log::info!("Initializing Standard Validator...");
-+
-+    let guardian = GuardianContainer::new(&path.join("guardian.toml"))?;
-+
-+    let state_tree = FileStateTree::new("state.json", HashCommitmentScheme::new());
- 
--    // Default config directory is ./config
--    let config_dir = env::var("CONFIG_DIR").unwrap_or_else(|_| "./config".to_string());
-+    let workload_config = WorkloadConfig {
-+        enabled_vms: vec!["WASM".to_string()],
-+    };
- 
--    println!("Starting DePIN SDK Standard Validator");
--    println!("Container type: {}", container_type);
--    println!("Config directory: {}", config_dir);
-+    let workload = Arc::new(WorkloadContainer::new(workload_config, state_tree));
- 
--    match container_type {
--        "guardian" => {
--            // Start only the guardian container
--            let path = Path::new(&config_dir);
--            let guardian =
--                depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"))?;
--            guardian.start()?;
-+    // FIX: OrchestrationContainer::new is now async and must be awaited.
-+    let orchestration = Arc::new(
-+        OrchestrationContainer::<
-+            HashCommitmentScheme,
-+            (), // Placeholder for TM
-+            FileStateTree<HashCommitmentScheme>,
-+        >::new(&path.join("orchestration.toml"))
-+        .await?,
-+    );
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        "orchestration" => {
--            // Start only the orchestration container
--            let path = Path::new(&config_dir);
--            let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(
--                path.join("orchestration.toml"),
--            )?;
--            orchestration.start()?;
-+    // Wire up a dummy chain for now. In a real scenario, this would be part of the composition root.
-+    // orchestration.set_chain_and_workload_ref(Arc::new(Mutex::new(())), workload);
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        "workload" => {
--            // Start only the workload container
--            let path = Path::new(&config_dir);
--            let workload =
--                depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"))?;
--            workload.start()?;
-+    log::info!("Starting services...");
-+    orchestration.start().await?;
-+    guardian.start().await?;
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        // Fixed: Separate "all" case from wildcard pattern to avoid Clippy warning
--        "all" => {
--            // Start the full validator
--            let path = Path::new(&config_dir);
--            let validator = StandardValidator::new(path)?;
--            validator.start()?;
-+    tokio::signal::ctrl_c().await?;
-+    log::info!("Shutdown signal received.");
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--        _ => {
--            // Default to full validator for any other input
--            let path = Path::new(&config_dir);
--            let validator = StandardValidator::new(path)?;
--            validator.start()?;
-+    orchestration.stop().await?;
-+    guardian.stop().await?;
-+    log::info!("Validator stopped gracefully.");
- 
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        }
--    }
-+    Ok(())
- }
-\ No newline at end of file
-diff --git a/crates/validator/src/bin/validator_hybrid.rs b/crates/validator/src/bin/validator_hybrid.rs
-index 470c370..d21ead3 100644
---- a/crates/validator/src/bin/validator_hybrid.rs
-+++ b/crates/validator/src/bin/validator_hybrid.rs
-@@ -1,89 +1,74 @@
--//! Hybrid validator binary
-+// Path: crates/validator/src/bin/validator_hybrid.rs
- 
--use std::env;
--use std::path::Path;
--use depin_sdk_validator::hybrid::HybridValidator;
--use depin_sdk_core::validator::{Container, ValidatorModel};
-+use anyhow::anyhow;
-+use clap::Parser;
-+// FIX: Import WorkloadContainer from its new, correct location in `core`.
-+use depin_sdk_core::validator::WorkloadContainer;
-+use depin_sdk_core::{config::WorkloadConfig, Container};
-+use depin_sdk_state_trees::file::FileStateTree;
-+// FIX: Add necessary imports.
-+use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-+use depin_sdk_validator::{
-+    common::GuardianContainer,
-+    hybrid::{ApiContainer, InterfaceContainer},
-+    standard::OrchestrationContainer,
-+};
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
-+
-+
-+#[derive(Parser, Debug)]
-+#[clap(name = "validator_hybrid", about = "A hybrid DePIN SDK validator node with public APIs.")]
-+struct Opts {
-+    #[clap(long, default_value = "./config")]
-+    config_dir: String,
-+}
- 
- #[tokio::main]
--async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
--    // Parse command-line arguments
--    let args: Vec<String> = env::args().collect();
--    let container_type = if args.len() > 1 { &args[1] } else { "all" };
--    
--    // Default config directory is ./config
--    let config_dir = env::var("CONFIG_DIR").unwrap_or_else(|_| "./config".to_string());
-+async fn main() -> anyhow::Result<()> {
-+    env_logger::builder().filter_level(log::LevelFilter::Info).init();
-+    let opts = Opts::parse();
-+    let path = PathBuf::from(opts.config_dir);
-+
-+    log::info!("Initializing Hybrid Validator...");
-+
-+    // FIX: Pass borrowed paths (`&`) to the `new` constructors.
-+    let guardian = GuardianContainer::new(&path.join("guardian.toml"))?;
-+
-+    let state_tree = FileStateTree::new("state.json", HashCommitmentScheme::new());
-+
-+    let workload = Arc::new(WorkloadContainer::new(
-+        WorkloadConfig::default(),
-+        state_tree,
-+    ));
-+
-+    let orchestration = Arc::new(OrchestrationContainer::new(
-+        &path.join("orchestration.toml"),
-+    )?);
-     
--    println!("Starting DePIN SDK Hybrid Validator");
--    println!("Container type: {}", container_type);
--    println!("Config directory: {}", config_dir);
-+    // Wire up a dummy chain for now.
-+    orchestration.set_chain_and_workload_ref(Arc::new(Mutex::new(())), workload);
-+
-+    let interface = InterfaceContainer::new(&path.join("interface.toml"))?;
-+    let api = ApiContainer::new(&path.join("api.toml"))?;
-+
-+
-+    log::info!("Starting services...");
-+    guardian.start()?;
-+    // FIX: The start method is async and must be awaited.
-+    orchestration.start().await?;
-+    interface.start()?;
-+    api.start()?;
-+
-+    tokio::signal::ctrl_c().await?;
-+    log::info!("Shutdown signal received.");
-+
-+    api.stop()?;
-+    interface.stop()?;
-+    orchestration.stop().await?;
-+    guardian.stop()?;
-+    log::info!("Validator stopped gracefully.");
-     
--    match container_type {
--        "guardian" => {
--            // Start only the guardian container
--            let path = Path::new(&config_dir);
--            let guardian = depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"))?;
--            guardian.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "orchestration" => {
--            // Start only the orchestration container
--            let path = Path::new(&config_dir);
--            let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(path.join("orchestration.toml"))?;
--            orchestration.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "workload" => {
--            // Start only the workload container
--            let path = Path::new(&config_dir);
--            let workload = depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"))?;
--            workload.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "interface" => {
--            // Start only the interface container
--            let path = Path::new(&config_dir);
--            let interface = depin_sdk_validator::hybrid::InterfaceContainer::new(path.join("interface.toml"))?;
--            interface.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "api" => {
--            // Start only the API container
--            let path = Path::new(&config_dir);
--            let api = depin_sdk_validator::hybrid::ApiContainer::new(path.join("api.toml"))?;
--            api.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--        "all" | _ => {
--            // Start the full validator
--            let path = Path::new(&config_dir);
--            let validator = HybridValidator::new(path)?;
--            validator.start()?;
--            
--            // Keep the process running
--            loop {
--                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
--            }
--        },
--    }
-+    Ok(())
- }
-\ No newline at end of file
-diff --git a/crates/validator/src/common/guardian.rs b/crates/validator/src/common/guardian.rs
-index c6008b0..534c6fe 100644
---- a/crates/validator/src/common/guardian.rs
-+++ b/crates/validator/src/common/guardian.rs
-@@ -1,86 +1,64 @@
--//! Implementation of the guardian container
-+// Path: crates/validator/src/common/guardian.rs
- 
--use crate::config::GuardianConfig;
-+use async_trait::async_trait;
- use depin_sdk_core::error::ValidatorError;
--use depin_sdk_core::validator::{Container, GuardianContainer as GuardianTrait};
--use std::error::Error;
-+use depin_sdk_core::validator::{Container, GuardianContainer as GuardianContainerTrait};
- use std::path::Path;
--use std::sync::{Arc, Mutex};
-+// FIX: Add imports for atomic state management
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
- 
--/// Guardian container for security, boot process, and attestation
-+#[derive(Debug, Default)]
- pub struct GuardianContainer {
--    /// Parsed configuration for the Guardian.
--    config: GuardianConfig,
--    /// Boot status
--    boot_status: Arc<Mutex<BootStatus>>,
--}
--
--/// Boot status
--#[derive(Debug, Clone, Copy, PartialEq, Eq)]
--pub enum BootStatus {
--    /// Not started
--    NotStarted,
--    /// In progress
--    InProgress,
--    /// Completed successfully
--    Completed,
--    /// Failed
--    Failed,
-+    // FIX: Use Arc<AtomicBool> for thread-safe interior mutability.
-+    running: Arc<AtomicBool>,
- }
- 
- impl GuardianContainer {
--    /// Create a new guardian container from a config file.
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--        let config: GuardianConfig = toml::from_str(&config_str)?;
--
--        println!(
--            "Guardian config loaded. Signature policy: {:?}",
--            config.signature_policy
--        );
--
-+    pub fn new(_config_path: &Path) -> anyhow::Result<Self> {
-+        // FIX: Initialize the atomic bool correctly.
-         Ok(Self {
--            config,
--            boot_status: Arc::new(Mutex::new(BootStatus::NotStarted)),
-+            running: Arc::new(AtomicBool::new(false)),
-         })
-     }
--    
--    /// Get the current boot status
--    pub fn boot_status(&self) -> BootStatus {
--        *self.boot_status.lock().unwrap()
--    }
- }
- 
-+#[async_trait]
- impl Container for GuardianContainer {
--    fn start(&self) -> Result<(), ValidatorError> {
--        self.start_boot()
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!("Starting GuardianContainer...");
-+        // FIX: Atomically set the running flag to true.
-+        self.running.store(true, Ordering::SeqCst);
-+        Ok(())
-     }
- 
--    fn stop(&self) -> Result<(), ValidatorError> {
--        println!("Guardian container stopped.");
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("Stopping GuardianContainer...");
-+        // FIX: Atomically set the running flag to false.
-+        self.running.store(false, Ordering::SeqCst);
-         Ok(())
-     }
- 
-     fn is_running(&self) -> bool {
--        *self.boot_status.lock().unwrap() == BootStatus::Completed
-+        // FIX: Atomically load the value of the running flag.
-+        self.running.load(Ordering::SeqCst)
-     }
- 
--    fn id(&self) -> &str {
-+    fn id(&self) -> &'static str {
-         "guardian"
-     }
- }
- 
--impl GuardianTrait for GuardianContainer {
-+impl GuardianContainerTrait for GuardianContainer {
-     fn start_boot(&self) -> Result<(), ValidatorError> {
--        let mut status = self.boot_status.lock().unwrap();
--        *status = BootStatus::InProgress;
--        println!("Guardian container starting boot process...");
--        *status = BootStatus::Completed;
--        println!("Guardian container boot process completed.");
-+        log::info!("Guardian: Initiating secure boot sequence...");
-         Ok(())
-     }
- 
-     fn verify_attestation(&self) -> Result<bool, ValidatorError> {
-+        log::info!("Guardian: Verifying inter-container attestation...");
-         Ok(true)
-     }
- }
-\ No newline at end of file
-diff --git a/crates/validator/src/hybrid/api.rs b/crates/validator/src/hybrid/api.rs
-index ca9a27c..b2bbc90 100644
---- a/crates/validator/src/hybrid/api.rs
-+++ b/crates/validator/src/hybrid/api.rs
-@@ -1,67 +1,64 @@
--//! Implementation of API container
-+// Path: crates/validator/src/hybrid/api.rs
- 
--use crate::config::ApiConfig;
- use depin_sdk_core::error::ValidatorError;
- use depin_sdk_core::validator::Container;
--use std::error::Error;
-+use serde::Deserialize;
- use std::path::Path;
--use std::sync::{Arc, Mutex};
-+// FIX: Add imports for atomic state management
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
-+use toml;
- 
--/// API container for API implementation and state queries
-+/// Configuration for the API container, loaded from `api.toml`.
-+#[derive(Deserialize)]
-+pub struct ApiConfig {
-+    pub listen_address: String,
-+    pub enabled_endpoints: Vec<String>,
-+}
-+
-+/// The ApiContainer is responsible for implementing the public-facing JSON-RPC
-+/// or other state-query APIs for a hybrid validator.
- pub struct ApiContainer {
--    /// Parsed configuration for the API container.
-     config: ApiConfig,
--    /// Running status
--    running: Arc<Mutex<bool>>,
-+    // FIX: Use Arc<AtomicBool> for thread-safe state.
-+    running: Arc<AtomicBool>,
- }
- 
- impl ApiContainer {
--    /// Create a new API container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_str = std::fs::read_to_string(config_path.as_ref())?;
-+    pub fn new(config_path: &Path) -> anyhow::Result<Self> {
-+        let config_str = std::fs::read_to_string(config_path)?;
-         let config: ApiConfig = toml::from_str(&config_str)?;
--
--        println!("API container config loaded. Listen address: {}", config.listen_address);
--
-         Ok(Self {
-             config,
--            running: Arc::new(Mutex::new(false)),
-+            running: Arc::new(AtomicBool::new(false)),
-         })
-     }
--    /// Handle an API request
--    pub fn handle_request(&self, endpoint: &str, params: &[u8]) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--        if !self.is_running() {
--            return Err("API container is not running".into());
--        }
--        println!("Handling API request to endpoint {}, {} bytes", endpoint, params.len());
--        Ok(vec![9, 10, 11, 12])
--    }
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
--    }
- }
- 
-+#[async_trait::async_trait]
- impl Container for ApiContainer {
--    fn start(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        println!("API container started successfully");
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!(
-+            "Starting ApiContainer, listening on {}...",
-+            self.config.listen_address
-+        );
-+        self.running.store(true, Ordering::SeqCst);
-         Ok(())
-     }
- 
--    fn stop(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        println!("API container stopped successfully");
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("Stopping ApiContainer...");
-+        self.running.store(false, Ordering::SeqCst);
-         Ok(())
-     }
- 
-     fn is_running(&self) -> bool {
--        self.is_running()
-+        self.running.load(Ordering::SeqCst)
-     }
- 
--    fn id(&self) -> &str {
-+    fn id(&self) -> &'static str {
-         "api"
-     }
- }
-\ No newline at end of file
-diff --git a/crates/validator/src/hybrid/interface.rs b/crates/validator/src/hybrid/interface.rs
-index fed5918..e52d344 100644
---- a/crates/validator/src/hybrid/interface.rs
-+++ b/crates/validator/src/hybrid/interface.rs
-@@ -1,68 +1,64 @@
--//! Implementation of interface container
-+// Path: crates/validator/src/hybrid/interface.rs
- 
--use crate::config::InterfaceConfig;
- use depin_sdk_core::error::ValidatorError;
- use depin_sdk_core::validator::Container;
--use std::error::Error;
--use std::net::SocketAddr;
-+use serde::Deserialize;
- use std::path::Path;
--use std::sync::{Arc, Mutex};
-+// FIX: Add imports for atomic state management
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
-+use toml;
- 
--/// Interface container for connection handling and protocol routing
-+/// Configuration for the Interface container, loaded from `interface.toml`.
-+#[derive(Deserialize)]
-+pub struct InterfaceConfig {
-+    pub max_connections: u32,
-+    pub rate_limit_per_second: u64,
-+}
-+
-+/// The InterfaceContainer manages raw network connections, protocol routing,
-+/// and basic DDoS protection for a hybrid validator's public-facing services.
- pub struct InterfaceContainer {
--    /// Parsed configuration for the Interface container.
-     config: InterfaceConfig,
--    /// Running status
--    running: Arc<Mutex<bool>>,
-+    // FIX: Use Arc<AtomicBool> for thread-safe state.
-+    running: Arc<AtomicBool>,
- }
- 
- impl InterfaceContainer {
--    /// Create a new interface container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_str = std::fs::read_to_string(config_path.as_ref())?;
-+    pub fn new(config_path: &Path) -> anyhow::Result<Self> {
-+        let config_str = std::fs::read_to_string(config_path)?;
-         let config: InterfaceConfig = toml::from_str(&config_str)?;
--
--        println!("Interface container config loaded. Listen address: {}", config.listen_address);
--
-         Ok(Self {
-             config,
--            running: Arc::new(Mutex::new(false)),
-+            running: Arc::new(AtomicBool::new(false)),
-         })
-     }
--    /// Handle a client connection
--    pub fn handle_connection(&self, addr: SocketAddr, data: &[u8]) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--        if !self.is_running() {
--            return Err("Interface container is not running".into());
--        }
--        println!("Handling connection from {}, {} bytes", addr, data.len());
--        Ok(vec![5, 6, 7, 8])
--    }
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
--    }
- }
- 
-+#[async_trait::async_trait]
- impl Container for InterfaceContainer {
--    fn start(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        println!("Interface container started successfully");
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        log::info!(
-+            "Starting InterfaceContainer with max {} connections...",
-+            self.config.max_connections
-+        );
-+        self.running.store(true, Ordering::SeqCst);
-         Ok(())
-     }
- 
--    fn stop(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        println!("Interface container stopped successfully");
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        log::info!("Stopping InterfaceContainer...");
-+        self.running.store(false, Ordering::SeqCst);
-         Ok(())
-     }
- 
-     fn is_running(&self) -> bool {
--        self.is_running()
-+        self.running.load(Ordering::SeqCst)
-     }
- 
--    fn id(&self) -> &str {
-+    fn id(&self) -> &'static str {
-         "interface"
-     }
- }
-\ No newline at end of file
-diff --git a/crates/validator/src/hybrid/mod.rs b/crates/validator/src/hybrid/mod.rs
-index 06b0148..2a1f969 100644
---- a/crates/validator/src/hybrid/mod.rs
-+++ b/crates/validator/src/hybrid/mod.rs
-@@ -1,124 +1,8 @@
--//! Hybrid validator implementation (5 containers)
-+// Path: crates/validator/src/hybrid/mod.rs
- 
--mod interface;
--mod api;
-+pub mod api;
-+pub mod interface;
- 
--#[cfg(test)]
--mod tests;
--
--pub use interface::*;
--pub use api::*;
--use depin_sdk_core::error::ValidatorError;
--use depin_sdk_core::validator::{Container, ValidatorModel, ValidatorType};
--use std::error::Error;
--use std::path::Path;
--use crate::common::{GuardianContainer, SecurityChannel};
--use crate::standard::{OrchestrationContainer, WorkloadContainer};
--
--/// Hybrid validator with 5 containers
--pub struct HybridValidator {
--    /// Guardian container
--    pub guardian: GuardianContainer,
--    /// Orchestration container
--    pub orchestration: OrchestrationContainer,
--    /// Workload container
--    pub workload: WorkloadContainer,
--    /// Interface container
--    pub interface: InterfaceContainer,
--    /// API container
--    pub api: ApiContainer,
--    /// Security channels between containers
--    security_channels: Vec<SecurityChannel>,
--}
--
--impl HybridValidator {
--    /// Create a new hybrid validator
--    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_dir = config_dir.as_ref();
--        
--        // Create containers
--        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"))?;
--        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"))?;
--        let workload = WorkloadContainer::new(config_dir.join("workload.toml"))?;
--        let interface = InterfaceContainer::new(config_dir.join("interface.toml"))?;
--        let api = ApiContainer::new(config_dir.join("api.toml"))?;
--        
--        // Create security channels
--        let mut security_channels = Vec::new();
--        
--        // Guardian to Orchestration
--        let channel_g_o = SecurityChannel::new("guardian", "orchestration");
--        channel_g_o.establish()?;
--        security_channels.push(channel_g_o);
--        
--        // Orchestration to Workload
--        let channel_o_w = SecurityChannel::new("orchestration", "workload");
--        channel_o_w.establish()?;
--        security_channels.push(channel_o_w);
--        
--        // Orchestration to Interface
--        let channel_o_i = SecurityChannel::new("orchestration", "interface");
--        channel_o_i.establish()?;
--        security_channels.push(channel_o_i);
--        
--        // Interface to API
--        let channel_i_a = SecurityChannel::new("interface", "api");
--        channel_i_a.establish()?;
--        security_channels.push(channel_i_a);
--        
--        Ok(Self {
--            guardian,
--            orchestration,
--            workload,
--            interface,
--            api,
--            security_channels,
--        })
--    }
--}
--
--impl ValidatorModel for HybridValidator {
--    fn start(&self) -> Result<(), ValidatorError> {
--        // Start Guardian first
--        self.guardian.start()?;
--
--        // Start Orchestration
--        self.orchestration.start()?;
--
--        // Start Workload
--        self.workload.start()?;
--
--        // Start Interface
--        self.interface.start()?;
--
--        // Start API
--        self.api.start()?;
--
--        println!("Hybrid validator started successfully");
--        Ok(())
--    }
--
--    fn stop(&self) -> Result<(), ValidatorError> {
--        // Stop in reverse order
--        self.api.stop()?;
--        self.interface.stop()?;
--        self.workload.stop()?;
--        self.orchestration.stop()?;
--        self.guardian.stop()?;
--
--        println!("Hybrid validator stopped successfully");
--        Ok(())
--    }
--
--    fn is_running(&self) -> bool {
--        self.guardian.is_running()
--            && self.orchestration.is_running()
--            && self.workload.is_running()
--            && self.interface.is_running()
--            && self.api.is_running()
--    }
--
--    fn validator_type(&self) -> ValidatorType {
--        ValidatorType::Hybrid
--    }
--}
-\ No newline at end of file
-+// FIX: Publicly re-export the containers so they are visible to binaries.
-+pub use api::ApiContainer;
-+pub use interface::InterfaceContainer;
-\ No newline at end of file
-diff --git a/crates/validator/src/lib.rs b/crates/validator/src/lib.rs
-index a2dcbc3..7f7c60e 100644
---- a/crates/validator/src/lib.rs
-+++ b/crates/validator/src/lib.rs
-@@ -6,6 +6,8 @@ pub mod config;
- pub mod common;
- pub mod standard;
- pub mod hybrid;
-+// NEW: Public traits for this crate are defined here.
-+pub mod traits;
- 
--use std::error::Error;
--use depin_sdk_core::validator::ValidatorModel;
-\ No newline at end of file
-+// Re-export the new public trait.
-+pub use traits::WorkloadLogic;
-\ No newline at end of file
-diff --git a/crates/validator/src/standard/mod.rs b/crates/validator/src/standard/mod.rs
-index 482ad8f..04c7609 100644
---- a/crates/validator/src/standard/mod.rs
-+++ b/crates/validator/src/standard/mod.rs
-@@ -1,93 +1,7 @@
--//! Standard validator implementation (3 containers)
-+// Path: crates/validator/src/standard/mod.rs
- 
--mod orchestration;
--mod workload;
-+pub mod orchestration;
-+pub mod workload;
- 
--#[cfg(test)]
--mod tests;
--
--pub use orchestration::*;
--pub use workload::*;
--use depin_sdk_core::error::ValidatorError;
--use depin_sdk_core::validator::{Container, ValidatorModel, ValidatorType};
--use std::error::Error;
--use std::path::Path;
--use crate::common::{GuardianContainer, SecurityChannel};
--
--/// Standard validator with 3 containers
--pub struct StandardValidator {
--    /// Guardian container
--    pub guardian: GuardianContainer,
--    /// Orchestration container
--    pub orchestration: OrchestrationContainer,
--    /// Workload container
--    pub workload: WorkloadContainer,
--    /// Security channels between containers
--    security_channels: Vec<SecurityChannel>,
--}
--
--impl StandardValidator {
--    /// Create a new standard validator
--    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_dir = config_dir.as_ref();
--        
--        // Create containers
--        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"))?;
--        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"))?;
--        let workload = WorkloadContainer::new(config_dir.join("workload.toml"))?;
--        
--        // Create security channels
--        let mut security_channels = Vec::new();
--        
--        // Guardian to Orchestration
--        let channel_g_o = SecurityChannel::new("guardian", "orchestration");
--        channel_g_o.establish()?;
--        security_channels.push(channel_g_o);
--        
--        // Orchestration to Workload
--        let channel_o_w = SecurityChannel::new("orchestration", "workload");
--        channel_o_w.establish()?;
--        security_channels.push(channel_o_w);
--        
--        Ok(Self {
--            guardian,
--            orchestration,
--            workload,
--            security_channels,
--        })
--    }
--}
--
--impl ValidatorModel for StandardValidator {
--    fn start(&self) -> Result<(), ValidatorError> {
--        // Start Guardian first
--        self.guardian.start()?;
--
--        // Start Orchestration
--        self.orchestration.start()?;
--
--        // Start Workload
--        self.workload.start()?;
--
--        println!("Standard validator started successfully");
--        Ok(())
--    }
--
--    fn stop(&self) -> Result<(), ValidatorError> {
--        // Stop in reverse order
--        self.workload.stop()?;
--        self.orchestration.stop()?;
--        self.guardian.stop()?;
--
--        println!("Standard validator stopped successfully");
--        Ok(())
--    }
--
--    fn is_running(&self) -> bool {
--        self.guardian.is_running() && self.orchestration.is_running() && self.workload.is_running()
--    }
--
--    fn validator_type(&self) -> ValidatorType {
--        ValidatorType::Standard
--    }
--}
-\ No newline at end of file
-+// FIX: Publicly re-export the container so it's visible to binaries in the same crate.
-+pub use orchestration::OrchestrationContainer;
-\ No newline at end of file
-diff --git a/crates/validator/src/standard/orchestration.rs b/crates/validator/src/standard/orchestration.rs
-index f97b91b..9c780e1 100644
---- a/crates/validator/src/standard/orchestration.rs
-+++ b/crates/validator/src/standard/orchestration.rs
-@@ -1,60 +1,285 @@
--//! Implementation of orchestration container
-+// Path: crates/validator/src/standard/orchestration.rs
- 
- use crate::config::OrchestrationConfig;
--use depin_sdk_core::error::ValidatorError;
--use depin_sdk_core::validator::Container;
--use std::error::Error;
--use std::path::Path;
--use std::sync::{Arc, Mutex};
--
--/// Orchestration container for node functions and consensus
--pub struct OrchestrationContainer {
--    /// Parsed configuration for the Orchestration container.
--    config: OrchestrationConfig,
--    /// Running status
--    running: Arc<Mutex<bool>>,
-+use async_trait::async_trait;
-+use depin_sdk_core::{
-+    chain::SovereignChain,
-+    commitment::CommitmentScheme,
-+    error::ValidatorError,
-+    state::{StateManager, StateTree},
-+    transaction::TransactionModel,
-+    validator::{Container, WorkloadContainer},
-+};
-+use futures::StreamExt;
-+// ADDED: Import Multiaddr for the listen_on call
-+use libp2p::{
-+    core::upgrade, gossipsub, identity, noise, swarm::SwarmEvent, tcp, yamux, Multiaddr, Swarm,
-+    SwarmBuilder, Transport,
-+};
-+use std::fmt::Debug;
-+use std::sync::{
-+    atomic::{AtomicBool, Ordering},
-+    Arc,
-+};
-+use tokio::{
-+    sync::{watch, Mutex, OnceCell},
-+    task::JoinHandle,
-+    time::{self, Duration},
-+};
-+
-+pub struct OrchestrationContainer<CS, TM, ST>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-+    TM::Transaction: Clone + Debug + Send + Sync,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof> + Send + Sync + 'static + Debug,
-+{
-+    _config: OrchestrationConfig,
-+    chain: Arc<OnceCell<Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>>>,
-+    workload: Arc<OnceCell<Arc<WorkloadContainer<ST>>>>,
-+    pub swarm: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-+    shutdown_sender: Arc<watch::Sender<bool>>,
-+    task_handles: Arc<Mutex<Vec<JoinHandle<()>>>>,
-+    is_running: Arc<AtomicBool>,
- }
- 
--impl OrchestrationContainer {
--    /// Create a new orchestration container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--        let config: OrchestrationConfig = toml::from_str(&config_str)?;
-+impl<CS, TM, ST> OrchestrationContainer<CS, TM, ST>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-+    TM::Transaction: Clone + Debug + Send + Sync,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + Send
-+        + Sync
-+        + 'static
-+        + Debug,
-+    CS::Commitment: Send + Sync + Debug,
-+{
-+    pub async fn new(config_path: &std::path::Path) -> anyhow::Result<Self> {
-+        let _config: OrchestrationConfig =
-+            toml::from_str(&std::fs::read_to_string(config_path)?)?;
-+
-+        let (shutdown_sender, _) = watch::channel(false);
- 
--        println!("Orchestration config loaded. Consensus type: {:?}", config.consensus_type);
-+        let local_key = identity::Keypair::generate_ed25519();
-+
-+        let swarm = SwarmBuilder::with_existing_identity(local_key)
-+            .with_tokio()
-+            .with_other_transport(|key| {
-+                let noise_config = noise::Config::new(key)
-+                    .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
-+                let transport = tcp::tokio::Transport::new(tcp::Config::default())
-+                    .upgrade(upgrade::Version::V1Lazy)
-+                    .authenticate(noise_config)
-+                    .multiplex(yamux::Config::default())
-+                    .timeout(std::time::Duration::from_secs(20))
-+                    .boxed();
-+                Ok(transport)
-+            })?
-+            .with_behaviour(|key| {
-+                let gossipsub_config = gossipsub::Config::default();
-+                gossipsub::Behaviour::new(
-+                    gossipsub::MessageAuthenticity::Signed(key.clone()),
-+                    gossipsub_config,
-+                )
-+                .expect("Valid gossipsub config")
-+            })?
-+            .build();
- 
-         Ok(Self {
--            config,
--            running: Arc::new(Mutex::new(false)),
-+            _config,
-+            chain: Arc::new(OnceCell::new()),
-+            workload: Arc::new(OnceCell::new()),
-+            swarm: Arc::new(Mutex::new(swarm)),
-+            shutdown_sender: Arc::new(shutdown_sender),
-+            task_handles: Arc::new(Mutex::new(Vec::new())),
-+            is_running: Arc::new(AtomicBool::new(false)),
-         })
-     }
- 
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
-+    pub fn set_chain_and_workload_ref(
-+        &self,
-+        chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
-+        workload_ref: Arc<WorkloadContainer<ST>>,
-+    ) {
-+        self.chain.set(chain_ref).expect("Chain ref already set");
-+        self.workload
-+            .set(workload_ref)
-+            .expect("Workload ref already set");
-     }
--}
- 
--impl Container for OrchestrationContainer {
--    fn start(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        println!("Orchestration container started successfully");
--        Ok(())
-+    async fn run_event_loop(
-+        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-+        mut shutdown_receiver: watch::Receiver<bool>,
-+    ) {
-+        loop {
-+            tokio::select! {
-+                biased;
-+                _ = shutdown_receiver.changed() => {
-+                    if *shutdown_receiver.borrow() {
-+                        log::info!("Orchestration event loop received shutdown signal.");
-+                        break;
-+                    }
-+                },
-+                event = async { swarm_ref.lock().await.select_next_some().await } => {
-+                     match event {
-+                        SwarmEvent::Behaviour(gossipsub::Event::Message { message, .. }) => {
-+                            log::info!(
-+                                "Received block gossip from peer {:?}: '{}'",
-+                                message.source,
-+                                String::from_utf8_lossy(&message.data)
-+                            );
-+                        }
-+                        SwarmEvent::NewListenAddr { address, .. } => {
-+                            log::info!("OrchestrationContainer now listening on {}", address);
-+                        }
-+                        SwarmEvent::ConnectionEstablished { peer_id, .. } => {
-+                            log::info!("Connection established with peer: {:?}", peer_id);
-+                        }
-+                        _ => {}
-+                    }
-+                }
-+            }
-+        }
-     }
- 
--    fn stop(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        println!("Orchestration container stopped successfully");
--        Ok(())
-+    async fn run_block_production(
-+        chain_ref: Arc<Mutex<dyn SovereignChain<CS, TM, ST> + Send + Sync>>,
-+        workload_ref: Arc<WorkloadContainer<ST>>,
-+        swarm_ref: Arc<Mutex<Swarm<gossipsub::Behaviour>>>,
-+        is_running: Arc<AtomicBool>,
-+    ) {
-+        let mut interval = time::interval(Duration::from_secs(10));
-+        while is_running.load(Ordering::SeqCst) {
-+            interval.tick().await;
-+
-+            let new_block;
-+            {
-+                let mut chain = chain_ref.lock().await;
-+                let tm = chain.transaction_model().clone();
-+                let coinbase_result = tm
-+                    .create_coinbase_transaction(chain.status().height + 1, &[]);
-+                
-+                let coinbase = match coinbase_result {
-+                    Ok(tx) => tx,
-+                    Err(e) => {
-+                        log::error!("Failed to create coinbase transaction: {:?}", e);
-+                        continue;
-+                    }
-+                };
-+
-+                new_block = chain.create_block(vec![coinbase], &workload_ref);
-+
-+                if let Err(e) = chain
-+                    .process_block(new_block.clone(), &workload_ref)
-+                    .await
-+                {
-+                    log::error!("Failed to process new block: {:?}", e);
-+                    continue;
-+                }
-+                log::info!("Produced and processed new block #{}", new_block.header.height);
-+            }
-+            
-+            let swarm_clone = swarm_ref.clone();
-+            tokio::spawn(async move {
-+                let mut swarm = swarm_clone.lock().await;
-+                let topic = gossipsub::IdentTopic::new("blocks");
-+                let message_data = serde_json::to_vec(&new_block.header).unwrap_or_default();
-+
-+                if let Err(e) = swarm.behaviour_mut().publish(topic, message_data) {
-+                    log::warn!("Failed to publish block (likely no peers): {:?}", e);
-+                }
-+            });
-+        }
-+        log::info!("Orchestration block production loop finished.");
-+    }
-+}
-+
-+#[async_trait]
-+impl<CS, TM, ST> Container for OrchestrationContainer<CS, TM, ST>
-+where
-+    CS: CommitmentScheme + Send + Sync + 'static,
-+    TM: TransactionModel<CommitmentScheme = CS> + Clone + Send + Sync + 'static,
-+    TM::Transaction: Clone + Debug + Send + Sync,
-+    ST: StateManager<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + StateTree<Commitment = CS::Commitment, Proof = CS::Proof>
-+        + Send
-+        + Sync
-+        + 'static
-+        + Debug,
-+    CS::Commitment: Send + Sync + Debug,
-+{
-+    fn id(&self) -> &'static str {
-+        "orchestration_container"
-     }
- 
-     fn is_running(&self) -> bool {
--        self.is_running()
-+        self.is_running.load(Ordering::SeqCst)
-     }
- 
--    fn id(&self) -> &str {
--        "orchestration"
-+    async fn start(&self) -> Result<(), ValidatorError> {
-+        if self.is_running() {
-+            return Err(ValidatorError::AlreadyRunning(self.id().to_string()));
-+        }
-+        log::info!("OrchestrationContainer starting...");
-+
-+        // --- ADDED THIS BLOCK TO START LISTENING ---
-+        // Listen on all interfaces on a random OS-assigned TCP port.
-+        let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0"
-+            .parse()
-+            .expect("Invalid listen address format");
-+        self.swarm
-+            .lock()
-+            .await
-+            .listen_on(listen_addr)
-+            .map_err(|e| ValidatorError::Other(format!("Failed to listen on address: {}", e)))?;
-+        // --- END ADDED BLOCK ---
-+
-+        self.is_running.store(true, Ordering::SeqCst);
-+        
-+        let mut handles = self.task_handles.lock().await;
-+
-+        let event_loop_receiver = self.shutdown_sender.subscribe();
-+        let swarm_clone = self.swarm.clone();
-+        handles.push(tokio::spawn(async move {
-+            Self::run_event_loop(swarm_clone, event_loop_receiver).await;
-+        }));
-+
-+        let chain_clone = self.chain.get().unwrap().clone();
-+        let workload_clone = self.workload.get().unwrap().clone();
-+        let swarm_clone_2 = self.swarm.clone();
-+        let is_running_clone = self.is_running.clone();
-+
-+        handles.push(tokio::spawn(async move {
-+            Self::run_block_production(
-+                chain_clone,
-+                workload_clone,
-+                swarm_clone_2,
-+                is_running_clone,
-+            )
-+            .await;
-+        }));
-+
-+        Ok(())
-+    }
-+
-+    async fn stop(&self) -> Result<(), ValidatorError> {
-+        if !self.is_running() {
-+            return Ok(());
-+        }
-+        log::info!("OrchestrationContainer stopping...");
-+        self.is_running.store(false, Ordering::SeqCst);
-+        
-+        self.shutdown_sender.send(true).map_err(|e| {
-+            ValidatorError::Other(format!("Failed to send shutdown signal: {}", e))
-+        })?;
-+
-+        let mut handles = self.task_handles.lock().await;
-+        for handle in handles.drain(..) {
-+            handle.await.map_err(|e| ValidatorError::Other(format!("Task panicked during shutdown: {}", e)))?;
-+        }
-+
-+        Ok(())
-     }
- }
-\ No newline at end of file
-diff --git a/crates/validator/src/standard/workload.rs b/crates/validator/src/standard/workload.rs
-index 75daef6..ef4e935 100644
---- a/crates/validator/src/standard/workload.rs
-+++ b/crates/validator/src/standard/workload.rs
-@@ -1,67 +1,51 @@
--//! Implementation of workload container
-+// Path: crates/validator/src/standard/workload.rs
- 
--use crate::config::WorkloadConfig;
-+use crate::traits::WorkloadLogic;
-+use depin_sdk_core::commitment::CommitmentScheme;
- use depin_sdk_core::error::ValidatorError;
--use depin_sdk_core::validator::Container;
--use std::error::Error;
--use std::path::Path;
--use std::sync::{Arc, Mutex};
--
--/// Workload container for resource provisioning and execution
--pub struct WorkloadContainer {
--    /// Parsed configuration for the Workload container.
--    config: WorkloadConfig,
--    /// Running status
--    running: Arc<Mutex<bool>>,
--}
--
--impl WorkloadContainer {
--    /// Create a new workload container
--    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--        let config: WorkloadConfig = toml::from_str(&config_str)?;
--
--        println!("Workload config loaded. Enabled VMs: {:?}", config.enabled_vms);
--
--        Ok(Self {
--            config,
--            running: Arc::new(Mutex::new(false)),
--        })
--    }
--    /// Execute a transaction
--    pub fn execute_transaction(&self, tx_data: &[u8]) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--        if !self.is_running() {
--            return Err("Workload container is not running".into());
-+use depin_sdk_core::state::{StateManager, StateTree};
-+use depin_sdk_core::transaction::TransactionModel;
-+use depin_sdk_core::validator::WorkloadContainer;
-+
-+impl<ST> WorkloadLogic<ST> for WorkloadContainer<ST>
-+where
-+    // FIX: The bound must be StateManager (which implies StateTree) and Sized.
-+    ST: StateManager + Send + Sync,
-+{
-+    fn execute_transaction<CS, TM>(
-+        &self,
-+        tx: &TM::Transaction,
-+        model: &TM,
-+    ) -> impl std::future::Future<Output = Result<(), ValidatorError>> + Send
-+    where
-+        CS: CommitmentScheme<
-+            Commitment = <ST as StateTree>::Commitment,
-+            Proof = <ST as StateTree>::Proof,
-+        >,
-+        TM: TransactionModel<CommitmentScheme = CS> + Sync,
-+        TM::Transaction: Sync,
-+        // FIX: The bound `ST: StateManager` is now satisfied by the impl block's bounds.
-+        ST: StateManager,
-+    {
-+        async move {
-+            let state_tree_arc = self.state_tree();
-+            let mut state = state_tree_arc.lock().await;
-+
-+            let is_valid = model
-+                .validate(tx, &*state)
-+                .map_err(|e| ValidatorError::Other(e.to_string()))?;
-+            if !is_valid {
-+                return Err(ValidatorError::Other(
-+                    "Transaction validation failed".to_string(),
-+                ));
-+            }
-+
-+            model
-+                .apply(tx, &mut *state)
-+                .map_err(|e| ValidatorError::Other(e.to_string()))?;
-+
-+            log::info!("Successfully executed transaction and updated state.");
-+            Ok(())
-         }
--        println!("Executing transaction of {} bytes", tx_data.len());
--        Ok(tx_data.to_vec())
--    }
--    /// Check if the container is running
--    pub fn is_running(&self) -> bool {
--        *self.running.lock().unwrap()
--    }
--}
--
--impl Container for WorkloadContainer {
--    fn start(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = true;
--        println!("Workload container started successfully");
--        Ok(())
--    }
--
--    fn stop(&self) -> Result<(), ValidatorError> {
--        let mut running = self.running.lock().unwrap();
--        *running = false;
--        println!("Workload container stopped successfully");
--        Ok(())
--    }
--
--    fn is_running(&self) -> bool {
--        self.is_running()
--    }
--
--    fn id(&self) -> &str {
--        "workload"
-     }
- }
-\ No newline at end of file
-diff --git a/output.txt b/output.txt
-index bf55fc0..bffcedd 100644
---- a/output.txt
-+++ b/output.txt
-@@ -1,2750 +0,0 @@
--diff --git a/codebase_snapshot.md b/codebase_snapshot.md
--index 6994984..930eaaf 100644
----- a/codebase_snapshot.md
--+++ b/codebase_snapshot.md
--@@ -1,12 +1,12 @@
-- # Codebase Snapshot: crates
---Created: Sun Jul 27 01:34:13 PM UTC 2025
--+Created: Sun Jul 27 10:33:24 PM UTC 2025
-- Target: /workspaces/depin-sdk/crates
-- Line threshold for included files: 1500
-- 
-- ## Summary Statistics
-- 
---* Total files: 153
---* Total directories: 110
--+* Total files: 150
--+* Total directories: 111
-- 
-- ### Directory: /workspaces/depin-sdk/crates
-- 
--@@ -378,7 +378,7 @@ fn test_max_recent_blocks() {
-- }```
-- 
-- ####### File: chain/src/app/mod.rs
---####*Size: 20K, Lines: 546, Type: ASCII text*
--+####*Size: 20K, Lines: 569, Type: ASCII text*
-- 
-- ```rust
-- use depin_sdk_core::commitment::CommitmentScheme;
--@@ -388,11 +388,14 @@ use depin_sdk_core::state::{StateManager, StateTree};
-- use depin_sdk_core::transaction::TransactionModel;
-- use depin_sdk_core::validator::ValidatorModel;
-- use crate::upgrade_manager::ModuleUpgradeManager;
--+use depin_sdk_state_trees::file::FileStateTree;
--+use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
--+
-- use std::sync::Arc;
-- use std::time::{Duration, SystemTime, UNIX_EPOCH};
-- 
-- /// Block header containing metadata
---#[derive(Debug, Clone)]
--+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-- pub struct BlockHeader {
--     /// Block height
--     pub height: u64,
--@@ -407,7 +410,7 @@ pub struct BlockHeader {
-- }
-- 
-- /// Block structure containing transactions
---#[derive(Debug, Clone)]
--+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-- pub struct Block<T> {
--     /// Block header
--     pub header: BlockHeader,
--@@ -669,7 +672,11 @@ where
--     //
-- 
--     /// Process a block
---    pub fn process_block(&mut self, mut block: Block<TM::Transaction>) -> Result<(), String> {
--+    pub fn process_block(&mut self, mut block: Block<TM::Transaction>) -> Result<(), String>
--+    where
--+        CS: Clone,
--+        CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--+    {
--         // Ensure block is built on current chain state
--         if block.header.height != self.status.height + 1 {
--             return Err(format!(
--@@ -742,6 +749,22 @@ where
--             self.recent_blocks.remove(0); // Remove oldest block
--         }
-- 
--+        // Periodically save state if the state tree supports it (e.g., FileStateTree)
--+        if self.status.height % 10 == 0 {
--+            // This uses `as_any()` and `downcast_ref` to check if the state tree is a `FileStateTree`
--+            // without breaking the generic `ST` constraint. This is a common pattern for
--+            // accessing concrete type features from generic code.
--+            if let Some(persistable_tree) = self.state_tree.as_any().downcast_ref::<FileStateTree<CS>>() {
--+                // Now valid because of the `where` clause on this method
--+                if let Err(e) = persistable_tree.save() {
--+                    eprintln!("[Warning] Periodic state save failed at height {}: {}", self.status.height, e);
--+                } else {
--+                    println!("State periodically saved at height {}", self.status.height);
--+                }
--+            }
--+        }
--+
--+
--         Ok(())
--     }
-- 
--@@ -932,218 +955,382 @@ mod tests;```
-- ###### Directory: chain/src/bin
-- 
-- ####### File: chain/src/bin/mvsc.rs
---####*Size: 8.0K, Lines: 212, Type: C source, ASCII text*
--+####*Size: 16K, Lines: 376, Type: C source, ASCII text*
-- 
-- ```rust
-- //! # Minimum Viable Single-Node Chain (MVSC)
-- //!
---//! This binary assembles and runs a self-contained, in-memory blockchain
---//! using components from the DePIN SDK. It demonstrates the end-to-end
---//! integration of the state tree, commitment scheme, transaction model,
---//! and the new `dcrypt`-backed crypto layer.
---
---// --- IMPORTS ---
---use depin_sdk_chain::app::SovereignAppChain;
--+//! Now with persistence and P2P networking!
--+//!
--+//! This binary runs a blockchain node that can:
--+//! 1. Persist its state to `state.json` and resume after a restart.
--+//! 2. Discover other nodes on the local network using mDNS.
--+//! 3. Gossip new blocks to peers using libp2p.
--+//! 4. Process blocks received from peers.
--+
--+use clap::Parser;
--+use depin_sdk_chain::app::{Block, SovereignAppChain};
-- use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
---use depin_sdk_core::{
---    commitment::CommitmentScheme,
---    crypto::{SerializableKey, SigningKeyPair},
---    state::{StateManager, StateTree},
---    transaction::TransactionModel,
---    validator::{ValidatorModel, ValidatorType},
---};
--+use depin_sdk_core::crypto::{SerializableKey, SigningKeyPair, SigningKey};
--+use depin_sdk_core::validator::{ValidatorModel, ValidatorType};
-- use depin_sdk_crypto::algorithms::hash::sha256;
---use depin_sdk_crypto::sign::eddsa::Ed25519KeyPair;
---use depin_sdk_state_trees::hashmap::HashMapStateTree;
---use depin_sdk_transaction_models::utxo::{UTXOInput, UTXOOutput, UTXOTransaction, UTXOModel};
---use std::sync::atomic::{AtomicU64, Ordering};
--+use depin_sdk_crypto::sign::eddsa::{Ed25519KeyPair, Ed25519PrivateKey};
--+use depin_sdk_state_trees::file::FileStateTree; // Use our new FileStateTree
--+use depin_sdk_transaction_models::utxo::{UTXOInput, UTXOOutput, UTXOTransaction, UTXOModel, UTXOOperations};
--+use std::fs;
--+
--+use futures::stream::StreamExt;
--+use libp2p::{gossipsub, mdns, swarm::SwarmEvent};
--+use std::hash::{Hash, Hasher};
--+use std::sync::{atomic::{AtomicU64, Ordering}, Arc};
-- use std::time::Duration;
--+use tokio::sync::{mpsc, Mutex, Notify};
--+
--+
--+// --- LIBP2P NETWORKING SETUP ---
--+
--+// We create a custom network behaviour that combines Gossipsub and Mdns.
--+#[derive(libp2p::swarm::NetworkBehaviour)]
--+struct MyBehaviour {
--+    gossipsub: gossipsub::Behaviour,
--+    mdns: mdns::tokio::Behaviour,
--+}
--+
--+const BLOCK_TOPIC: &str = "blocks";
--+const KEYPAIR_SEED_FILE: &str = "keypair.seed";
--+
--+// --- COMMAND LINE ARGUMENTS ---
--+
--+#[derive(Parser, Debug)]
--+#[clap(name = "mvsc", about = "A minimum viable sovereign chain node.")]
--+struct Opts {
--+    /// Listening port for the p2p network.
--+    #[clap(long, default_value = "0")]
--+    listen_port: u16,
--+
--+    /// Flag to indicate if this node should produce blocks.
--+    #[clap(long)]
--+    is_producer: bool,
--+
--+    /// Path to the state file.
--+    #[clap(long, default_value = "state.json")]
--+    state_file: String,
--+
--+    /// Path to the keypair seed file.
--+    #[clap(long, default_value = "keypair.seed")]
--+    keypair_file: String,
--+}
--+
-- 
-- // --- MOCK VALIDATOR MODEL ---
-- // A simple validator model implementation for the in-memory chain.
---// Adapted from `depin-sdk-chain` tests.
-- struct MockValidatorModel {
--     running: std::cell::RefCell<bool>,
-- }
-- 
-- impl MockValidatorModel {
---    fn new() -> Self {
---        Self {
---            running: std::cell::RefCell::new(false),
---        }
---    }
--+    fn new() -> Self { Self { running: std::cell::RefCell::new(false) } }
-- }
-- 
-- impl ValidatorModel for MockValidatorModel {
---    fn start(&self) -> Result<(), String> {
---        *self.running.borrow_mut() = true;
---        Ok(())
---    }
---
---    fn stop(&self) -> Result<(), String> {
---        *self.running.borrow_mut() = false;
---        Ok(())
---    }
---
---    fn is_running(&self) -> bool {
---        *self.running.borrow()
---    }
---
---    fn validator_type(&self) -> ValidatorType {
---        ValidatorType::Standard
---    }
--+    fn start(&self) -> Result<(), String> { *self.running.borrow_mut() = true; Ok(()) }
--+    fn stop(&self) -> Result<(), String> { *self.running.borrow_mut() = false; Ok(()) }
--+    fn is_running(&self) -> bool { *self.running.borrow() }
--+    fn validator_type(&self) -> ValidatorType { ValidatorType::Standard }
-- }
-- 
---// --- TRANSACTION CREATION HELPER ---
---/// Creates a dummy UTXO transaction for demonstration purposes.
---/// Each new transaction spends the output of the previous one.
--+// --- TRANSACTION CREATION HELPERS ---
-- fn create_dummy_transaction(
--     keypair: &Ed25519KeyPair,
--     nonce: u64,
--     prev_txid: Vec<u8>,
-- ) -> UTXOTransaction {
--     let mut tx = UTXOTransaction {
---        txid: Vec::new(), // To be filled after signing
--+        txid: Vec::new(),
--         inputs: vec![UTXOInput {
--             prev_txid,
--             prev_index: 0,
---            signature: Vec::new(), // To be filled after signing
--+            signature: Vec::new(),
--         }],
--         outputs: vec![UTXOOutput {
--             value: 100,
---            lock_script: keypair.public_key().to_bytes(), // Lock to our own key for simplicity
--+            lock_script: keypair.public_key().to_bytes(),
--         }],
--     };
---
---    // Create a digest for signing. A real implementation would have a more
---    // robust and standardized serialization format for signing.
--     let mut digest_data = Vec::new();
--     digest_data.extend_from_slice(&tx.inputs[0].prev_txid);
---    digest_data.extend_from_slice(&tx.inputs[0].prev_index.to_le_bytes());
---    digest_data.extend_from_slice(&tx.outputs[0].value.to_le_bytes());
---    digest_data.extend_from_slice(&tx.outputs[0].lock_script);
---    digest_data.extend_from_slice(&nonce.to_le_bytes()); // Add nonce to make each tx hash unique
--     
--     let digest = sha256(&digest_data);
---
---    // Sign the digest using the dcrypt-backed Ed25519 implementation
--     let signature = keypair.sign(&digest);
--     tx.inputs[0].signature = signature.to_bytes();
---
---    // The transaction ID is the hash of the signed transaction data
--     let mut txid_data = Vec::new();
--     txid_data.extend_from_slice(&digest);
--     txid_data.extend_from_slice(&tx.inputs[0].signature);
--     tx.txid = sha256(&txid_data);
---
--     tx
-- }
-- 
---/// Creates a genesis transaction that creates initial UTXOs from nothing
-- fn create_genesis_transaction(keypair: &Ed25519KeyPair) -> UTXOTransaction {
--     let mut tx = UTXOTransaction {
--         txid: Vec::new(),
---        inputs: vec![], // No inputs for genesis/coinbase transaction
--+        inputs: vec![],
--         outputs: vec![UTXOOutput {
---            value: 1000000, // Initial supply
--+            value: 1_000_000,
--             lock_script: keypair.public_key().to_bytes(),
--         }],
--     };
---
---    // For genesis, we just hash the outputs
--     let mut digest_data = Vec::new();
--     digest_data.extend_from_slice(b"GENESIS");
--     digest_data.extend_from_slice(&tx.outputs[0].value.to_le_bytes());
--     digest_data.extend_from_slice(&tx.outputs[0].lock_script);
---    
--     tx.txid = sha256(&digest_data);
--     tx
-- }
-- 
--+/// Loads a keypair from a seed file, or creates a new one if it doesn't exist.
--+fn load_or_create_keypair(path: &str) -> Ed25519KeyPair {
--+    match fs::read(path) {
--+        Ok(seed_bytes) => {
--+            log::info!("Loading persistent keypair from {}", path);
--+            let private_key = Ed25519PrivateKey::from_bytes(&seed_bytes)
--+                .expect("Failed to create private key from seed file");
--+            Ed25519KeyPair::from_private_key(&private_key)
--+        }
--+        Err(_) => {
--+            log::info!("No keypair found at {}, creating a new one.", path);
--+            let keypair = Ed25519KeyPair::generate();
--+            fs::write(path, keypair.private_key().to_bytes())
--+                .expect("Failed to write new keypair seed to file");
--+            keypair
--+        }
--+    }
--+}
--+
--+
-- // --- MAIN APPLICATION ---
-- #[tokio::main]
---async fn main() {
---    println!("Starting Minimum Viable Single-Node Chain (MVSC)...");
--+async fn main() -> anyhow::Result<()> {
--+    env_logger::builder().filter_level(log::LevelFilter::Info).init();
--+    let opts = Opts::parse();
-- 
---    // Step 1: Instantiate Components
--+    // --- CHAIN SETUP ---
--+    log::info!("Starting Minimum Viable Sovereign Chain (MVSC)...");
--     let commitment_scheme = HashCommitmentScheme::new();
---    let state_tree = HashMapStateTree::new(commitment_scheme.clone());
--+    let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
--     let transaction_model = UTXOModel::new(commitment_scheme.clone());
--     let validator_model = MockValidatorModel::new();
-- 
---    // Step 2: Instantiate SovereignAppChain
---    let mut chain = SovereignAppChain::new(
--+    let chain = Arc::new(Mutex::new(SovereignAppChain::new(
--         commitment_scheme,
--         state_tree,
--         transaction_model,
--         validator_model,
--         "mvsc-chain-1",
---        vec![], // No initial services
---    );
--+        vec![],
--+    )));
--+
--+    // --- P2P NETWORK SETUP ---
--+    let mut swarm = libp2p::SwarmBuilder::with_new_identity()
--+        .with_tokio()
--+        .with_tcp(
--+            libp2p::tcp::Config::default(),
--+            libp2p::noise::Config::new,
--+            libp2p::yamux::Config::default,
--+        )?
--+        .with_behaviour(|key| {
--+            let message_id_fn = |message: &gossipsub::Message| {
--+                let mut s = std::collections::hash_map::DefaultHasher::new();
--+                message.data.hash(&mut s);
--+                gossipsub::MessageId::from(s.finish().to_string())
--+            };
--+            let gossipsub_config = gossipsub::ConfigBuilder::default()
--+                .message_id_fn(message_id_fn)
--+                // For a small test network, we don't need to wait for a mesh to form to publish.
--+                .mesh_outbound_min(1)
--+                .build()?;
--+            Ok(MyBehaviour {
--+                gossipsub: gossipsub::Behaviour::new(
--+                    gossipsub::MessageAuthenticity::Signed(key.clone()),
--+                    gossipsub_config,
--+                )?,
--+                mdns: mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?,
--+            })
--+        })?
--+        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
--+        .build();
--+    
--+    let topic = gossipsub::IdentTopic::new(BLOCK_TOPIC);
--+    swarm.behaviour_mut().gossipsub.subscribe(&topic)?;
--+
--+    let listen_addr = format!("/ip4/0.0.0.0/tcp/{}", opts.listen_port);
--+    swarm.listen_on(listen_addr.parse()?)?;
--+    log::info!("Local Peer ID: {}", swarm.local_peer_id());
--+
--+    // Channel for the block producer to send new blocks to the main event loop.
--+    let (block_tx, mut block_rx) = mpsc::channel::<Vec<u8>>(32);
--+
--+    // Notifier to signal the producer task when it's okay to start.
--+    let producer_start_signal = Arc::new(Notify::new());
--+
--+    // --- BLOCK PRODUCTION (if enabled) ---
--+    if opts.is_producer {
--+        let chain_clone = Arc::clone(&chain);
--+        let start_signal_clone = Arc::clone(&producer_start_signal);
--+        let keypair_file = opts.keypair_file.clone();
--+        tokio::spawn(async move {
--+            let keypair = load_or_create_keypair(&keypair_file);
--+            let nonce = AtomicU64::new(0);
--+            let mut last_txid: Vec<u8>;
--+
--+            // Create and process genesis block if chain is new
--+            {
--+                let mut chain_lock = chain_clone.lock().await;
--+                if chain_lock.status().height == 0 {
--+                    log::info!("Block producer is waiting for the first peer to connect...");
--+                    start_signal_clone.notified().await;
--+                    
--+                    // Give gossipsub a moment to establish the connection fully.
--+                    tokio::time::sleep(Duration::from_secs(2)).await;
--+                    log::info!("Peer connected! Creating and gossiping genesis block.");
--+
--+                    log::info!("Chain is at genesis height, creating genesis block...");
--+                    let genesis_tx = create_genesis_transaction(&keypair);
--+                    last_txid = genesis_tx.txid.clone();
--+                    let genesis_block = chain_lock.create_block(vec![genesis_tx]);
--+                    chain_lock.process_block(genesis_block.clone()).expect("Failed to process genesis block");
--+                    
--+                    let block_bytes = serde_json::to_vec(&genesis_block).unwrap();
--+                    if let Err(e) = block_tx.send(block_bytes).await {
--+                         log::error!("Failed to send genesis block to main loop: {:?}", e);
--+                    }
--+                } else {
--+                    log::info!("Chain is at height {}, resuming block production.", chain_lock.status().height);
--+                    // Find the last UTXO owned by this keypair to continue the transaction chain.
--+                    // This is a naive scan; a real wallet would use an index.
--+                    let tm = chain_lock.transaction_model();
--+                    let pk_bytes = keypair.public_key().to_bytes();
--+                    
--+                    // This is a placeholder for finding the last txid.
--+                    // For this demo, we'll restart with a new "coinbase" tx in the next block.
--+                    // A proper implementation would require iterating through the state.
--+                    let coinbase_tx = create_genesis_transaction(&keypair);
--+                    last_txid = coinbase_tx.txid.clone();
--+                    let block = chain_lock.create_block(vec![coinbase_tx]);
--+                    chain_lock.process_block(block).expect("Failed to create resumption block");
--+                }
--+            }
-- 
---    // Start the chain logic
---    if let Err(e) = chain.start() {
---        eprintln!("Failed to start chain: {}", e);
---        return;
---    }
---    println!("Chain started successfully. Producing a new block every 5 seconds.");
-- 
---    // Create a persistent Ed25519 keypair for signing all dummy transactions
---    let keypair = Ed25519KeyPair::generate();
---    println!("Generated signing keypair for dummy transactions.");
---
---    // Create and process genesis block
---    println!("Creating genesis block...");
---    let genesis_tx = create_genesis_transaction(&keypair);
---    let genesis_txid = genesis_tx.txid.clone();
---    println!("  -> Created genesis transaction with txid: 0x{}", hex::encode(&genesis_txid));
---    
---    let genesis_block = chain.create_block(vec![genesis_tx]);
---    match chain.process_block(genesis_block) {
---        Ok(_) => {
---            let status = chain.status();
---            let state_commitment = chain.get_state_commitment();
---            let state_root_bytes: &[u8] = state_commitment.as_ref();
---            println!(
---                "Processed Genesis Block. New State Root: 0x{}",
---                hex::encode(state_root_bytes)
---            );
---        }
---        Err(e) => {
---            eprintln!("Error processing genesis block: {}", e);
---            return;
---        }
---    }
--+            let mut interval = tokio::time::interval(Duration::from_secs(5));
--+            loop {
--+                interval.tick().await;
--+                let current_nonce = nonce.fetch_add(1, Ordering::SeqCst);
--+                let dummy_tx = create_dummy_transaction(&keypair, current_nonce, last_txid.clone());
--+                last_txid = dummy_tx.txid.clone();
-- 
---    let nonce = AtomicU64::new(0);
---    let mut last_txid = genesis_txid; // Start with genesis transaction ID
--+                let mut chain_lock = chain_clone.lock().await;
--+                let block = chain_lock.create_block(vec![dummy_tx]);
--+                
--+                log::info!("Producing Block #{}", block.header.height);
--+
--+                match chain_lock.process_block(block.clone()) {
--+                    Ok(_) => {
--+                        let status = chain_lock.status();
--+                        let state_commitment = chain_lock.get_state_commitment();
--+                        let state_root: &[u8] = state_commitment.as_ref();
--+                        log::info!(
--+                            "Locally processed Block #{}. New State Root: 0x{}",
--+                            status.height,
--+                            hex::encode(state_root)
--+                        );
--+
--+                        let block_bytes = serde_json::to_vec(&block).unwrap();
--+                        if let Err(e) = block_tx.send(block_bytes).await {
--+                            log::error!("Failed to send block to main loop: {:?}", e);
--+                        }
--+                    }
--+                    Err(e) => {
--+                        log::error!("Error processing locally produced block: {}", e);
--+                    }
--+                }
--+            }
--+        });
--+    }
-- 
---    // Step 3 & 4: Main Loop for Block Production and Transaction Creation
--+    // --- MAIN EVENT LOOP ---
--     loop {
---        // Wait for 5 seconds to simulate block time
---        tokio::time::sleep(Duration::from_secs(5)).await;
---
---        // Create a dummy transaction that spends the output of the previous one
---        let current_nonce = nonce.fetch_add(1, Ordering::SeqCst);
---        let dummy_tx = create_dummy_transaction(&keypair, current_nonce, last_txid.clone());
---        println!("  -> Created dummy transaction with txid: 0x{}", hex::encode(&dummy_tx.txid));
---        last_txid = dummy_tx.txid.clone(); // Chain to the next transaction
---
---        // Create and process a block containing the new transaction
---        let block = chain.create_block(vec![dummy_tx]);
---        match chain.process_block(block) {
---            Ok(_) => {
---                let status = chain.status();
---                let state_commitment = chain.get_state_commitment();
---                let state_root_bytes: &[u8] = state_commitment.as_ref();
---                println!(
---                    "Processed Block #{}. New State Root: 0x{}",
---                    status.height,
---                    hex::encode(state_root_bytes)
---                );
---            }
---            Err(e) => {
---                eprintln!("Error processing block: {}", e);
--+        tokio::select! {
--+            // Handle events from the p2p network
--+            event = swarm.select_next_some() => {
--+                match event {
--+                    SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {
--+                        for (peer_id, _multiaddr) in list {
--+                            log::info!("mDNS discovered a new peer: {}", peer_id);
--+                            swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
--+
--+                            producer_start_signal.notify_one();
--+                        }
--+                    }
--+                    SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
--+                        for (peer_id, _multiaddr) in list {
--+                            log::info!("mDNS discover peer has expired: {}", peer_id);
--+                            swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);
--+                        }
--+                    }
--+                    SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {
--+                        propagation_source: peer_id,
--+                        message_id: id,
--+                        message,
--+                    })) => {
--+                        log::info!(
--+                            "Got new gossip message with id: {} from peer: {}",
--+                            id,
--+                            peer_id
--+                        );
--+                        
--+                        type AppBlock = Block<UTXOTransaction>;
--+                        match serde_json::from_slice::<AppBlock>(&message.data) {
--+                            Ok(block) => {
--+                                let mut chain_lock = chain.lock().await;
--+                                log::info!("Received Block #{} from network.", block.header.height);
--+
--+                                if block.header.height <= chain_lock.status().height {
--+                                    log::info!("Ignoring old or duplicate block (height {}). Current height is {}.", block.header.height, chain_lock.status().height);
--+                                    continue;
--+                                }
--+
--+                                match chain_lock.process_block(block) {
--+                                    Ok(_) => {
--+                                        let status = chain_lock.status();
--+                                        let state_commitment = chain_lock.get_state_commitment();
--+                                        let state_root: &[u8] = state_commitment.as_ref();
--+                                        log::info!(
--+                                            "Processed network Block #{}. New State Root: 0x{}",
--+                                            status.height,
--+                                            hex::encode(state_root)
--+                                        );
--+                                    }
--+                                    Err(e) => {
--+                                        log::error!("Error processing block from network: {}", e);
--+                                    }
--+                                }
--+                            }
--+                            Err(e) => {
--+                                log::error!("Failed to deserialize block: {:?}", e);
--+                            }
--+                        }
--+                    }
--+                    SwarmEvent::NewListenAddr { address, .. } => {
--+                        log::info!("Local node is listening on {}", address);
--+                    }
--+                    _ => {}
--+                }
--+            },
--+            // Handle blocks produced locally that need to be gossiped
--+            Some(block_to_gossip) = block_rx.recv() => {
--+                if let Err(e) = swarm.behaviour_mut().gossipsub.publish(topic.clone(), block_to_gossip) {
--+                    log::error!("Failed to publish block: {:?}", e);
--+                }
--             }
--         }
--     }
--@@ -1360,7 +1547,7 @@ mod tests {
-- }```
-- 
-- ##### File: chain/Cargo.toml
---##*Size: 4.0K, Lines: 35, Type: ASCII text*
--+##*Size: 4.0K, Lines: 57, Type: ASCII text*
-- 
-- ```toml
-- [package]
--@@ -1378,21 +1565,43 @@ depin-sdk-state-trees = { path = "../state_trees" }
-- depin-sdk-transaction-models = { path = "../transaction_models" }
-- depin-sdk-validator = { path = "../validator" }
-- log = { workspace = true }
---serde = { workspace = true }
--+serde = { workspace = true, features = ["derive"] }
--+serde_json = { workspace = true }
-- thiserror = { workspace = true }
-- anyhow = { workspace = true }
-- 
-- # Dependencies added for the mvsc binary, made optional
-- depin-sdk-crypto = { path = "../crypto", optional = true }
-- tokio = { workspace = true, features = ["full"], optional = true }
--+futures = { workspace = true, optional = true }
-- hex = { version = "0.4", optional = true }
--+clap = { version = "4.3", features = ["derive"], optional = true }
--+env_logger = { version = "0.10", optional = true }
--+libp2p = { version = "0.52", features = [
--+    "tokio",
--+    "gossipsub",
--+    "mdns",
--+    "macros",
--+    "tcp",
--+    "noise",
--+    "yamux",
--+], optional = true }
--+
-- 
-- [features]
-- default = []
-- tendermint = []
-- custom-consensus = []
-- # Feature to enable building the binary and its dependencies
---mvsc-bin = ["dep:depin-sdk-crypto", "dep:tokio", "dep:hex"]
--+mvsc-bin = [
--+    "dep:depin-sdk-crypto",
--+    "dep:tokio",
--+    "dep:futures",
--+    "dep:hex",
--+    "dep:clap",
--+    "dep:env_logger",
--+    "dep:libp2p",
--+]
-- 
-- [[bin]]
-- name = "mvsc"
--@@ -5141,11 +5350,12 @@ pub type StateTreeFor<CS> = dyn StateTree<
-- ```
-- 
-- ####### File: core/src/state/tree.rs
---####*Size: 4.0K, Lines: 60, Type: ASCII text*
--+####*Size: 4.0K, Lines: 65, Type: ASCII text*
-- 
-- ```rust
-- // File: crates/core/src/state/tree.rs
-- 
--+use std::any::Any;
-- use crate::error::StateError;
-- 
-- /// Generic state tree operations
--@@ -5204,6 +5414,10 @@ pub trait StateTree {
--         key: &[u8],
--         value: &[u8]
--     ) -> bool;
--+
--+    /// Provide access to the concrete type for downcasting.
--+    fn as_any(&self) -> &dyn Any;
--+    
-- }```
-- 
-- ###### Directory: core/src/test_utils
--@@ -12434,24 +12648,213 @@ default = []
-- 
-- ##### Directory: state_trees/src
-- 
--+###### Directory: state_trees/src/file
--+
--+####### File: state_trees/src/file/mod.rs
--+####*Size: 8.0K, Lines: 181, Type: C source, ASCII text*
--+
--+```rust
--+use depin_sdk_core::commitment::CommitmentScheme;
--+use depin_sdk_core::error::StateError;
--+use depin_sdk_core::state::{StateManager, StateTree};
--+use crate::HashMapStateTree;
--+use serde::{Deserialize, Serialize};
--+use std::collections::HashMap;
--+use std::fs;
--+use std::path::{Path, PathBuf};
--+use std::any::Any;
--+use std::sync::{Arc, RwLock};
--+
--+// A serializable representation of the state, using hex strings for keys and values.
--+#[derive(Serialize, Deserialize, Default)]
--+struct SerializableState(HashMap<String, String>);
--+
--+/// A state tree that persists its state to a JSON file.
--+/// It wraps an in-memory HashMapStateTree and adds load/save functionality.
--+pub struct FileStateTree<CS: CommitmentScheme + Clone>
--+where
--+    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--+{
--+    // The inner, in-memory state tree.
--+    inner: HashMapStateTree<CS>,
--+    // Path to the state file on disk.
--+    path: PathBuf,
--+    // We use an Arc<RwLock<()>> as a simple, cheap way to prevent saves
--+    // from happening concurrently, which could corrupt the file.
--+    save_lock: Arc<RwLock<()>>,
--+}
--+
--+impl<CS: CommitmentScheme + Clone> FileStateTree<CS>
--+where
--+    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--+{
--+    /// Creates a new FileStateTree.
--+    ///
--+    /// It attempts to load the initial state from the file at `path`.
--+    /// If the file doesn't exist, it starts with an empty state.
--+    pub fn new<P: AsRef<Path>>(path: P, scheme: CS) -> Self {
--+        let mut tree = Self {
--+            inner: HashMapStateTree::new(scheme),
--+            path: path.as_ref().to_path_buf(),
--+            save_lock: Arc::new(RwLock::new(())),
--+        };
--+
--+        if let Err(e) = tree.load() {
--+            // Log a warning if loading fails, but don't panic.
--+            // This allows the node to start fresh if the state file is corrupted or unreadable.
--+            eprintln!("[Warning] Failed to load state from {:?}: {}. Starting with a fresh state.", tree.path, e);
--+        }
--+        tree
--+    }
--+
--+    /// Loads the state from the JSON file.
--+    pub fn load(&mut self) -> Result<(), StateError> {
--+        if !self.path.exists() {
--+            println!("State file not found at {:?}, starting new state.", self.path);
--+            return Ok(());
--+        }
--+
--+        let json_data = fs::read_to_string(&self.path)
--+            .map_err(|e| StateError::ReadError(e.to_string()))?;
--+            
--+        let serializable_map: SerializableState = serde_json::from_str(&json_data)
--+            .map_err(|e| StateError::ReadError(format!("JSON deserialization error: {}", e)))?;
--+
--+        self.inner.data.clear();
--+        for (k_hex, v_hex) in serializable_map.0 {
--+            let k = hex::decode(&k_hex)
--+                .map_err(|e| StateError::InvalidKey(format!("Hex decode error: {}", e)))?;
--+            let v_bytes = hex::decode(&v_hex)
--+                .map_err(|e| StateError::InvalidValue(format!("Hex decode error: {}", e)))?;
--+            
--+            self.inner.data.insert(k, CS::Value::from(v_bytes));
--+        }
--+
--+        println!("Successfully loaded state with {} entries from {:?}", self.inner.data.len(), self.path);
--+        Ok(())
--+    }
--+
--+    /// Saves the current state to the JSON file.
--+    pub fn save(&self) -> Result<(), StateError> {
--+        // Acquire a write lock to ensure only one save operation happens at a time.
--+        let _lock = self.save_lock.write().unwrap();
--+
--+        let mut serializable_map = SerializableState::default();
--+        for (k, v) in &self.inner.data {
--+            serializable_map.0.insert(hex::encode(k), hex::encode(v.as_ref()));
--+        }
--+
--+        let json_data = serde_json::to_string_pretty(&serializable_map)
--+            .map_err(|e| StateError::WriteError(e.to_string()))?;
--+        
--+        fs::write(&self.path, json_data)
--+            .map_err(|e| StateError::WriteError(e.to_string()))?;
--+
--+        Ok(())
--+    }
--+}
--+
--+// Delegate StateTree and StateManager traits to the inner HashMapStateTree.
--+impl<CS: CommitmentScheme + Clone> StateTree for FileStateTree<CS>
--+where
--+    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--+{
--+    type Commitment = CS::Commitment;
--+    type Proof = CS::Proof;
--+
--+    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--+        StateTree::get(&self.inner, key)
--+    }
--+
--+    fn insert(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--+        StateTree::insert(&mut self.inner, key, value)
--+    }
--+
--+    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--+        StateTree::delete(&mut self.inner, key)
--+    }
--+
--+    fn root_commitment(&self) -> Self::Commitment {
--+        StateTree::root_commitment(&self.inner)
--+    }
--+
--+    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--+        StateTree::create_proof(&self.inner, key)
--+    }
--+
--+    fn verify_proof(&self, commitment: &Self::Commitment, proof: &Self::Proof, key: &[u8], value: &[u8]) -> bool {
--+        StateTree::verify_proof(&self.inner, commitment, proof, key, value)
--+    }
--+
--+    fn as_any(&self) -> &dyn Any {
--+        self
--+    }
--+}
--+
--+impl<CS: CommitmentScheme + Clone> StateManager for FileStateTree<CS>
--+where
--+    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--+{
--+    type Commitment = CS::Commitment;
--+    type Proof = CS::Proof;
--+
--+    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, StateError> {
--+        <Self as StateTree>::get(self, key)
--+    }
--+
--+    fn set(&mut self, key: &[u8], value: &[u8]) -> Result<(), StateError> {
--+        <Self as StateTree>::insert(self, key, value)
--+    }
--+
--+    fn delete(&mut self, key: &[u8]) -> Result<(), StateError> {
--+        <Self as StateTree>::delete(self, key)
--+    }
--+
--+    fn root_commitment(&self) -> Self::Commitment {
--+        <Self as StateTree>::root_commitment(self)
--+    }
--+
--+    fn create_proof(&self, key: &[u8]) -> Option<Self::Proof> {
--+        <Self as StateTree>::create_proof(self, key)
--+    }
--+
--+    fn verify_proof(&self, commitment: &Self::Commitment, proof: &Self::Proof, key: &[u8], value: &[u8]) -> bool {
--+        <Self as StateTree>::verify_proof(self, commitment, proof, key, value)
--+    }
--+}
--+
--+// Automatically save the state when the FileStateTree is dropped.
--+// This is a safety net for graceful shutdowns.
--+impl<CS: CommitmentScheme + Clone> Drop for FileStateTree<CS>
--+where
--+    CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--+{
--+    fn drop(&mut self) {
--+        println!("Shutting down... saving final state to {:?}", self.path);
--+        if let Err(e) = self.save() {
--+            eprintln!("[Error] Failed to save state on shutdown: {}", e);
--+        }
--+    }
--+}```
--+
-- ###### Directory: state_trees/src/hashmap
-- 
-- ####### File: state_trees/src/hashmap/mod.rs
---####*Size: 4.0K, Lines: 120, Type: ASCII text*
--+####*Size: 4.0K, Lines: 131, Type: ASCII text*
-- 
-- ```rust
-- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-- use depin_sdk_core::error::StateError;
-- use depin_sdk_core::state::{StateManager, StateTree};
---// Removed unused import: std::any::Any
--+use std::any::Any;
-- use std::collections::HashMap;
-- 
-- /// HashMap-based state tree implementation
-- pub struct HashMapStateTree<CS: CommitmentScheme> {
---    /// Data store
---    data: HashMap<Vec<u8>, CS::Value>,
---    /// Commitment scheme
---    scheme: CS,
--+    /// Data store. Made `pub(crate)` to allow the `FileStateTree` wrapper to access it.
--+    pub(crate) data: HashMap<Vec<u8>, CS::Value>,
--+    /// Commitment scheme. Made `pub(crate)` for consistency.
--+    pub(crate) scheme: CS,
-- }
-- 
-- impl<CS: CommitmentScheme> HashMapStateTree<CS>
--@@ -12494,7 +12897,14 @@ where
--     }
-- 
--     fn root_commitment(&self) -> Self::Commitment {
---        let values: Vec<Option<CS::Value>> = self.data.values().map(|v| Some(v.clone())).collect();
--+        // Keys must be sorted to ensure a deterministic commitment.
--+        let mut sorted_keys: Vec<_> = self.data.keys().collect();
--+        sorted_keys.sort();
--+
--+        let values: Vec<Option<CS::Value>> = sorted_keys
--+            .iter()
--+            .map(|key| self.data.get(*key).cloned())
--+            .collect();
--         self.scheme.commit(&values)
--     }
-- 
--@@ -12521,6 +12931,10 @@ where
--         self.scheme
--             .verify(commitment, proof, &selector, &typed_value, &context)
--     }
--+
--+    fn as_any(&self) -> &dyn Any {
--+        self
--+    }
-- }
-- 
-- impl<CS: CommitmentScheme> StateManager for HashMapStateTree<CS>
--@@ -12565,14 +12979,14 @@ where
-- ###### Directory: state_trees/src/iavl
-- 
-- ####### File: state_trees/src/iavl/mod.rs
---####*Size: 8.0K, Lines: 146, Type: ASCII text*
--+####*Size: 8.0K, Lines: 150, Type: ASCII text*
-- 
-- ```rust
-- //! IAVL tree implementation
-- 
-- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-- use depin_sdk_core::error::StateError;
---use depin_sdk_core::state::StateTree;
--+use depin_sdk_core::state::{StateManager, StateTree};
-- use std::any::Any;
-- use std::collections::HashMap;
-- 
--@@ -12666,6 +13080,10 @@ where
--         self.scheme
--             .verify(commitment, proof, &selector, &scheme_value, &context)
--     }
--+
--+    fn as_any(&self) -> &dyn Any {
--+        self
--+    }
-- }
-- 
-- // Add support for tree-specific operations for IAVL
--@@ -12716,22 +13134,17 @@ where
--     }
-- }```
-- 
---####### File: state_trees/src/iavl/mod.rs:6:5
---####*Size: 0, Lines: 0, Type: empty*
---
---####*File content not included (exceeds threshold or non-text file)*
---
-- ###### Directory: state_trees/src/sparse_merkle
-- 
-- ####### File: state_trees/src/sparse_merkle/mod.rs
---####*Size: 4.0K, Lines: 135, Type: ASCII text*
--+####*Size: 4.0K, Lines: 139, Type: ASCII text*
-- 
-- ```rust
-- //! Sparse Merkle tree implementation
-- 
-- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-- use depin_sdk_core::error::StateError;
---use depin_sdk_core::state::StateTree;
--+use depin_sdk_core::state::{StateManager, StateTree};
-- use std::any::Any;
-- use std::collections::HashMap;
-- 
--@@ -12824,6 +13237,10 @@ where
--             &context,
--         )
--     }
--+
--+    fn as_any(&self) -> &dyn Any {
--+        self        
--+    }
-- }
-- 
-- // Add some utility methods for sparse Merkle trees
--@@ -12864,22 +13281,17 @@ where
--     }
-- }```
-- 
---####### File: state_trees/src/sparse_merkle/mod.rs:6:5
---####*Size: 0, Lines: 0, Type: empty*
---
---####*File content not included (exceeds threshold or non-text file)*
---
-- ###### Directory: state_trees/src/verkle
-- 
-- ####### File: state_trees/src/verkle/mod.rs
---####*Size: 8.0K, Lines: 144, Type: ASCII text*
--+####*Size: 8.0K, Lines: 148, Type: ASCII text*
-- 
-- ```rust
-- //! Verkle tree implementation
-- 
-- use depin_sdk_core::commitment::{CommitmentScheme, ProofContext, Selector};
-- use depin_sdk_core::error::StateError;
---use depin_sdk_core::state::StateTree;
--+use depin_sdk_core::state::{StateManager, StateTree};
-- use std::any::Any;
-- use std::collections::HashMap;
-- 
--@@ -12998,6 +13410,10 @@ where
--             false
--         }
--     }
--+
--+    fn as_any(&self) -> &dyn Any {
--+        self        
--+    }
-- }
-- 
-- // Helper methods to convert between Vec<u8> and CS::Value
--@@ -13021,18 +13437,8 @@ where
--     }
-- }```
-- 
---####### File: state_trees/src/verkle/mod.rs:142:8
---####*Size: 0, Lines: 0, Type: empty*
---
---####*File content not included (exceeds threshold or non-text file)*
---
---####### File: state_trees/src/verkle/mod.rs:6:5
---####*Size: 0, Lines: 0, Type: empty*
---
---####*File content not included (exceeds threshold or non-text file)*
---
-- ###### File: state_trees/src/lib.rs
---###*Size: 4.0K, Lines: 18, Type: ASCII text*
--+###*Size: 4.0K, Lines: 20, Type: ASCII text*
-- 
-- ```rust
-- //! # DePIN SDK State Trees
--@@ -13043,8 +13449,10 @@ pub mod hashmap;
-- pub mod iavl;
-- pub mod sparse_merkle;
-- pub mod verkle;
--+pub mod file;
-- 
-- // Re-export concrete implementations for convenience
--+pub use file::FileStateTree;
-- pub use hashmap::HashMapStateTree;
-- pub use iavl::IAVLTree;
-- pub use sparse_merkle::SparseMerkleTree;
--@@ -13056,7 +13464,7 @@ use depin_sdk_core::state::StateTree;
-- use std::any::Any;```
-- 
-- ##### File: state_trees/Cargo.toml
---##*Size: 4.0K, Lines: 20, Type: ASCII text*
--+##*Size: 4.0K, Lines: 22, Type: ASCII text*
-- 
-- ```toml
-- [package]
--@@ -13073,6 +13481,8 @@ log = { workspace = true }
-- serde = { workspace = true }
-- thiserror = { workspace = true }
-- bytes = { workspace = true }
--+serde_json = { workspace = true }
--+hex = { workspace = true }
-- 
-- [features]
-- default = []
--@@ -14195,11 +14605,14 @@ where
-- ###### Directory: transaction_models/src/utxo
-- 
-- ####### File: transaction_models/src/utxo/mod.rs
---####*Size: 20K, Lines: 570, Type: ASCII text*
--+####*Size: 20K, Lines: 578, Type: ASCII text*
-- 
-- ```rust
-- //! UTXO-based transaction model implementation.
-- 
--+use depin_sdk_core::crypto::SerializableKey;
--+use depin_sdk_core::crypto::VerifyingKey;
--+use depin_sdk_crypto::{algorithms::hash::sha256, sign::eddsa::{Ed25519PublicKey, Ed25519Signature}};
-- use depin_sdk_core::commitment::CommitmentScheme;
-- use depin_sdk_core::error::TransactionError;
-- use depin_sdk_core::state::StateManager;
--@@ -14208,7 +14621,7 @@ use std::any::Any;
-- use std::collections::HashMap;
-- 
-- /// UTXO transaction input
---#[derive(Debug, Clone)]
--+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-- pub struct UTXOInput {
--     /// Previous transaction ID
--     pub prev_txid: Vec<u8>,
--@@ -14219,7 +14632,7 @@ pub struct UTXOInput {
-- }
-- 
-- /// UTXO transaction output
---#[derive(Debug, Clone)]
--+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-- pub struct UTXOOutput {
--     /// Value of the output
--     pub value: u64,
--@@ -14228,7 +14641,7 @@ pub struct UTXOOutput {
-- }
-- 
-- /// UTXO transaction
---#[derive(Debug, Clone)]
--+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-- pub struct UTXOTransaction {
--     /// Transaction ID
--     pub txid: Vec<u8>,
--@@ -14456,13 +14869,18 @@ where
-- 
--             match utxo {
--                 Some(output) => {
---                    // TODO: Validate signatures
---                    // In a real implementation, you would:
---                    // 1. Check the signature against the lock_script
---                    // 2. Verify the public key matches
---                    // 3. Handle different script types (P2PKH, P2SH, etc.)
--+                    // Reconstruct the digest that was signed.
--+                    let mut digest_data = Vec::new();
--+                    digest_data.extend_from_slice(&input.prev_txid);
--+                    let digest = sha256(&digest_data);
--+
--+                    let public_key = Ed25519PublicKey::from_bytes(&output.lock_script).map_err(|e| TransactionError::InvalidSignature(e))?;
--+                    let signature = Ed25519Signature::from_bytes(&input.signature).map_err(|e| TransactionError::InvalidSignature(e))?;
--+
--+                    if !public_key.verify(&digest, &signature) {
--+                        return Err(TransactionError::InvalidSignature("Signature verification failed".to_string()));
--+                    }
-- 
---                    // Add to total input
--                     total_input = total_input.checked_add(output.value).ok_or_else(|| {
--                         TransactionError::InvalidTransaction("Input value overflow".to_string())
--                     })?;
--@@ -14806,7 +15224,7 @@ pub use utxo::UTXOOperations;
-- ```
-- 
-- ##### File: transaction_models/Cargo.toml
---##*Size: 4.0K, Lines: 21, Type: ASCII text*
--+##*Size: 4.0K, Lines: 22, Type: ASCII text*
-- 
-- ```toml
-- [package]
--@@ -14817,6 +15235,7 @@ description = "Transaction model implementations for the DePIN SDK"
-- license = "MIT OR Apache-2.0"
-- 
-- [dependencies]
--+depin-sdk-crypto = { path = "../crypto", optional = true }
-- depin-sdk-core = { path = "../core" }
-- log = { workspace = true }
-- serde = { workspace = true }
--@@ -14826,7 +15245,7 @@ anyhow = { workspace = true }
-- 
-- 
-- [features]
---default = []
--+default = ["dep:depin-sdk-crypto"]
-- utxo-model = []
-- account-model = []
-- hybrid-model = []
--diff --git a/crates/chain/src/app/mod.rs b/crates/chain/src/app/mod.rs
--index 65c4430..88a35c0 100644
----- a/crates/chain/src/app/mod.rs
--+++ b/crates/chain/src/app/mod.rs
--@@ -11,6 +11,23 @@ use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
-- use std::sync::Arc;
-- use std::time::{Duration, SystemTime, UNIX_EPOCH};
-- 
--+/// Custom error type for chain operations.
--+#[derive(Debug, thiserror::Error)]
--+pub enum ChainError {
--+    #[error("Validator operation failed: {0}")]
--+    Validator(String),
--+    #[error("Service operation failed: {0}")]
--+    Service(String),
--+    #[error("State operation failed: {0}")]
--+    State(#[from] depin_sdk_core::error::StateError),
--+    #[error("Transaction processing failed: {0}")]
--+    Transaction(String),
--+    #[error("Block processing failed: {0}")]
--+    Block(String),
--+    #[error("Module upgrade failed: {0}")]
--+    Upgrade(String),
--+}
--+
-- /// Block header containing metadata
-- #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
-- pub struct BlockHeader {
--@@ -231,15 +248,13 @@ where
--     }
-- 
--     /// Update state directly (administrative function)
---    pub fn update_state(&mut self, key: &[u8], value: &[u8]) -> Result<(), String> {
---        <ST as StateTree>::insert(&mut self.state_tree, key, value)
---            .map_err(|e| format!("State error: {}", e))
--+    pub fn update_state(&mut self, key: &[u8], value: &[u8]) -> Result<(), ChainError> {
--+        <ST as StateTree>::insert(&mut self.state_tree, key, value).map_err(ChainError::from)
--     }
-- 
--     /// Delete a key from state (administrative function)
---    pub fn delete_state(&mut self, key: &[u8]) -> Result<(), String> {
---        <ST as StateTree>::delete(&mut self.state_tree, key)
---            .map_err(|e| format!("State error: {}", e))
--+    pub fn delete_state(&mut self, key: &[u8]) -> Result<(), ChainError> {
--+        <ST as StateTree>::delete(&mut self.state_tree, key).map_err(ChainError::from)
--     }
-- 
--     //
--@@ -247,16 +262,16 @@ where
--     //
-- 
--     /// Process a transaction
---    pub fn process_transaction(&mut self, tx: &TM::Transaction) -> Result<(), String> {
--+    pub fn process_transaction(&mut self, tx: &TM::Transaction) -> Result<(), ChainError> {
--         // Validate the transaction against current state
--         // Pass the state_tree itself, not just the commitment
--         match self.transaction_model.validate(tx, &self.state_tree) {
--             Ok(valid) => {
--                 if !valid {
---                    return Err("Transaction validation failed".to_string());
--+                    return Err(ChainError::Transaction("Transaction validation failed".to_string()));
--                 }
--             }
---            Err(e) => return Err(format!("Validation error: {}", e)),
--+            Err(e) => return Err(ChainError::Transaction(format!("Validation error: {}", e))),
--         }
-- 
--         // Apply the transaction to state - map error to String
--@@ -266,18 +281,18 @@ where
--                 self.status.total_transactions += 1;
--                 Ok(())
--             }
---            Err(e) => Err(format!("Transaction application failed: {}", e)),
--+            Err(e) => Err(ChainError::Transaction(format!("Transaction application failed: {}", e))),
--         }
--     }
-- 
--     /// Process a batch of transactions
---    pub fn process_transactions(&mut self, txs: &[TM::Transaction]) -> Result<Vec<String>, String> {
--+    pub fn process_transactions(&mut self, txs: &[TM::Transaction]) -> Result<Vec<String>, ChainError> {
--         let mut results = Vec::with_capacity(txs.len());
-- 
--         for tx in txs {
--             match self.process_transaction(tx) {
--                 Ok(()) => results.push("Success".to_string()),
---                Err(e) => results.push(e),
--+                Err(e) => results.push(e.to_string()),
--             }
--         }
-- 
--@@ -289,18 +304,18 @@ where
--     //
-- 
--     /// Process a block
---    pub fn process_block(&mut self, mut block: Block<TM::Transaction>) -> Result<(), String>
--+    pub fn process_block(&mut self, mut block: Block<TM::Transaction>) -> Result<(), ChainError>
--     where
--         CS: Clone,
--         CS::Value: From<Vec<u8>> + AsRef<[u8]> + Clone,
--     {
--         // Ensure block is built on current chain state
--         if block.header.height != self.status.height + 1 {
---            return Err(format!(
--+            return Err(ChainError::Block(format!(
--                 "Invalid block height: expected {}, got {}",
--                 self.status.height + 1,
--                 block.header.height
---            ));
--+            )));
--         }
-- 
--         // Verify block timestamp is reasonable
--@@ -311,14 +326,14 @@ where
-- 
--         if block.header.timestamp > now + 60 {
--             // Allow 1 minute clock drift
---            return Err("Block timestamp is in the future".to_string());
--+            return Err(ChainError::Block("Block timestamp is in the future".to_string()));
--         }
-- 
--         // Validate block using validator_model
--         if !self.validator_model.is_running() {
--             self.validator_model
--                 .start()
---                .map_err(|e| format!("Failed to start validator: {}", e))?;
--+                .map_err(|e| ChainError::Validator(format!("Failed to start validator: {}", e)))?;
--         }
-- 
--         // Process all transactions
--@@ -328,7 +343,7 @@ where
--                 Ok(()) => tx_results.push(true),
--                 Err(e) => {
--                     tx_results.push(false);
---                    return Err(format!("Transaction processing failed: {}", e));
--+                    return Err(ChainError::Transaction(format!("Transaction processing failed: {}", e)));
--                 }
--             }
--         }
--@@ -352,7 +367,7 @@ where
--                 }
--             }
--             Err(e) => {
---                return Err(format!("Failed to apply module upgrades: {}", e));
--+                return Err(ChainError::Upgrade(format!("Failed to apply module upgrades: {}", e)));
--             }
--         }
-- 
--@@ -433,18 +448,18 @@ where
--     //
-- 
--     /// Start the chain with proper initialization
---    pub fn start(&mut self) -> Result<(), String> {
--+    pub fn start(&mut self) -> Result<(), ChainError> {
--         println!("Starting sovereign app chain: {}", self.chain_id);
-- 
--         // Initialize validator
--         self.validator_model
--             .start()
---            .map_err(|e| format!("Failed to start validator: {}", e))?;
--+            .map_err(|e| ChainError::Validator(format!("Failed to start validator: {}", e)))?;
-- 
--         // Start all registered services
--         self.service_manager
--             .start_all_services()
---            .map_err(|e| format!("Failed to start services: {}", e))?;
--+            .map_err(|e| ChainError::Service(format!("Failed to start services: {}", e)))?;
-- 
--         // Initialize state (in a real implementation, would load from persistent storage)
--         // For now, we'll just use the existing state
--@@ -465,18 +480,18 @@ where
--     }
-- 
--     /// Stop the chain
---    pub fn stop(&mut self) -> Result<(), String> {
--+    pub fn stop(&mut self) -> Result<(), ChainError> {
--         println!("Stopping sovereign app chain: {}", self.chain_id);
-- 
--         // Stop all services
--         self.service_manager
--             .stop_all_services()
---            .map_err(|e| format!("Failed to stop services: {}", e))?;
--+            .map_err(|e| ChainError::Service(format!("Failed to stop services: {}", e)))?;
-- 
--         // Stop the validator
--         self.validator_model
--             .stop()
---            .map_err(|e| format!("Failed to stop validator: {}", e))?;
--+            .map_err(|e| ChainError::Validator(format!("Failed to stop validator: {}", e)))?;
-- 
--         // In a real implementation, we would:
--         // 1. Persist state to storage
--@@ -495,7 +510,7 @@ where
--     }
-- 
--     /// Reset the chain (for testing purposes)
---    pub fn reset(&mut self) -> Result<(), String> {
--+    pub fn reset(&mut self) -> Result<(), ChainError> {
--         // Stop the chain if running
--         if self.status.is_running {
--             self.stop()?;
--@@ -503,7 +518,7 @@ where
-- 
--         // Reset service manager
--         self.service_manager.reset()
---            .map_err(|e| format!("Failed to reset service manager: {}", e))?;
--+            .map_err(|e| ChainError::Service(format!("Failed to reset service manager: {}", e)))?;
-- 
--         // Reset state (implementation would depend on how ST can be reset)
--         // For demonstration purposes, assuming ST has no reset method
--diff --git a/crates/chain/src/bin/mvsc.rs b/crates/chain/src/bin/mvsc.rs
--index f3adf74..45253d9 100644
----- a/crates/chain/src/bin/mvsc.rs
--+++ b/crates/chain/src/bin/mvsc.rs
--@@ -8,24 +8,20 @@
-- //! 3. Gossip new blocks to peers using libp2p.
-- //! 4. Process blocks received from peers.
-- 
--+use anyhow::anyhow;
-- use clap::Parser;
---use depin_sdk_chain::app::{Block, SovereignAppChain};
--+use depin_sdk_chain::app::SovereignAppChain;
-- use depin_sdk_commitment_schemes::hash::HashCommitmentScheme;
---use depin_sdk_core::crypto::{SerializableKey, SigningKeyPair, SigningKey};
---use depin_sdk_core::validator::{ValidatorModel, ValidatorType};
---use depin_sdk_crypto::algorithms::hash::sha256;
---use depin_sdk_crypto::sign::eddsa::{Ed25519KeyPair, Ed25519PrivateKey};
-- use depin_sdk_state_trees::file::FileStateTree; // Use our new FileStateTree
---use depin_sdk_transaction_models::utxo::{UTXOInput, UTXOOutput, UTXOTransaction, UTXOModel, UTXOOperations};
---use std::fs;
--+use depin_sdk_transaction_models::utxo::{UTXOModel, UTXOTransaction};
--+use depin_sdk_validator::standard::StandardValidator;
-- 
-- use futures::stream::StreamExt;
-- use libp2p::{gossipsub, mdns, swarm::SwarmEvent};
-- use std::hash::{Hash, Hasher};
---use std::sync::{atomic::{AtomicU64, Ordering}, Arc};
--+use std::sync::Arc;
-- use std::time::Duration;
---use tokio::sync::{mpsc, Mutex, Notify};
---
--+use tokio::sync::Mutex;
-- 
-- // --- LIBP2P NETWORKING SETUP ---
-- 
--@@ -37,7 +33,6 @@ struct MyBehaviour {
-- }
-- 
-- const BLOCK_TOPIC: &str = "blocks";
---const KEYPAIR_SEED_FILE: &str = "keypair.seed";
-- 
-- // --- COMMAND LINE ARGUMENTS ---
-- 
--@@ -48,105 +43,15 @@ struct Opts {
--     #[clap(long, default_value = "0")]
--     listen_port: u16,
-- 
---    /// Flag to indicate if this node should produce blocks.
---    #[clap(long)]
---    is_producer: bool,
---
--     /// Path to the state file.
--     #[clap(long, default_value = "state.json")]
--     state_file: String,
-- 
---    /// Path to the keypair seed file.
---    #[clap(long, default_value = "keypair.seed")]
---    keypair_file: String,
---}
---
---
---// --- MOCK VALIDATOR MODEL ---
---// A simple validator model implementation for the in-memory chain.
---struct MockValidatorModel {
---    running: std::cell::RefCell<bool>,
---}
---
---impl MockValidatorModel {
---    fn new() -> Self { Self { running: std::cell::RefCell::new(false) } }
---}
---
---impl ValidatorModel for MockValidatorModel {
---    fn start(&self) -> Result<(), String> { *self.running.borrow_mut() = true; Ok(()) }
---    fn stop(&self) -> Result<(), String> { *self.running.borrow_mut() = false; Ok(()) }
---    fn is_running(&self) -> bool { *self.running.borrow() }
---    fn validator_type(&self) -> ValidatorType { ValidatorType::Standard }
---}
---
---// --- TRANSACTION CREATION HELPERS ---
---fn create_dummy_transaction(
---    keypair: &Ed25519KeyPair,
---    nonce: u64,
---    prev_txid: Vec<u8>,
---) -> UTXOTransaction {
---    let mut tx = UTXOTransaction {
---        txid: Vec::new(),
---        inputs: vec![UTXOInput {
---            prev_txid,
---            prev_index: 0,
---            signature: Vec::new(),
---        }],
---        outputs: vec![UTXOOutput {
---            value: 100,
---            lock_script: keypair.public_key().to_bytes(),
---        }],
---    };
---    let mut digest_data = Vec::new();
---    digest_data.extend_from_slice(&tx.inputs[0].prev_txid);
---    
---    let digest = sha256(&digest_data);
---    let signature = keypair.sign(&digest);
---    tx.inputs[0].signature = signature.to_bytes();
---    let mut txid_data = Vec::new();
---    txid_data.extend_from_slice(&digest);
---    txid_data.extend_from_slice(&tx.inputs[0].signature);
---    tx.txid = sha256(&txid_data);
---    tx
--+    /// Path to the directory containing validator configuration files (guardian.toml, orchestration.toml, workload.toml).
--+    #[clap(long, default_value = "./config")]
--+    config_dir: String,
-- }
-- 
---fn create_genesis_transaction(keypair: &Ed25519KeyPair) -> UTXOTransaction {
---    let mut tx = UTXOTransaction {
---        txid: Vec::new(),
---        inputs: vec![],
---        outputs: vec![UTXOOutput {
---            value: 1_000_000,
---            lock_script: keypair.public_key().to_bytes(),
---        }],
---    };
---    let mut digest_data = Vec::new();
---    digest_data.extend_from_slice(b"GENESIS");
---    digest_data.extend_from_slice(&tx.outputs[0].value.to_le_bytes());
---    digest_data.extend_from_slice(&tx.outputs[0].lock_script);
---    tx.txid = sha256(&digest_data);
---    tx
---}
---
---/// Loads a keypair from a seed file, or creates a new one if it doesn't exist.
---fn load_or_create_keypair(path: &str) -> Ed25519KeyPair {
---    match fs::read(path) {
---        Ok(seed_bytes) => {
---            log::info!("Loading persistent keypair from {}", path);
---            let private_key = Ed25519PrivateKey::from_bytes(&seed_bytes)
---                .expect("Failed to create private key from seed file");
---            Ed25519KeyPair::from_private_key(&private_key)
---        }
---        Err(_) => {
---            log::info!("No keypair found at {}, creating a new one.", path);
---            let keypair = Ed25519KeyPair::generate();
---            fs::write(path, keypair.private_key().to_bytes())
---                .expect("Failed to write new keypair seed to file");
---            keypair
---        }
---    }
---}
---
---
-- // --- MAIN APPLICATION ---
-- #[tokio::main]
-- async fn main() -> anyhow::Result<()> {
--@@ -158,7 +63,8 @@ async fn main() -> anyhow::Result<()> {
--     let commitment_scheme = HashCommitmentScheme::new();
--     let state_tree = FileStateTree::new(&opts.state_file, commitment_scheme.clone());
--     let transaction_model = UTXOModel::new(commitment_scheme.clone());
---    let validator_model = MockValidatorModel::new();
--+    let validator_model =
--+        StandardValidator::new(&opts.config_dir).map_err(|e| anyhow!(e))?;
-- 
--     let chain = Arc::new(Mutex::new(SovereignAppChain::new(
--         commitment_scheme,
--@@ -169,6 +75,9 @@ async fn main() -> anyhow::Result<()> {
--         vec![],
--     )));
-- 
--+    // Start the validator model, which in turn starts its containers.
--+    chain.lock().await.start().map_err(|e| anyhow!(e))?;
--+
--     // --- P2P NETWORK SETUP ---
--     let mut swarm = libp2p::SwarmBuilder::with_new_identity()
--         .with_tokio()
--@@ -179,7 +88,7 @@ async fn main() -> anyhow::Result<()> {
--         )?
--         .with_behaviour(|key| {
--             let message_id_fn = |message: &gossipsub::Message| {
---                let mut s = std::collections::hash_map::DefaultHasher::new();
--+                let mut s = std::hash::DefaultHasher::new();
--                 message.data.hash(&mut s);
--                 gossipsub::MessageId::from(s.finish().to_string())
--             };
--@@ -198,7 +107,7 @@ async fn main() -> anyhow::Result<()> {
--         })?
--         .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
--         .build();
---    
--+
--     let topic = gossipsub::IdentTopic::new(BLOCK_TOPIC);
--     swarm.behaviour_mut().gossipsub.subscribe(&topic)?;
-- 
--@@ -206,97 +115,6 @@ async fn main() -> anyhow::Result<()> {
--     swarm.listen_on(listen_addr.parse()?)?;
--     log::info!("Local Peer ID: {}", swarm.local_peer_id());
-- 
---    // Channel for the block producer to send new blocks to the main event loop.
---    let (block_tx, mut block_rx) = mpsc::channel::<Vec<u8>>(32);
---
---    // Notifier to signal the producer task when it's okay to start.
---    let producer_start_signal = Arc::new(Notify::new());
---
---    // --- BLOCK PRODUCTION (if enabled) ---
---    if opts.is_producer {
---        let chain_clone = Arc::clone(&chain);
---        let start_signal_clone = Arc::clone(&producer_start_signal);
---        let keypair_file = opts.keypair_file.clone();
---        tokio::spawn(async move {
---            let keypair = load_or_create_keypair(&keypair_file);
---            let nonce = AtomicU64::new(0);
---            let mut last_txid: Vec<u8>;
---
---            // Create and process genesis block if chain is new
---            {
---                let mut chain_lock = chain_clone.lock().await;
---                if chain_lock.status().height == 0 {
---                    log::info!("Block producer is waiting for the first peer to connect...");
---                    start_signal_clone.notified().await;
---                    
---                    // Give gossipsub a moment to establish the connection fully.
---                    tokio::time::sleep(Duration::from_secs(2)).await;
---                    log::info!("Peer connected! Creating and gossiping genesis block.");
---
---                    log::info!("Chain is at genesis height, creating genesis block...");
---                    let genesis_tx = create_genesis_transaction(&keypair);
---                    last_txid = genesis_tx.txid.clone();
---                    let genesis_block = chain_lock.create_block(vec![genesis_tx]);
---                    chain_lock.process_block(genesis_block.clone()).expect("Failed to process genesis block");
---                    
---                    let block_bytes = serde_json::to_vec(&genesis_block).unwrap();
---                    if let Err(e) = block_tx.send(block_bytes).await {
---                         log::error!("Failed to send genesis block to main loop: {:?}", e);
---                    }
---                } else {
---                    log::info!("Chain is at height {}, resuming block production.", chain_lock.status().height);
---                    // Find the last UTXO owned by this keypair to continue the transaction chain.
---                    // This is a naive scan; a real wallet would use an index.
---                    let tm = chain_lock.transaction_model();
---                    let pk_bytes = keypair.public_key().to_bytes();
---                    
---                    // This is a placeholder for finding the last txid.
---                    // For this demo, we'll restart with a new "coinbase" tx in the next block.
---                    // A proper implementation would require iterating through the state.
---                    let coinbase_tx = create_genesis_transaction(&keypair);
---                    last_txid = coinbase_tx.txid.clone();
---                    let block = chain_lock.create_block(vec![coinbase_tx]);
---                    chain_lock.process_block(block).expect("Failed to create resumption block");
---                }
---            }
---
---
---            let mut interval = tokio::time::interval(Duration::from_secs(5));
---            loop {
---                interval.tick().await;
---                let current_nonce = nonce.fetch_add(1, Ordering::SeqCst);
---                let dummy_tx = create_dummy_transaction(&keypair, current_nonce, last_txid.clone());
---                last_txid = dummy_tx.txid.clone();
---
---                let mut chain_lock = chain_clone.lock().await;
---                let block = chain_lock.create_block(vec![dummy_tx]);
---                
---                log::info!("Producing Block #{}", block.header.height);
---
---                match chain_lock.process_block(block.clone()) {
---                    Ok(_) => {
---                        let status = chain_lock.status();
---                        let state_commitment = chain_lock.get_state_commitment();
---                        let state_root: &[u8] = state_commitment.as_ref();
---                        log::info!(
---                            "Locally processed Block #{}. New State Root: 0x{}",
---                            status.height,
---                            hex::encode(state_root)
---                        );
---
---                        let block_bytes = serde_json::to_vec(&block).unwrap();
---                        if let Err(e) = block_tx.send(block_bytes).await {
---                            log::error!("Failed to send block to main loop: {:?}", e);
---                        }
---                    }
---                    Err(e) => {
---                        log::error!("Error processing locally produced block: {}", e);
---                    }
---                }
---            }
---        });
---    }
---
--     // --- MAIN EVENT LOOP ---
--     loop {
--         tokio::select! {
--@@ -307,8 +125,6 @@ async fn main() -> anyhow::Result<()> {
--                         for (peer_id, _multiaddr) in list {
--                             log::info!("mDNS discovered a new peer: {}", peer_id);
--                             swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);
---
---                            producer_start_signal.notify_one();
--                         }
--                     }
--                     SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
--@@ -327,8 +143,8 @@ async fn main() -> anyhow::Result<()> {
--                             id,
--                             peer_id
--                         );
---                        
---                        type AppBlock = Block<UTXOTransaction>;
--+
--+                        type AppBlock = depin_sdk_chain::app::Block<UTXOTransaction>;
--                         match serde_json::from_slice::<AppBlock>(&message.data) {
--                             Ok(block) => {
--                                 let mut chain_lock = chain.lock().await;
--@@ -366,12 +182,6 @@ async fn main() -> anyhow::Result<()> {
--                     _ => {}
--                 }
--             },
---            // Handle blocks produced locally that need to be gossiped
---            Some(block_to_gossip) = block_rx.recv() => {
---                if let Err(e) = swarm.behaviour_mut().gossipsub.publish(topic.clone(), block_to_gossip) {
---                    log::error!("Failed to publish block: {:?}", e);
---                }
---            }
--         }
--     }
-- }
--\ No newline at end of file
--diff --git a/crates/core/src/error/mod.rs b/crates/core/src/error/mod.rs
--index 19d2830..94109af 100644
----- a/crates/core/src/error/mod.rs
--+++ b/crates/core/src/error/mod.rs
--@@ -90,6 +90,18 @@ impl From<StateError> for TransactionError {
--     }
-- }
-- 
--+/// Error type for validator operations.
--+#[derive(Debug, thiserror::Error)]
--+pub enum ValidatorError {
--+    #[error("Container operation failed: {0}")]
--+    Container(String),
--+    #[error("Configuration error: {0}")]
--+    Config(String),
--+    #[error("Lifecycle error: {0}")]
--+    Lifecycle(String),
--+}
--+
--+
-- /// Core error type for the SDK
-- #[derive(Debug, thiserror::Error)]
-- pub enum CoreError {
--diff --git a/crates/core/src/validator/container.rs b/crates/core/src/validator/container.rs
--index cee5c3f..34be8ae 100644
----- a/crates/core/src/validator/container.rs
--+++ b/crates/core/src/validator/container.rs
--@@ -1,12 +1,13 @@
-- //! Container interface definitions
--+use crate::error::ValidatorError;
-- 
-- /// Container interface
-- pub trait Container {
--     /// Start the container
---    fn start(&self) -> Result<(), String>;
--+    fn start(&self) -> Result<(), ValidatorError>;
--     
--     /// Stop the container
---    fn stop(&self) -> Result<(), String>;
--+    fn stop(&self) -> Result<(), ValidatorError>;
--     
--     /// Check if the container is running
--     fn is_running(&self) -> bool;
--@@ -18,8 +19,8 @@ pub trait Container {
-- /// Guardian container interface
-- pub trait GuardianContainer: Container {
--     /// Start the boot process
---    fn start_boot(&self) -> Result<(), String>;
--+    fn start_boot(&self) -> Result<(), ValidatorError>;
--     
--     /// Verify attestation
---    fn verify_attestation(&self) -> Result<bool, String>;
---}
--+    fn verify_attestation(&self) -> Result<bool, ValidatorError>;
--+}
--\ No newline at end of file
--diff --git a/crates/core/src/validator/types.rs b/crates/core/src/validator/types.rs
--index 2fd7aae..bc5af6a 100644
----- a/crates/core/src/validator/types.rs
--+++ b/crates/core/src/validator/types.rs
--@@ -1,12 +1,13 @@
-- //! Validator type definitions
--+use crate::error::ValidatorError;
-- 
-- /// Validator model trait
-- pub trait ValidatorModel {
--     /// Start the validator
---    fn start(&self) -> Result<(), String>;
--+    fn start(&self) -> Result<(), ValidatorError>;
--     
--     /// Stop the validator
---    fn stop(&self) -> Result<(), String>;
--+    fn stop(&self) -> Result<(), ValidatorError>;
--     
--     /// Check if the validator is running
--     fn is_running(&self) -> bool;
--@@ -22,4 +23,4 @@ pub enum ValidatorType {
--     Standard,
--     /// Hybrid validator (5 containers)
--     Hybrid,
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/bin/validator.rs b/crates/validator/src/bin/validator.rs
--index b7f5a20..518aedf 100644
----- a/crates/validator/src/bin/validator.rs
--+++ b/crates/validator/src/bin/validator.rs
--@@ -1,11 +1,12 @@
-- //! Standard validator binary
-- 
--+use depin_sdk_core::validator::{Container, ValidatorModel};
-- use depin_sdk_validator::standard::StandardValidator;
-- use std::env;
-- use std::path::Path;
-- 
-- #[tokio::main]
---async fn main() -> Result<(), Box<dyn std::error::Error>> {
--+async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
--     // Parse command-line arguments
--     let args: Vec<String> = env::args().collect();
--     let container_type = if args.len() > 1 { &args[1] } else { "all" };
--@@ -22,8 +23,8 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--             // Start only the guardian container
--             let path = Path::new(&config_dir);
--             let guardian =
---                depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"));
---            guardian.start_boot()?;
--+                depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"))?;
--+            guardian.start()?;
-- 
--             // Keep the process running
--             loop {
--@@ -35,7 +36,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--             let path = Path::new(&config_dir);
--             let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(
--                 path.join("orchestration.toml"),
---            );
--+            )?;
--             orchestration.start()?;
-- 
--             // Keep the process running
--@@ -47,7 +48,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--             // Start only the workload container
--             let path = Path::new(&config_dir);
--             let workload =
---                depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"));
--+                depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"))?;
--             workload.start()?;
-- 
--             // Keep the process running
--@@ -79,4 +80,4 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--             }
--         }
--     }
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/bin/validator_hybrid.rs b/crates/validator/src/bin/validator_hybrid.rs
--index 4aedf4a..470c370 100644
----- a/crates/validator/src/bin/validator_hybrid.rs
--+++ b/crates/validator/src/bin/validator_hybrid.rs
--@@ -3,9 +3,10 @@
-- use std::env;
-- use std::path::Path;
-- use depin_sdk_validator::hybrid::HybridValidator;
--+use depin_sdk_core::validator::{Container, ValidatorModel};
-- 
-- #[tokio::main]
---async fn main() -> Result<(), Box<dyn std::error::Error>> {
--+async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
--     // Parse command-line arguments
--     let args: Vec<String> = env::args().collect();
--     let container_type = if args.len() > 1 { &args[1] } else { "all" };
--@@ -21,8 +22,8 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--         "guardian" => {
--             // Start only the guardian container
--             let path = Path::new(&config_dir);
---            let guardian = depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"));
---            guardian.start_boot()?;
--+            let guardian = depin_sdk_validator::common::GuardianContainer::new(path.join("guardian.toml"))?;
--+            guardian.start()?;
--             
--             // Keep the process running
--             loop {
--@@ -32,7 +33,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--         "orchestration" => {
--             // Start only the orchestration container
--             let path = Path::new(&config_dir);
---            let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(path.join("orchestration.toml"));
--+            let orchestration = depin_sdk_validator::standard::OrchestrationContainer::new(path.join("orchestration.toml"))?;
--             orchestration.start()?;
--             
--             // Keep the process running
--@@ -43,7 +44,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--         "workload" => {
--             // Start only the workload container
--             let path = Path::new(&config_dir);
---            let workload = depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"));
--+            let workload = depin_sdk_validator::standard::WorkloadContainer::new(path.join("workload.toml"))?;
--             workload.start()?;
--             
--             // Keep the process running
--@@ -54,7 +55,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--         "interface" => {
--             // Start only the interface container
--             let path = Path::new(&config_dir);
---            let interface = depin_sdk_validator::hybrid::InterfaceContainer::new(path.join("interface.toml"));
--+            let interface = depin_sdk_validator::hybrid::InterfaceContainer::new(path.join("interface.toml"))?;
--             interface.start()?;
--             
--             // Keep the process running
--@@ -65,7 +66,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--         "api" => {
--             // Start only the API container
--             let path = Path::new(&config_dir);
---            let api = depin_sdk_validator::hybrid::ApiContainer::new(path.join("api.toml"));
--+            let api = depin_sdk_validator::hybrid::ApiContainer::new(path.join("api.toml"))?;
--             api.start()?;
--             
--             // Keep the process running
--@@ -85,4 +86,4 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
--             }
--         },
--     }
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/common/guardian.rs b/crates/validator/src/common/guardian.rs
--index 0eb65b8..c6008b0 100644
----- a/crates/validator/src/common/guardian.rs
--+++ b/crates/validator/src/common/guardian.rs
--@@ -1,13 +1,16 @@
-- //! Implementation of the guardian container
-- 
---use std::path::Path;
--+use crate::config::GuardianConfig;
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::{Container, GuardianContainer as GuardianTrait};
-- use std::error::Error;
--+use std::path::Path;
-- use std::sync::{Arc, Mutex};
-- 
-- /// Guardian container for security, boot process, and attestation
-- pub struct GuardianContainer {
---    /// Configuration path
---    config_path: String,
--+    /// Parsed configuration for the Guardian.
--+    config: GuardianConfig,
--     /// Boot status
--     boot_status: Arc<Mutex<BootStatus>>,
-- }
--@@ -26,42 +29,58 @@ pub enum BootStatus {
-- }
-- 
-- impl GuardianContainer {
---    /// Create a new guardian container
---    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
---        Self {
---            config_path: config_path.as_ref().to_string_lossy().to_string(),
--+    /// Create a new guardian container from a config file.
--+    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--+        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--+        let config: GuardianConfig = toml::from_str(&config_str)?;
--+
--+        println!(
--+            "Guardian config loaded. Signature policy: {:?}",
--+            config.signature_policy
--+        );
--+
--+        Ok(Self {
--+            config,
--             boot_status: Arc::new(Mutex::new(BootStatus::NotStarted)),
---        }
--+        })
--     }
--     
---    /// Start the boot process
---    pub fn start_boot(&self) -> Result<(), Box<dyn Error>> {
--+    /// Get the current boot status
--+    pub fn boot_status(&self) -> BootStatus {
--+        *self.boot_status.lock().unwrap()
--+    }
--+}
--+
--+impl Container for GuardianContainer {
--+    fn start(&self) -> Result<(), ValidatorError> {
--+        self.start_boot()
--+    }
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--+        println!("Guardian container stopped.");
--+        Ok(())
--+    }
--+
--+    fn is_running(&self) -> bool {
--+        *self.boot_status.lock().unwrap() == BootStatus::Completed
--+    }
--+
--+    fn id(&self) -> &str {
--+        "guardian"
--+    }
--+}
--+
--+impl GuardianTrait for GuardianContainer {
--+    fn start_boot(&self) -> Result<(), ValidatorError> {
--         let mut status = self.boot_status.lock().unwrap();
--         *status = BootStatus::InProgress;
---        
---        // Perform boot process (simplified for initial setup)
--         println!("Guardian container starting boot process...");
---        
---        // In a real implementation, we would:
---        // 1. Verify hardware attestation
---        // 2. Check secure boot status
---        // 3. Initialize security boundaries
---        
--         *status = BootStatus::Completed;
--         println!("Guardian container boot process completed.");
---        
--         Ok(())
--     }
---    
---    /// Get the current boot status
---    pub fn boot_status(&self) -> BootStatus {
---        *self.boot_status.lock().unwrap()
---    }
---    
---    /// Verify attestation
---    pub fn verify_attestation(&self) -> Result<bool, Box<dyn Error>> {
---        // Simplified attestation verification for initial setup
---        // In a real implementation, we would verify hardware attestation
--+
--+    fn verify_attestation(&self) -> Result<bool, ValidatorError> {
--         Ok(true)
--     }
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/common/security.rs b/crates/validator/src/common/security.rs
--index fe6b35c..c0702e1 100644
----- a/crates/validator/src/common/security.rs
--+++ b/crates/validator/src/common/security.rs
--@@ -25,7 +25,7 @@ impl SecurityChannel {
--     }
--     
--     /// Establish the security channel
---    pub fn establish(&self) -> Result<(), Box<dyn Error>> {
--+    pub fn establish(&self) -> Result<(), Box<dyn Error + Send + Sync>> {
--         // Simplified channel establishment for initial setup
--         // In a real implementation, we would:
--         // 1. Perform mutual authentication
--@@ -38,7 +38,7 @@ impl SecurityChannel {
--     }
--     
--     /// Send data through the security channel
---    pub fn send(&self, data: &[u8]) -> Result<(), Box<dyn Error>> {
--+    pub fn send(&self, data: &[u8]) -> Result<(), Box<dyn Error + Send + Sync>> {
--         // Simplified sending for initial setup
--         println!("Sending {} bytes through channel {}", data.len(), self.channel_id);
--         
--@@ -46,11 +46,11 @@ impl SecurityChannel {
--     }
--     
--     /// Receive data from the security channel
---    pub fn receive(&self, max_size: usize) -> Result<Vec<u8>, Box<dyn Error>> {
--+    pub fn receive(&self, max_size: usize) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--         // Simplified receiving for initial setup
--         println!("Receiving up to {} bytes from channel {}", max_size, self.channel_id);
--         
--         // Return empty data for now
--         Ok(Vec::new())
--     }
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/hybrid/api.rs b/crates/validator/src/hybrid/api.rs
--index 1d889ef..ca9a27c 100644
----- a/crates/validator/src/hybrid/api.rs
--+++ b/crates/validator/src/hybrid/api.rs
--@@ -1,80 +1,67 @@
-- //! Implementation of API container
-- 
---use std::path::Path;
--+use crate::config::ApiConfig;
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::Container;
-- use std::error::Error;
--+use std::path::Path;
-- use std::sync::{Arc, Mutex};
-- 
-- /// API container for API implementation and state queries
-- pub struct ApiContainer {
---    /// Configuration path
---    config_path: String,
--+    /// Parsed configuration for the API container.
--+    config: ApiConfig,
--     /// Running status
--     running: Arc<Mutex<bool>>,
-- }
-- 
-- impl ApiContainer {
--     /// Create a new API container
---    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
---        Self {
---            config_path: config_path.as_ref().to_string_lossy().to_string(),
--+    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--+        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--+        let config: ApiConfig = toml::from_str(&config_str)?;
--+
--+        println!("API container config loaded. Listen address: {}", config.listen_address);
--+
--+        Ok(Self {
--+            config,
--             running: Arc::new(Mutex::new(false)),
--+        })
--+    }
--+    /// Handle an API request
--+    pub fn handle_request(&self, endpoint: &str, params: &[u8]) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--+        if !self.is_running() {
--+            return Err("API container is not running".into());
--         }
--+        println!("Handling API request to endpoint {}, {} bytes", endpoint, params.len());
--+        Ok(vec![9, 10, 11, 12])
--     }
---    
---    /// Start the API container
---    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--+    /// Check if the container is running
--+    pub fn is_running(&self) -> bool {
--+        *self.running.lock().unwrap()
--+    }
--+}
--+
--+impl Container for ApiContainer {
--+    fn start(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = true;
---        
---        println!("API container starting...");
---        
---        // In a real implementation, we would:
---        // 1. Initialize API endpoints
---        // 2. Connect to state storage
---        // 3. Start serving requests
---        
--         println!("API container started successfully");
---        
--         Ok(())
--     }
---    
---    /// Stop the API container
---    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = false;
---        
---        println!("API container stopping...");
---        
---        // In a real implementation, we would:
---        // 1. Gracefully shutdown API server
---        // 2. Close state connections
---        // 3. Clean up resources
---        
--         println!("API container stopped successfully");
---        
--         Ok(())
--     }
---    
---    /// Handle an API request
---    pub fn handle_request(&self, endpoint: &str, params: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
---        if !self.is_running() {
---            return Err("API container is not running".into());
---        }
---        
---        // Simplified API handling for initial setup
---        println!("Handling API request to endpoint {}, {} bytes", endpoint, params.len());
---        
---        // In a real implementation, we would:
---        // 1. Parse the request parameters
---        // 2. Execute the appropriate API function
---        // 3. Format and return the response
---        
---        // Return a dummy response for now
---        Ok(vec![9, 10, 11, 12])
--+
--+    fn is_running(&self) -> bool {
--+        self.is_running()
--     }
---    
---    /// Check if the container is running
---    pub fn is_running(&self) -> bool {
---        *self.running.lock().unwrap()
--+
--+    fn id(&self) -> &str {
--+        "api"
--     }
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/hybrid/interface.rs b/crates/validator/src/hybrid/interface.rs
--index 24e0c61..fed5918 100644
----- a/crates/validator/src/hybrid/interface.rs
--+++ b/crates/validator/src/hybrid/interface.rs
--@@ -1,82 +1,68 @@
-- //! Implementation of interface container
-- 
---use std::path::Path;
--+use crate::config::InterfaceConfig;
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::Container;
-- use std::error::Error;
---use std::sync::{Arc, Mutex};
-- use std::net::SocketAddr;
--+use std::path::Path;
--+use std::sync::{Arc, Mutex};
-- 
-- /// Interface container for connection handling and protocol routing
-- pub struct InterfaceContainer {
---    /// Configuration path
---    config_path: String,
--+    /// Parsed configuration for the Interface container.
--+    config: InterfaceConfig,
--     /// Running status
--     running: Arc<Mutex<bool>>,
-- }
-- 
-- impl InterfaceContainer {
--     /// Create a new interface container
---    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
---        Self {
---            config_path: config_path.as_ref().to_string_lossy().to_string(),
--+    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--+        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--+        let config: InterfaceConfig = toml::from_str(&config_str)?;
--+
--+        println!("Interface container config loaded. Listen address: {}", config.listen_address);
--+
--+        Ok(Self {
--+            config,
--             running: Arc::new(Mutex::new(false)),
--+        })
--+    }
--+    /// Handle a client connection
--+    pub fn handle_connection(&self, addr: SocketAddr, data: &[u8]) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--+        if !self.is_running() {
--+            return Err("Interface container is not running".into());
--         }
--+        println!("Handling connection from {}, {} bytes", addr, data.len());
--+        Ok(vec![5, 6, 7, 8])
--+    }
--+    /// Check if the container is running
--+    pub fn is_running(&self) -> bool {
--+        *self.running.lock().unwrap()
--     }
---    
---    /// Start the interface container
---    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--+}
--+
--+impl Container for InterfaceContainer {
--+    fn start(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = true;
---        
---        println!("Interface container starting...");
---        
---        // In a real implementation, we would:
---        // 1. Start listening for connections
---        // 2. Initialize protocol handlers
---        // 3. Set up routing logic
---        
--         println!("Interface container started successfully");
---        
--         Ok(())
--     }
---    
---    /// Stop the interface container
---    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = false;
---        
---        println!("Interface container stopping...");
---        
---        // In a real implementation, we would:
---        // 1. Close all connections
---        // 2. Stop listeners
---        // 3. Clean up resources
---        
--         println!("Interface container stopped successfully");
---        
--         Ok(())
--     }
---    
---    /// Handle a client connection
---    pub fn handle_connection(&self, addr: SocketAddr, data: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
---        if !self.is_running() {
---            return Err("Interface container is not running".into());
---        }
---        
---        // Simplified connection handling for initial setup
---        println!("Handling connection from {}, {} bytes", addr, data.len());
---        
---        // In a real implementation, we would:
---        // 1. Identify the protocol
---        // 2. Route to the appropriate handler
---        // 3. Process the request
---        // 4. Return the response
---        
---        // Return a dummy response for now
---        Ok(vec![5, 6, 7, 8])
--+
--+    fn is_running(&self) -> bool {
--+        self.is_running()
--     }
---    
---    /// Check if the container is running
---    pub fn is_running(&self) -> bool {
---        *self.running.lock().unwrap()
--+
--+    fn id(&self) -> &str {
--+        "interface"
--     }
---}
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/hybrid/mod.rs b/crates/validator/src/hybrid/mod.rs
--index fc0ac5b..06b0148 100644
----- a/crates/validator/src/hybrid/mod.rs
--+++ b/crates/validator/src/hybrid/mod.rs
--@@ -8,7 +8,8 @@ mod tests;
-- 
-- pub use interface::*;
-- pub use api::*;
---
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::{Container, ValidatorModel, ValidatorType};
-- use std::error::Error;
-- use std::path::Path;
-- use crate::common::{GuardianContainer, SecurityChannel};
--@@ -32,15 +33,15 @@ pub struct HybridValidator {
-- 
-- impl HybridValidator {
--     /// Create a new hybrid validator
---    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error>> {
--+    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--         let config_dir = config_dir.as_ref();
--         
--         // Create containers
---        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"));
---        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"));
---        let workload = WorkloadContainer::new(config_dir.join("workload.toml"));
---        let interface = InterfaceContainer::new(config_dir.join("interface.toml"));
---        let api = ApiContainer::new(config_dir.join("api.toml"));
--+        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"))?;
--+        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"))?;
--+        let workload = WorkloadContainer::new(config_dir.join("workload.toml"))?;
--+        let interface = InterfaceContainer::new(config_dir.join("interface.toml"))?;
--+        let api = ApiContainer::new(config_dir.join("api.toml"))?;
--         
--         // Create security channels
--         let mut security_channels = Vec::new();
--@@ -74,39 +75,50 @@ impl HybridValidator {
--             security_channels,
--         })
--     }
---    
---    /// Start the validator
---    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--+}
--+
--+impl ValidatorModel for HybridValidator {
--+    fn start(&self) -> Result<(), ValidatorError> {
--         // Start Guardian first
---        self.guardian.start_boot()?;
---        
--+        self.guardian.start()?;
--+
--         // Start Orchestration
--         self.orchestration.start()?;
---        
--+
--         // Start Workload
--         self.workload.start()?;
---        
--+
--         // Start Interface
--         self.interface.start()?;
---        
--+
--         // Start API
--         self.api.start()?;
---        
--+
--         println!("Hybrid validator started successfully");
---        
--         Ok(())
--     }
---    
---    /// Stop the validator
---    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--         // Stop in reverse order
--         self.api.stop()?;
--         self.interface.stop()?;
--         self.workload.stop()?;
--         self.orchestration.stop()?;
---        
--+        self.guardian.stop()?;
--+
--         println!("Hybrid validator stopped successfully");
---        
--         Ok(())
--     }
---}
--+
--+    fn is_running(&self) -> bool {
--+        self.guardian.is_running()
--+            && self.orchestration.is_running()
--+            && self.workload.is_running()
--+            && self.interface.is_running()
--+            && self.api.is_running()
--+    }
--+
--+    fn validator_type(&self) -> ValidatorType {
--+        ValidatorType::Hybrid
--+    }
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/lib.rs b/crates/validator/src/lib.rs
--index 99cc9b3..a2dcbc3 100644
----- a/crates/validator/src/lib.rs
--+++ b/crates/validator/src/lib.rs
--@@ -2,9 +2,10 @@
-- //!
-- //! Validator implementation with container architecture for the DePIN SDK.
-- 
--+pub mod config;
-- pub mod common;
-- pub mod standard;
-- pub mod hybrid;
-- 
-- use std::error::Error;
---use depin_sdk_core::validator::ValidatorModel;
--+use depin_sdk_core::validator::ValidatorModel;
--\ No newline at end of file
--diff --git a/crates/validator/src/standard/mod.rs b/crates/validator/src/standard/mod.rs
--index d777973..482ad8f 100644
----- a/crates/validator/src/standard/mod.rs
--+++ b/crates/validator/src/standard/mod.rs
--@@ -8,7 +8,8 @@ mod tests;
-- 
-- pub use orchestration::*;
-- pub use workload::*;
---
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::{Container, ValidatorModel, ValidatorType};
-- use std::error::Error;
-- use std::path::Path;
-- use crate::common::{GuardianContainer, SecurityChannel};
--@@ -27,13 +28,13 @@ pub struct StandardValidator {
-- 
-- impl StandardValidator {
--     /// Create a new standard validator
---    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error>> {
--+    pub fn new<P: AsRef<Path>>(config_dir: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--         let config_dir = config_dir.as_ref();
--         
--         // Create containers
---        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"));
---        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"));
---        let workload = WorkloadContainer::new(config_dir.join("workload.toml"));
--+        let guardian = GuardianContainer::new(config_dir.join("guardian.toml"))?;
--+        let orchestration = OrchestrationContainer::new(config_dir.join("orchestration.toml"))?;
--+        let workload = WorkloadContainer::new(config_dir.join("workload.toml"))?;
--         
--         // Create security channels
--         let mut security_channels = Vec::new();
--@@ -55,31 +56,38 @@ impl StandardValidator {
--             security_channels,
--         })
--     }
---    
---    /// Start the validator
---    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--+}
--+
--+impl ValidatorModel for StandardValidator {
--+    fn start(&self) -> Result<(), ValidatorError> {
--         // Start Guardian first
---        self.guardian.start_boot()?;
---        
--+        self.guardian.start()?;
--+
--         // Start Orchestration
--         self.orchestration.start()?;
---        
--+
--         // Start Workload
--         self.workload.start()?;
---        
--+
--         println!("Standard validator started successfully");
---        
--         Ok(())
--     }
---    
---    /// Stop the validator
---    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--         // Stop in reverse order
--         self.workload.stop()?;
--         self.orchestration.stop()?;
---        
--+        self.guardian.stop()?;
--+
--         println!("Standard validator stopped successfully");
---        
--         Ok(())
--     }
---}
--+
--+    fn is_running(&self) -> bool {
--+        self.guardian.is_running() && self.orchestration.is_running() && self.workload.is_running()
--+    }
--+
--+    fn validator_type(&self) -> ValidatorType {
--+        ValidatorType::Standard
--+    }
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/standard/orchestration.rs b/crates/validator/src/standard/orchestration.rs
--index fe6a19c..f97b91b 100644
----- a/crates/validator/src/standard/orchestration.rs
--+++ b/crates/validator/src/standard/orchestration.rs
--@@ -1,62 +1,60 @@
-- //! Implementation of orchestration container
-- 
---use std::path::Path;
--+use crate::config::OrchestrationConfig;
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::Container;
-- use std::error::Error;
--+use std::path::Path;
-- use std::sync::{Arc, Mutex};
-- 
-- /// Orchestration container for node functions and consensus
-- pub struct OrchestrationContainer {
---    /// Configuration path
---    config_path: String,
--+    /// Parsed configuration for the Orchestration container.
--+    config: OrchestrationConfig,
--     /// Running status
--     running: Arc<Mutex<bool>>,
-- }
-- 
-- impl OrchestrationContainer {
--     /// Create a new orchestration container
---    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
---        Self {
---            config_path: config_path.as_ref().to_string_lossy().to_string(),
--+    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--+        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--+        let config: OrchestrationConfig = toml::from_str(&config_str)?;
--+
--+        println!("Orchestration config loaded. Consensus type: {:?}", config.consensus_type);
--+
--+        Ok(Self {
--+            config,
--             running: Arc::new(Mutex::new(false)),
---        }
--+        })
--+    }
--+
--+    /// Check if the container is running
--+    pub fn is_running(&self) -> bool {
--+        *self.running.lock().unwrap()
--     }
---    
---    /// Start the orchestration container
---    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--+}
--+
--+impl Container for OrchestrationContainer {
--+    fn start(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = true;
---        
---        println!("Orchestration container starting...");
---        
---        // In a real implementation, we would:
---        // 1. Initialize consensus mechanism
---        // 2. Connect to peer network
---        // 3. Start block processing
---        
--         println!("Orchestration container started successfully");
---        
--         Ok(())
--     }
---    
---    /// Stop the orchestration container
---    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = false;
---        
---        println!("Orchestration container stopping...");
---        
---        // In a real implementation, we would:
---        // 1. Gracefully disconnect from network
---        // 2. Stop consensus mechanism
---        // 3. Save state
---        
--         println!("Orchestration container stopped successfully");
---        
--         Ok(())
--     }
---    
---    /// Check if the container is running
---    pub fn is_running(&self) -> bool {
---        *self.running.lock().unwrap()
--+
--+    fn is_running(&self) -> bool {
--+        self.is_running()
--     }
---}
--+
--+    fn id(&self) -> &str {
--+        "orchestration"
--+    }
--+}
--\ No newline at end of file
--diff --git a/crates/validator/src/standard/workload.rs b/crates/validator/src/standard/workload.rs
--index e59d436..75daef6 100644
----- a/crates/validator/src/standard/workload.rs
--+++ b/crates/validator/src/standard/workload.rs
--@@ -1,81 +1,67 @@
-- //! Implementation of workload container
-- 
---use std::path::Path;
--+use crate::config::WorkloadConfig;
--+use depin_sdk_core::error::ValidatorError;
--+use depin_sdk_core::validator::Container;
-- use std::error::Error;
--+use std::path::Path;
-- use std::sync::{Arc, Mutex};
-- 
-- /// Workload container for resource provisioning and execution
-- pub struct WorkloadContainer {
---    /// Configuration path
---    config_path: String,
--+    /// Parsed configuration for the Workload container.
--+    config: WorkloadConfig,
--     /// Running status
--     running: Arc<Mutex<bool>>,
-- }
-- 
-- impl WorkloadContainer {
--     /// Create a new workload container
---    pub fn new<P: AsRef<Path>>(config_path: P) -> Self {
---        Self {
---            config_path: config_path.as_ref().to_string_lossy().to_string(),
--+    pub fn new<P: AsRef<Path>>(config_path: P) -> Result<Self, Box<dyn Error + Send + Sync>> {
--+        let config_str = std::fs::read_to_string(config_path.as_ref())?;
--+        let config: WorkloadConfig = toml::from_str(&config_str)?;
--+
--+        println!("Workload config loaded. Enabled VMs: {:?}", config.enabled_vms);
--+
--+        Ok(Self {
--+            config,
--             running: Arc::new(Mutex::new(false)),
--+        })
--+    }
--+    /// Execute a transaction
--+    pub fn execute_transaction(&self, tx_data: &[u8]) -> Result<Vec<u8>, Box<dyn Error + Send + Sync>> {
--+        if !self.is_running() {
--+            return Err("Workload container is not running".into());
--         }
--+        println!("Executing transaction of {} bytes", tx_data.len());
--+        Ok(tx_data.to_vec())
--     }
---    
---    /// Start the workload container
---    pub fn start(&self) -> Result<(), Box<dyn Error>> {
--+    /// Check if the container is running
--+    pub fn is_running(&self) -> bool {
--+        *self.running.lock().unwrap()
--+    }
--+}
--+
--+impl Container for WorkloadContainer {
--+    fn start(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = true;
---        
---        println!("Workload container starting...");
---        
---        // In a real implementation, we would:
---        // 1. Initialize execution environment
---        // 2. Allocate resources
---        // 3. Start transaction processing
---        
--         println!("Workload container started successfully");
---        
--         Ok(())
--     }
---    
---    /// Stop the workload container
---    pub fn stop(&self) -> Result<(), Box<dyn Error>> {
--+
--+    fn stop(&self) -> Result<(), ValidatorError> {
--         let mut running = self.running.lock().unwrap();
--         *running = false;
---        
---        println!("Workload container stopping...");
---        
---        // In a real implementation, we would:
---        // 1. Gracefully stop transaction processing
---        // 2. Release resources
---        // 3. Save state
---        
--         println!("Workload container stopped successfully");
---        
--         Ok(())
--     }
---    
---    /// Execute a transaction
---    pub fn execute_transaction(&self, tx_data: &[u8]) -> Result<Vec<u8>, Box<dyn Error>> {
---        if !self.is_running() {
---            return Err("Workload container is not running".into());
---        }
---        
---        // Simplified transaction execution for initial setup
---        println!("Executing transaction of {} bytes", tx_data.len());
---        
---        // In a real implementation, we would:
---        // 1. Parse the transaction
---        // 2. Verify it against the state
---        // 3. Apply it to the state
---        // 4. Return the result
---        
---        // Return a dummy result for now
---        Ok(vec![1, 2, 3, 4])
--+
--+    fn is_running(&self) -> bool {
--+        self.is_running()
--     }
---    
---    /// Check if the container is running
---    pub fn is_running(&self) -> bool {
---        *self.running.lock().unwrap()
--+
--+    fn id(&self) -> &str {
--+        "workload"
--     }
---}
--+}
--\ No newline at end of file
diff --git a/state_node1.json b/state_node1.json
index b08865f..b39f4fb 100644
--- a/state_node1.json
+++ b/state_node1.json
@@ -12,7 +12,7 @@
       116,
       34,
       58,
-      55,
+      57,
       44,
       34,
       108,
@@ -37,12 +37,12 @@
       55,
       53,
       51,
+      56,
       55,
-      55,
-      57,
-      52,
-      57,
-      48,
+      50,
+      56,
+      51,
+      50,
       44,
       34,
       116,
@@ -65,7 +65,7 @@
       115,
       34,
       58,
-      55,
+      57,
       44,
       34,
       105,
@@ -87,7 +87,7 @@
       101,
       125
     ],
-    "751a94efc4d425ff450d8ab19de532aa4df747ab2ae56077830c8e5d133387f4e300000000": [
+    "759b62e6071d0b39f64bf4b0055571d29daac5760b18a6f823422e69782304c51800000000": [
       123,
       34,
       118,
@@ -114,8 +114,565 @@
       34,
       58,
       91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      51,
+      44,
+      49,
+      48,
+      54,
+      44,
+      53,
+      53,
+      44,
+      50,
+      52,
+      56,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      53,
+      48,
+      44,
+      53,
+      48,
+      44,
+      52,
+      55,
+      44,
+      50,
+      50,
+      50,
+      44,
+      50,
+      50,
+      57,
+      44,
+      52,
+      57,
+      44,
+      51,
+      54,
+      44,
+      49,
+      44,
+      49,
+      50,
+      55,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      55,
+      48,
+      44,
+      53,
+      53,
+      44,
+      49,
+      55,
+      54,
+      44,
+      50,
+      48,
+      51,
+      44,
+      49,
+      57,
+      44,
+      49,
+      50,
+      57,
+      44,
+      49,
+      57,
+      55,
+      44,
+      55,
+      48,
+      44,
+      49,
+      54,
+      51,
+      44,
+      50,
+      51,
+      56,
+      44,
+      51,
+      57,
+      44,
+      50,
+      49,
+      55,
+      44,
+      49,
+      52,
+      50,
+      44,
+      49,
+      49,
+      55,
+      44,
+      49,
+      54,
+      52,
+      44,
+      49,
+      57,
+      57,
+      44,
+      54,
+      48,
+      93,
+      125
+    ],
+    "754f73f5820c8d1d21535d6317239aea0fc336b08676cc6e3d30df8c1e20641ad200000000": [
+      123,
+      34,
+      118,
+      97,
+      108,
+      117,
+      101,
+      34,
+      58,
+      53,
+      48,
+      44,
+      34,
+      112,
+      117,
+      98,
+      108,
+      105,
+      99,
+      95,
+      107,
+      101,
+      121,
+      34,
+      58,
+      91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      48,
+      44,
+      49,
+      51,
+      51,
+      44,
+      49,
+      55,
+      48,
+      44,
+      50,
+      53,
+      49,
+      44,
+      49,
+      48,
+      56,
+      44,
+      49,
+      48,
+      55,
+      44,
+      49,
+      56,
+      54,
+      44,
+      49,
+      56,
+      51,
+      44,
+      53,
+      44,
+      50,
+      48,
+      55,
+      44,
+      49,
+      57,
+      44,
+      57,
+      56,
+      44,
+      50,
+      52,
+      51,
+      44,
+      49,
+      52,
+      53,
+      44,
+      50,
+      48,
+      52,
+      44,
+      51,
+      51,
+      44,
+      49,
+      49,
+      52,
+      44,
+      50,
+      52,
+      57,
+      44,
+      50,
+      54,
+      44,
+      49,
+      51,
+      52,
+      44,
+      49,
+      57,
+      44,
+      50,
+      50,
+      49,
+      44,
+      49,
+      50,
+      48,
+      44,
+      55,
+      55,
+      44,
+      54,
+      57,
+      44,
+      50,
+      50,
+      55,
+      44,
+      49,
+      56,
+      44,
+      49,
+      50,
+      52,
+      44,
+      50,
+      56,
+      44,
+      50,
+      48,
+      51,
+      44,
+      50,
+      49,
+      55,
+      44,
+      50,
+      52,
+      51,
       93,
       125
+    ],
+    "73797374656d3a3a76616c696461746f7273": [
+      91,
+      91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      48,
+      44,
+      49,
+      51,
+      51,
+      44,
+      49,
+      55,
+      48,
+      44,
+      50,
+      53,
+      49,
+      44,
+      49,
+      48,
+      56,
+      44,
+      49,
+      48,
+      55,
+      44,
+      49,
+      56,
+      54,
+      44,
+      49,
+      56,
+      51,
+      44,
+      53,
+      44,
+      50,
+      48,
+      55,
+      44,
+      49,
+      57,
+      44,
+      57,
+      56,
+      44,
+      50,
+      52,
+      51,
+      44,
+      49,
+      52,
+      53,
+      44,
+      50,
+      48,
+      52,
+      44,
+      51,
+      51,
+      44,
+      49,
+      49,
+      52,
+      44,
+      50,
+      52,
+      57,
+      44,
+      50,
+      54,
+      44,
+      49,
+      51,
+      52,
+      44,
+      49,
+      57,
+      44,
+      50,
+      50,
+      49,
+      44,
+      49,
+      50,
+      48,
+      44,
+      55,
+      55,
+      44,
+      54,
+      57,
+      44,
+      50,
+      50,
+      55,
+      44,
+      49,
+      56,
+      44,
+      49,
+      50,
+      52,
+      44,
+      50,
+      56,
+      44,
+      50,
+      48,
+      51,
+      44,
+      50,
+      49,
+      55,
+      44,
+      50,
+      52,
+      51,
+      93,
+      44,
+      91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      51,
+      44,
+      49,
+      48,
+      54,
+      44,
+      53,
+      53,
+      44,
+      50,
+      52,
+      56,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      53,
+      48,
+      44,
+      53,
+      48,
+      44,
+      52,
+      55,
+      44,
+      50,
+      50,
+      50,
+      44,
+      50,
+      50,
+      57,
+      44,
+      52,
+      57,
+      44,
+      51,
+      54,
+      44,
+      49,
+      44,
+      49,
+      50,
+      55,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      55,
+      48,
+      44,
+      53,
+      53,
+      44,
+      49,
+      55,
+      54,
+      44,
+      50,
+      48,
+      51,
+      44,
+      49,
+      57,
+      44,
+      49,
+      50,
+      57,
+      44,
+      49,
+      57,
+      55,
+      44,
+      55,
+      48,
+      44,
+      49,
+      54,
+      51,
+      44,
+      50,
+      51,
+      56,
+      44,
+      51,
+      57,
+      44,
+      50,
+      49,
+      55,
+      44,
+      49,
+      52,
+      50,
+      44,
+      49,
+      49,
+      55,
+      44,
+      49,
+      54,
+      52,
+      44,
+      49,
+      57,
+      57,
+      44,
+      54,
+      48,
+      93,
+      93
     ]
   }
 }
\ No newline at end of file
diff --git a/state_node2.json b/state_node2.json
index 761560d..970baf9 100644
--- a/state_node2.json
+++ b/state_node2.json
@@ -1,7 +1,7 @@
 {
   "path": "state_node2.json",
   "data": {
-    "751a94efc4d425ff450d8ab19de532aa4df747ab2ae56077830c8e5d133387f4e300000000": [
+    "754f73f5820c8d1d21535d6317239aea0fc336b08676cc6e3d30df8c1e20641ad200000000": [
       123,
       34,
       118,
@@ -28,6 +28,136 @@
       34,
       58,
       91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      48,
+      44,
+      49,
+      51,
+      51,
+      44,
+      49,
+      55,
+      48,
+      44,
+      50,
+      53,
+      49,
+      44,
+      49,
+      48,
+      56,
+      44,
+      49,
+      48,
+      55,
+      44,
+      49,
+      56,
+      54,
+      44,
+      49,
+      56,
+      51,
+      44,
+      53,
+      44,
+      50,
+      48,
+      55,
+      44,
+      49,
+      57,
+      44,
+      57,
+      56,
+      44,
+      50,
+      52,
+      51,
+      44,
+      49,
+      52,
+      53,
+      44,
+      50,
+      48,
+      52,
+      44,
+      51,
+      51,
+      44,
+      49,
+      49,
+      52,
+      44,
+      50,
+      52,
+      57,
+      44,
+      50,
+      54,
+      44,
+      49,
+      51,
+      52,
+      44,
+      49,
+      57,
+      44,
+      50,
+      50,
+      49,
+      44,
+      49,
+      50,
+      48,
+      44,
+      55,
+      55,
+      44,
+      54,
+      57,
+      44,
+      50,
+      50,
+      55,
+      44,
+      49,
+      56,
+      44,
+      49,
+      50,
+      52,
+      44,
+      50,
+      56,
+      44,
+      50,
+      48,
+      51,
+      44,
+      50,
+      49,
+      55,
+      44,
+      50,
+      52,
+      51,
       93,
       125
     ],
@@ -42,7 +172,8 @@
       116,
       34,
       58,
-      54,
+      49,
+      48,
       44,
       34,
       108,
@@ -67,12 +198,12 @@
       55,
       53,
       51,
+      56,
       55,
-      55,
-      57,
+      50,
+      56,
+      52,
       53,
-      48,
-      54,
       44,
       34,
       116,
@@ -95,7 +226,8 @@
       115,
       34,
       58,
-      54,
+      49,
+      48,
       44,
       34,
       105,
@@ -116,6 +248,433 @@
       115,
       101,
       125
+    ],
+    "73797374656d3a3a76616c696461746f7273": [
+      91,
+      91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      48,
+      44,
+      49,
+      51,
+      51,
+      44,
+      49,
+      55,
+      48,
+      44,
+      50,
+      53,
+      49,
+      44,
+      49,
+      48,
+      56,
+      44,
+      49,
+      48,
+      55,
+      44,
+      49,
+      56,
+      54,
+      44,
+      49,
+      56,
+      51,
+      44,
+      53,
+      44,
+      50,
+      48,
+      55,
+      44,
+      49,
+      57,
+      44,
+      57,
+      56,
+      44,
+      50,
+      52,
+      51,
+      44,
+      49,
+      52,
+      53,
+      44,
+      50,
+      48,
+      52,
+      44,
+      51,
+      51,
+      44,
+      49,
+      49,
+      52,
+      44,
+      50,
+      52,
+      57,
+      44,
+      50,
+      54,
+      44,
+      49,
+      51,
+      52,
+      44,
+      49,
+      57,
+      44,
+      50,
+      50,
+      49,
+      44,
+      49,
+      50,
+      48,
+      44,
+      55,
+      55,
+      44,
+      54,
+      57,
+      44,
+      50,
+      50,
+      55,
+      44,
+      49,
+      56,
+      44,
+      49,
+      50,
+      52,
+      44,
+      50,
+      56,
+      44,
+      50,
+      48,
+      51,
+      44,
+      50,
+      49,
+      55,
+      44,
+      50,
+      52,
+      51,
+      93,
+      44,
+      91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      51,
+      44,
+      49,
+      48,
+      54,
+      44,
+      53,
+      53,
+      44,
+      50,
+      52,
+      56,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      53,
+      48,
+      44,
+      53,
+      48,
+      44,
+      52,
+      55,
+      44,
+      50,
+      50,
+      50,
+      44,
+      50,
+      50,
+      57,
+      44,
+      52,
+      57,
+      44,
+      51,
+      54,
+      44,
+      49,
+      44,
+      49,
+      50,
+      55,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      55,
+      48,
+      44,
+      53,
+      53,
+      44,
+      49,
+      55,
+      54,
+      44,
+      50,
+      48,
+      51,
+      44,
+      49,
+      57,
+      44,
+      49,
+      50,
+      57,
+      44,
+      49,
+      57,
+      55,
+      44,
+      55,
+      48,
+      44,
+      49,
+      54,
+      51,
+      44,
+      50,
+      51,
+      56,
+      44,
+      51,
+      57,
+      44,
+      50,
+      49,
+      55,
+      44,
+      49,
+      52,
+      50,
+      44,
+      49,
+      49,
+      55,
+      44,
+      49,
+      54,
+      52,
+      44,
+      49,
+      57,
+      57,
+      44,
+      54,
+      48,
+      93,
+      93
+    ],
+    "759b62e6071d0b39f64bf4b0055571d29daac5760b18a6f823422e69782304c51800000000": [
+      123,
+      34,
+      118,
+      97,
+      108,
+      117,
+      101,
+      34,
+      58,
+      53,
+      48,
+      44,
+      34,
+      112,
+      117,
+      98,
+      108,
+      105,
+      99,
+      95,
+      107,
+      101,
+      121,
+      34,
+      58,
+      91,
+      48,
+      44,
+      51,
+      54,
+      44,
+      56,
+      44,
+      49,
+      44,
+      49,
+      56,
+      44,
+      51,
+      50,
+      44,
+      57,
+      51,
+      44,
+      49,
+      48,
+      54,
+      44,
+      53,
+      53,
+      44,
+      50,
+      52,
+      56,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      53,
+      48,
+      44,
+      53,
+      48,
+      44,
+      52,
+      55,
+      44,
+      50,
+      50,
+      50,
+      44,
+      50,
+      50,
+      57,
+      44,
+      52,
+      57,
+      44,
+      51,
+      54,
+      44,
+      49,
+      44,
+      49,
+      50,
+      55,
+      44,
+      49,
+      52,
+      48,
+      44,
+      49,
+      55,
+      48,
+      44,
+      53,
+      53,
+      44,
+      49,
+      55,
+      54,
+      44,
+      50,
+      48,
+      51,
+      44,
+      49,
+      57,
+      44,
+      49,
+      50,
+      57,
+      44,
+      49,
+      57,
+      55,
+      44,
+      55,
+      48,
+      44,
+      49,
+      54,
+      51,
+      44,
+      50,
+      51,
+      56,
+      44,
+      51,
+      57,
+      44,
+      50,
+      49,
+      55,
+      44,
+      49,
+      52,
+      50,
+      44,
+      49,
+      49,
+      55,
+      44,
+      49,
+      54,
+      52,
+      44,
+      49,
+      57,
+      57,
+      44,
+      54,
+      48,
+      93,
+      125
     ]
   }
 }
\ No newline at end of file
